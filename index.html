<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Operações | Aquisição <> Monetização</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.1.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        :root {
            --primary-color: #6a82fb;
            --text-color: #343a40;
            --text-light: #6c757d;
            --bg-body: #f8f9fa;
            --bg-light: #ffffff;
            --border-color: #e9ecef;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            --border-radius: 12px;
            --color-positive: #20c997;
            --color-negative: #e74c3c;
            --color-neutral: #ffc107;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-color);
            padding: 25px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        /* Layout Geral e Utilitários */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* --- ESTILOS PARA SUB-ABAS (DENTRO DE UMA VIEW SECTION) --- */
        .sub-nav-container {
            display: flex;
            gap: 5px;
            background-color: var(--bg-light);
            padding: 8px; /* Mais sutil que a nav principal */
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px; /* Espaço antes do conteúdo da sub-aba */
            border: 1px solid var(--border-color);
            flex-wrap: wrap; /* Permite quebrar linha se não couber */
        }

        .sub-nav-btn {
            flex-grow: 1; /* Ocupa espaço disponível */
            padding: 10px 15px; /* Ligeiramente menor */
            background: transparent;
            color: var(--text-light);
            font-weight: 600;
            font-size: 0.95em; /* Ligeiramente menor */
            border: none;
            border-radius: 8px; /* Menor raio */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-align: center;
             min-width: 150px; /* Largura mínima para evitar botões muito pequenos */
        }

        .sub-nav-btn:hover {
            background-color: #f1f3f5;
            color: var(--text-color);
        }

        .sub-nav-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 1px 4px rgba(106, 130, 251, 0.25); /* Sombra mais sutil */
        }

        .operacoes-sub-view {
            display: none; /* Esconde por padrão */
        }

        .operacoes-sub-view.active {
            display: block; /* Mostra a ativa */
        }
        /* --- FIM DOS ESTILOS PARA SUB-ABAS --- */

        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .section-title {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--text-color);
            margin: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }

        .chart-full {
            grid-column: 1 / -1;
        }

        /* Header e Controles */
        .header {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px 35px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        h1 {
            font-size: 1.8em;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .status {
            font-size: 0.9em;
            color: var(--text-light);
        }

        button {
            padding: 10px 25px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(106, 130, 251, 0.4);
        }

        /* Filtros Gerais (Topo) */
        .filters {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-group label {
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-light);
        }

        input[type="date"],
        select,
        input[type="search"] {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            width: 180px;
            background-color: #fff;
        }

        select {
            width: 220px;
        }


        /* Navbar e Abas */
        .main-nav {
            display: flex;
            gap: 5px;
            background-color: var(--bg-light);
            padding: 5px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .nav-btn {
            flex-grow: 1;
            padding: 12px 15px;
            background: transparent;
            color: var(--text-light);
            font-weight: 600;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
        }

        .nav-btn:hover {
            background-color: #f1f3f5;
            color: var(--text-color);
        }

        .nav-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 5px rgba(106, 130, 251, 0.3);
        }

        .view-section {
            display: none;
        }

        .view-section.active {
            display: block;
        }

        /* Cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .card {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .card-header h3 {
            color: var(--text-light);
            font-size: 1em;
            text-transform: uppercase;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card .value {
            color: var(--text-color);
            font-size: 2.2em;
            font-weight: 700;
            margin-top: 8px;
            margin-bottom: 5px;
        }

        /* LAYOUT PARA MÉTRICAS SECUNDÁRIAS NOS CARDS */
        .card .secondary-metrics {
            display: flex;
            justify-content: space-between;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }

        .card .metric-item {
            display: flex;
            flex-direction: column;
        }

        .card .metric-label {
            font-size: 0.8em;
            color: var(--text-light);
            text-transform: uppercase;
        }

        .card .metric-value {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-color);
        }

        /* Cards Regionais & Por Empresa */
        .regional-cards-wrapper {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
            margin-bottom: 20px;
        }

        .regional-section {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .regional-section h3 {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Tabela de Comparação Diária */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table th:first-child,
        .comparison-table td:first-child {
            text-align: left;
            font-weight: 600;
        }

        .comparison-table thead th {
            color: var(--text-light);
            font-size: 0.9em;
            text-transform: uppercase;
        }

        .comparison-table .delta-positive,
        .performance-table .delta-positive {
            color: var(--color-positive);
            font-weight: 600;
        }

        .comparison-table .delta-negative,
        .performance-table .delta-negative {
            color: var(--color-negative);
            font-weight: 600;
        }

        .comparison-table .delta-neutral {
            color: var(--text-light);
        }

        .comparison-container {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .comparison-container h3 {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Gráficos */
        .chart-container {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            position: relative;
            height: 450px;
        }

        .chart-container.chart-full {
            height: 600px;
        }

        .chart-container h2 {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-color);
            margin-bottom: 20px;
            font-size: 1.3em;
            font-weight: 600;
        }

        #view-managers .charts-grid,
        #view-adops .charts-grid {
            grid-template-columns: 1fr;
        }

        /* Garante altura fixa para o gráfico principal de evolução */
        #view-managers .chart-container.chart-full {
            height: 500px;
        }

        /* Permite altura automática para os outros gráficos menores na mesma aba */
        #view-managers .charts-grid:not(:first-of-type) .chart-container,

        #view-segments .charts-grid {
            grid-template-columns: repeat(auto-fit, minmax(700px, 1fr));
        }

        /* Seletor de Métrica */
        .metric-selector-container {
            margin: 0;
            margin-left: auto;
        }

        .metric-toggle {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
        }

        .toggle-btn {
            padding: 8px 20px;
            border: none;
            background-color: var(--bg-light);
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-light);
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-btn:first-of-type {
            border-right: 1px solid var(--border-color);
        }

        .toggle-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .toggle-btn:not(.active):hover {
            background-color: #f1f3f5;
        }

        /* Filtros do gráfico de evolução */
        .chart-filters-container {
            display: flex;
            gap: 25px;
            align-items: flex-start;
            background-color: var(--bg-light);
            padding: 20px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .checkbox-wrapper {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .checkbox-wrapper input[type="checkbox"],
        .checkbox-wrapper input[type="radio"] {
            display: none;
        }

        .checkbox-wrapper label {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #f8f9fa;
            color: var(--text-light);
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            margin: 0;
        }

        .checkbox-wrapper input[type="checkbox"]:checked+label,
        .checkbox-wrapper input[type="radio"]:checked+label {
            background-color: var(--primary-color);
            color: white;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .checkbox-wrapper label:not(:last-of-type) {
            border-right: 1px solid var(--border-color);
        }

        /* --- NOVOS ESTILOS PARA BUSCA E COMPARAÇÃO --- */
        .comparison-controls-wrapper {
            display: flex;
            gap: 20px;
            width: 100%;
        }

        .search-container {
            flex-grow: 1;
            position: relative;
        }

        .search-results {
            position: absolute;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow);
            width: 100%;
            max-height: 250px;
            overflow-y: auto;
            z-index: 10;
            margin-top: 5px;
        }

        .search-result-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
        }

        .search-result-item:hover {
            background-color: #f1f3f5;
        }

        .selected-accounts-container {
            flex-basis: 40%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .selected-accounts-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        .account-pill {
            display: inline-flex;
            align-items: center;
            background-color: var(--primary-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 13px;
            font-weight: 500;
        }

        .account-pill .remove-pill {
            margin-left: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }

        .currency-warning-box {
            display: none;
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 5px;
            margin-bottom: 15px;
            color: #856404;
            font-size: 0.9em;
        }

        /* --- FIM DOS NOVOS ESTILOS --- */


        /* Tabelas de Performance (Segmentos & Metas) */
        .performance-table {
            width: 100%;
            border-collapse: collapse;
        }

        .performance-table th,
        .performance-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .performance-table th {
            font-weight: 600;
            background-color: #f9f9f9;
        }

        .performance-table tfoot td {
            font-weight: bold;
            background-color: #f1f3f5;
            border-top: 2px solid #dee2e6;
        }

        .performance-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .performance-table th.sortable:hover {
            background-color: #f0f0f0;
        }

        .performance-table th .sort-indicator {
            display: inline-block;
            margin-left: 5px;
            color: var(--text-light);
            font-size: 0.8em;
        }

        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-bar {
            flex-grow: 1;
            background-color: var(--border-color);
            border-radius: 5px;
            height: 18px;
            overflow: hidden;
        }

        .progress-bar-inner {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
            transition: width 0.3s ease-in-out;
            text-align: right;
            padding-right: 5px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            line-height: 18px;
        }

        .progress-bar-inner.positive {
            background-color: var(--color-positive);
        }

        .progress-bar-inner.negative {
            background-color: var(--color-negative);
        }

        .progress-percent {
            font-weight: 600;
            font-size: 0.9em;
            min-width: 45px;
        }

        /* ESTILOS PARA TABELA DE ACELERAÇÃO */
        .acceleration-table th,
        .acceleration-table td {
            text-align: right;
            white-space: nowrap;
        }

        .acceleration-table th:first-child,
        .acceleration-table td:first-child {
            text-align: left;
            position: sticky;
            left: 0;
            background-color: #fff;
            z-index: 1;
        }

        .acceleration-table thead th {
            text-align: center;
            vertical-align: middle;
            z-index: 2;
        }

        .acceleration-table thead tr:first-child th {
            background-color: #f1f3f5;
            border-bottom: 2px solid #dee2e6;
        }

        .acceleration-table .scenario-group-start {
            border-left: 2px solid #dee2e6;
        }

        .acceleration-table .acrescimo-cell span {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            background-color: #fbeae8;
        }

        /* ESTILOS PARA TABELA SPRINT 1M */
        .sprint-table th,
        .sprint-table td {
            text-align: right;
            vertical-align: middle;
        }

        .sprint-table th:first-child,
        .sprint-table td:first-child {
            text-align: left;
        }

        .sprint-table .daily-cell {
            padding: 4px 8px;
            border-radius: 6px;
            text-align: center;
            min-width: 130px;
        }

        .sprint-table .daily-cell div:first-child {
            font-size: 0.8em;
            color: var(--text-light);
            line-height: 1.2;
        }

        .sprint-table .daily-cell div:last-child {
            font-weight: bold;
            line-height: 1.2;
        }

        .sprint-table .daily-cell.delta-positive {
            background-color: #e6f8f3;
        }

        .sprint-table .daily-cell.delta-negative {
            background-color: #fbeae8;
        }

        .sprint-table th {
            white-space: nowrap;
        }

        /* --- ESTILOS PARA VISÃO OPERACIONAL --- */
        #operational-view-container {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: auto;
            /* Habilita ambos os scrolls */
            max-height: 75vh;
            /* Define uma altura máxima para o scroll vertical funcionar */
        }

        #operational-view-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        #operational-view-container::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        #operational-view-container::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 5px;
        }

        #operational-view-container::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        .operational-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }

        .operational-table th,
        .operational-table td {
            padding: 10px;
            text-align: right;
            border: 1px solid var(--border-color);
            white-space: nowrap;
            vertical-align: middle;
        }

        /* Congela o cabeçalho no topo */
        .operational-table thead th {
            background-color: #f1f3f5;
            font-weight: 700;
            position: sticky;
            top: 0;
            z-index: 3;
        }

        /* Garante que o fundo das células fixas não seja transparente */
        .operational-table .op-name-cell,
        .operational-table .platform-cell-container,
        .operational-table .metric-name-cell,
        .operational-table .goal-cell {
            background-color: #fff;
        }

        /* Congela as colunas à esquerda */
        .operational-table .op-name-cell,
        .operational-table .platform-cell-container,
        .operational-table .metric-name-cell,
        .operational-table .goal-cell {
            position: sticky;
            z-index: 1;
        }

        /* Define a posição e largura de cada coluna congelada */
        .operational-table .op-name-cell {
            left: 0;
            width: 160px;
            min-width: 160px;
        }

        .operational-table .platform-cell-container {
            left: 160px;
            width: 130px;
            min-width: 130px;
            text-align: center;
        }

        .operational-table .metric-name-cell {
            left: 290px;
            /* 160 + 130 */
            width: 120px;
            min-width: 120px;
        }

        .operational-table .goal-cell {
            left: 410px;
            /* 290 + 120 */
            width: 150px;
            min-width: 150px;
        }

        /* Define o Z-index para os cantos superiores esquerdos ficarem por cima */
        .operational-table thead th:nth-child(1) {
            left: 0;
            z-index: 4;
        }

        .operational-table thead th:nth-child(2) {
            left: 160px;
            z-index: 4;
        }

        .operational-table thead th:nth-child(3) {
            left: 290px;
            z-index: 4;
        }

        .operational-table thead th:nth-child(4) {
            left: 410px;
            z-index: 4;
        }

        .operational-table .platform-cell {
            background-color: #e9ecef !important;
            font-weight: normal;
            color: var(--text-light);
            text-align: center;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
        }

        .operational-table .metric-group-start td {
            border-top: 2px solid #343a40;
        }

        .operational-table .goal-value.positive {
            color: var(--color-positive);
        }

        .operational-table .goal-value.negative {
            color: var(--color-negative);
        }

        /* --- NOVOS ESTILOS PARA O FUNIL DE CONVERSÃO (COM SVG) --- */
        .funnel-wrapper {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 30px 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .funnel-wrapper h3 {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-color);
            text-align: center;
        }

        .funnel-svg {
            width: 100%;
            max-width: 600px;
            /* Limita a largura máxima do funil */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        .funnel-section-group {
            cursor: pointer;
        }

        .funnel-section-group .funnel-polygon {
            transition: filter 0.2s ease-in-out;
        }

        .funnel-section-group:hover .funnel-polygon {
            filter: brightness(1.15);
        }

        .funnel-label {
            fill: white;
            font-size: 14px;
            font-weight: 500;
            text-anchor: middle;
            text-transform: uppercase;
            opacity: 0.8;
        }
        /* --- ESTILOS PARA COMPARAÇÃO DE FUNIS --- */
        .comparison-filters {
            margin-bottom: 25px;
            justify-content: flex-start; /* Alinha filtros à esquerda */
        }

        #comparison-table-container .performance-table th,
        #comparison-table-container .performance-table td {
            text-align: right; /* Alinha números à direita */
            vertical-align: middle;
            white-space: nowrap;
        }
         #comparison-table-container .performance-table th:first-child,
         #comparison-table-container .performance-table td:first-child {
            text-align: left; /* Alinha nome da operação à esquerda */
            font-weight: 600;
             position: sticky; /* Congela a primeira coluna */
             left: 0;
             background-color: var(--bg-light); /* Fundo para cobrir rolagem */
             z-index: 1;
        }
         #comparison-table-container .performance-table thead th:first-child {
             z-index: 2; /* Garante que o header fique sobre as células */
         }


        .data-bar-container {
            display: flex;
            align-items: center;
            justify-content: flex-end; /* Alinha barra e texto à direita */
            min-width: 120px; /* Largura mínima para visualização */
            position: relative; /* Para a barra de fundo */
            padding: 2px 5px; /* Pequeno padding interno */
            margin: -2px -5px; /* Compensa o padding para alinhar com outras células */
        }

        .data-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background-color: #cfe2ff; /* Azul claro (Bootstrap info-light) */
            border-radius: 3px;
            opacity: 0.6;
             z-index: -1; /* Fica atrás do texto */
             transition: width 0.3s ease-out;
        }

        .data-bar-container span {
             position: relative; /* Garante que o texto fique sobre a barra */
             font-weight: 500;
        }

        /* Cores condicionais (Exemplo) */
        .positive-metric .data-bar {
             background-color: #d1e7dd; /* Verde claro (Bootstrap success-light) */
        }
         .negative-metric .data-bar {
             background-color: #f8d7da; /* Vermelho claro (Bootstrap danger-light) */
        }
         /* Para CPA baixo ser bom (barra menor é melhor visualmente) */
         .lower-is-better.positive-metric .data-bar { background-color: #f8d7da; }
         .lower-is-better.negative-metric .data-bar { background-color: #d1e7dd; }


        #comparison-table-container {
             overflow-x: auto; /* Permite rolagem horizontal se necessário */
        }
        /* --- FIM DOS ESTILOS PARA COMPARAÇÃO --- */

        .funnel-value {
            fill: white;
            font-size: 32px;
            font-weight: 700;
            text-anchor: middle;
        }

        .funnel-loss-arrow {
            stroke: #adb5bd;
            stroke-width: 2;
            fill: none;
        }

        .funnel-loss-text {
            fill: var(--text-light);
            font-size: 15px;
            font-weight: 600;
        }

        *==========================================================*/
        /* --- ESTILOS PARA O NOVO LAYOUT COM SIDEBAR --- */
        /* ========================================================== */

        body {
            padding: 0;
            overflow-x: hidden;
        }

        .dashboard-layout {
            display: flex;
            min-height: 100vh;
        }

        .sidebar-nav {
            width: 280px;
            /* Largura da barra expandida */
            background-color: var(--bg-light);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 15px;
            transition: width 0.3s ease-in-out;
            position: sticky;
            top: 0;
            height: 100vh;
        }

        .sidebar-header h1 {
            font-size: 1.6em;
            padding: 10px;
            white-space: nowrap;
            overflow: hidden;
        }

        .sidebar-menu {
            flex-grow: 1;
            margin-top: 15px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .main-nav {
            display: none;
        }

        /* Esconde a navbar antiga */

        .sidebar-nav .nav-btn {
            flex-grow: 0;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 15px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            padding: 14px 18px;
            font-size: 0.95em;
        }

        .nav-icon {
            font-size: 1.2em;
        }

        /* --- Estilos dos Submenus --- */
        .menu-group {
            margin: 20px 0;
        }

        .menu-group-title {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-light);
            text-transform: uppercase;
            padding: 0 18px 8px 18px;
            white-space: nowrap;
            overflow: hidden;
        }

        .sidebar-footer {
            margin-top: auto;
        }

        #sidebar-toggle {
            width: 100%;
            background: #f1f3f5;
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 15px;
            white-space: nowrap;
            overflow: hidden;
        }

        #sidebar-toggle:hover {
            background-color: #e9ecef;
            color: var(--text-color);
            transform: none;
            box-shadow: none;
        }

        .toggle-icon {
            transition: transform 0.3s ease-in-out;
        }

        .main-content {
            flex-grow: 1;
            padding: 25px;
            width: calc(100% - 280px);
            /* Ajuste de largura */
            transition: width 0.3s ease-in-out;
            overflow-y: auto;
        }

        .header h1 {
            white-space: nowrap;
        }

        /* --- Estilos para o Sidebar Minimizado --- */
        .sidebar-minimized .sidebar-nav {
            width: 88px;
            /* Largura da barra minimizada */
        }

        .sidebar-minimized .main-content {
            width: calc(100% - 88px);
        }

        .sidebar-minimized .sidebar-header h1,
        .sidebar-minimized .nav-btn span:last-child,
        .sidebar-minimized #sidebar-toggle span:last-child,
        .sidebar-minimized .menu-group-title {
            opacity: 0;
            width: 0;
            display: none;
        }

        .sidebar-minimized .nav-btn,
        .sidebar-minimized #sidebar-toggle {
            justify-content: center;
            padding: 14px 10px;
        }

        .sidebar-minimized .toggle-icon {
            transform: rotate(180deg);
        }

        .sidebar-minimized [data-tooltip] {
            position: relative;
        }

        .sidebar-minimized [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 15px;
            background-color: #343a40;
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* --- ESTILOS PARA CAIXA DE EXPLICAÇÃO --- */
        .explanation-box {
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px 25px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .explanation-box h4 {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .explanation-box p {
            margin-bottom: 10px;
            color: var(--text-light);
        }

        .explanation-box strong {
            color: var(--text-color);
        }

        .explanation-box i {
            font-style: italic;
        }

        /* --- ESTILOS PARA O SELETOR DE GESTOR CUSTOMIZADO --- */
        .custom-select-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .custom-select-wrapper label {
            font-size: 0.85em;
            font-weight: 600;
            color: var(--text-light);
        }

        .custom-select {
            position: relative;
            width: 350px;
        }

        .custom-select-trigger {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            background-color: #fff;
            text-align: left;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .custom-select-trigger::after {
            content: '▼';
            font-size: 0.8em;
            color: var(--text-light);
        }

        .custom-select-options {
            position: absolute;
            top: 105%;
            left: 0;
            right: 0;
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            z-index: 100;
            display: none;
            /* Controlado por JS */
            overflow: hidden;
        }

        .custom-select-options.open {
            display: block;
        }

        .custom-select-search {
            width: 100%;
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            outline: none;
            font-size: 14px;
        }

        .custom-options-list {
            max-height: 250px;
            overflow-y: auto;
        }

        .custom-options-list label {
            display: block;
            padding: 12px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
        }

        .custom-options-list label:hover {
            background-color: #f1f3f5;
        }

        .custom-options-list input[type="checkbox"] {
            margin-right: 10px;
        }

        /* --- ESTILOS PARA A LISTA DE OPERAÇÕES POR COORDENADOR --- */
        .ops-list-container {
            padding: 15px;
        }

        .ops-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .ops-list-item {
            background-color: #e9ecef;
            color: var(--text-color);
            padding: 8px 15px;
            border-radius: 50px;
            /* Bordas arredondadas para o estilo "pill" */
            font-size: 0.9em;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .ops-list-item:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        /* Adicione no final do seu CSS */
        #coordination-ops-list-container .performance-table td {
            text-align: left;
        }

        /* Adicione no final da sua seção <style> */

        #coordination-ops-list-container .regional-section h3 {
            margin-bottom: 15px;
            /* Adiciona um pequeno espaço abaixo do título */
        }

        #coordination-ops-list-container .performance-table {
            font-size: 0.9em;
            /* Ajusta o tamanho da fonte para a lista */
        }

        #coordination-ops-list-container .performance-table td {
            text-align: left;
            /* Alinha o nome das operações à esquerda */
            padding: 10px 15px;
            /* Ajusta o espaçamento interno */
            border-bottom: 1px solid var(--border-color);
        }

        #coordination-ops-list-container .performance-table tr:last-child td {
            border-bottom: none;
            /* Remove a borda da última linha */
        }

        /* Adicione no final da sua seção <style> */

        /* Corrige o layout dos gráficos de altura total (Gestor e AdOps) */
        .chart-container.chart-full {
            display: flex;
            flex-direction: column;
        }

        /* Faz o canvas ocupar todo o espaço vertical restante no contêiner */
        .chart-container.chart-full canvas {
            flex-grow: 1;
            /* Precisamos redefinir a altura para que o flex-grow funcione corretamente */
            height: 0;
        }

        /* --- ESTILOS PARA INFO TOOLTIP DO PLANEJADOR --- */
        .info-tooltip {
            display: inline-block;
            position: relative;
            cursor: help;
            font-weight: bold;
            color: var(--primary-color);
            background-color: #eef;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            margin-left: 5px;
        }

        .info-tooltip:hover::after {
            content: attr(data-tooltip-text);
            position: absolute;
            bottom: 125%;
            /* Posição acima do '?' */
            left: 50%;
            transform: translateX(-50%);
            background-color: #343a40;
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: 500;
            width: 300px;
            /* Largura do tooltip */
            text-align: left;
            white-space: normal;
            z-index: 1000;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>

<body>
    <div class="loader-overlay" id="loader">
        <div class="loader"></div>
    </div>

    <div class="dashboard-layout">
        <nav class="sidebar-nav">
            <div class="sidebar-header">
                <h1>📊 Dashboard</h1>
            </div>
            <div class="sidebar-menu">
                <button class="nav-btn active" data-target="view-general" data-tooltip="Visão Geral">
                    <span class="nav-icon">👁️</span> <span>Visão Geral</span>
                </button>
      
                <div class="menu-group">
                    <div class="menu-group-title">Operações</div>
                    <button class="nav-btn" data-target="operacoes-sub-funis" data-parent-view="view-operacoes" data-tooltip="Funis Agregados (Operações)">
                         <span class="nav-icon">📊</span> <span>Funis Agregados</span>
                    </button>
                    <button class="nav-btn" data-target="operacoes-sub-consolidado" data-parent-view="view-operacoes" data-tooltip="Visão Consolidada (Operações)">
                         <span class="nav-icon">📋</span> <span>Visão Consolidada</span>
                    </button>
                    <button class="nav-btn" data-target="operacoes-sub-comparacao" data-parent-view="view-operacoes" data-tooltip="Comparar Funis por Região">
                         <span class="nav-icon">⚖️</span> <span>Comparar Funis</span>
                    </button>
                    </div>
                <button class="nav-btn" data-target="view-proportion" data-tooltip="Análise de Proporção">
                    <span class="nav-icon">📊</span> <span>Análise de Proporção</span>
                </button>
                <button class="nav-btn" data-target="view-segments" data-tooltip="Segmentos de Negócio">
                    <span class="nav-icon">🧩</span> <span>Segmentos de Negócio</span>
                </button>
                <button class="nav-btn" data-target="view-companies" data-tooltip="Performance por Empresa">
                    <span class="nav-icon">🏢</span> <span>Performance por Empresa</span>
                </button>
      
                <div class="menu-group">
                     <div class="menu-group-title">Metas</div>
                     <button class="nav-btn" data-target="view-metas-geral" data-tooltip="Metas Gerais">
                         <span class="nav-icon">🎯</span> <span>Metas Gerais</span>
                     </button>
                     <button class="nav-btn" data-target="view-metas-planner" data-tooltip="Planejador de Metas">
                         <span class="nav-icon">🏃</span> <span>Planejador de Metas</span>
                     </button>
                </div>
      
                <div class="menu-group">
                    <div class="menu-group-title">Performance</div>
                    <button class="nav-btn" data-target="view-managers" data-tooltip="Performance por Gestor">
                        <span class="nav-icon">👨‍💼</span> <span>Por Gestor de Tráfego</span>
                    </button>
                    <button class="nav-btn" data-target="view-coordination" data-tooltip="Performance por Coordenação">
                        <span class="nav-icon">👑</span> <span>Por Coordenação (Aquisição)</span>
                    </button>
                    <button class="nav-btn" data-target="view-adops" data-tooltip="Performance por AdOps">
                        <span class="nav-icon">👩‍💻</span> <span>Por AdOps</span>
                    </button>
                </div>
      
                <div class="menu-group">
                    <div class="menu-group-title">Análise Avançada</div>
                    <button class="nav-btn" data-target="view-correlation" data-tooltip="Análise de Correlação">
                        <span class="nav-icon">🔗</span> <span>Correlação</span>
                    </button>
                    <button class="nav-btn" data-target="view-forecast" data-tooltip="Previsão Avançada">
                        <span class="nav-icon">🔮</span> <span>Previsão Avançada</span>
                    </button>
                </div>
      
                <div class="menu-group">
                    <div class="menu-group-title">Análise de Contas</div>
                    <button class="nav-btn" data-target="view-jn-analysis" data-tooltip="Análise de Contas JN">
                        <span class="nav-icon">📈</span> <span>Contas JN</span>
                    </button>
                    <button class="nav-btn" data-target="view-mg-analysis" data-tooltip="Análise de Contas MG">
                        <span class="nav-icon">📉</span> <span>Contas MG</span>
                    </button>
                    <button class="nav-btn" data-target="view-grid-analysis" data-tooltip="Análise de Contas GRID">
                        <span class="nav-icon">📊</span> <span>Contas GRID</span>
                    </button>
                </div>
            </div>
            <div class="sidebar-footer">
                <button id="sidebar-toggle" data-tooltip="Minimizar Menu">
                    <span class="nav-icon toggle-icon">«</span> <span>Minimizar</span>
                </button>
            </div>
        </nav>

        <main class="main-content">
            <div class="container">
                <div class="header">
                    <h1 id="main-title">Visão Geral</h1>
                    <div class="controls">
                        <div id="status" class="status">Pronto para carregar.</div>
                        <button id="updateBtn" onclick="loadAllData(true)">🔄 Atualizar Dados</button>
                    </div>
                </div>

                <div class="filters">
                    <div class="filter-group"><label for="dateFilterStart">Data de Início:</label><input type="date"
                            id="dateFilterStart" onchange="filterAndRenderAll()"></div>
                    <div class="filter-group"><label for="dateFilterEnd">Data Final:</label><input type="date"
                            id="dateFilterEnd" onchange="filterAndRenderAll()"></div>
                    <button onclick="clearFilters()" style="background: #6c757d; margin-left: auto;">Limpar
                        Filtros</button>
                </div>

                <div class="content-wrapper" id="mainContent">

                    <div id="view-general" class="view-section active">
                        <div class="section-header">
                            <h2 class="section-title" id="general-results-title">Resultados Gerais do Período</h2>
                        </div>
                        <div class="summary-cards" id="summaryCards"></div>
                        <div class="section-header">
                            <h2 class="section-title" id="regional-results-title">Resultados do Período por Região</h2>
                        </div>
                        <div class="regional-cards-wrapper">
                            <div class="regional-section" id="regional-br">
                                <h3>🇧🇷 Brasil</h3>
                                <div class="summary-cards" id="summaryCardsBr"></div>
                            </div>
                            <div class="regional-section" id="regional-us">
                                <h3>🇺🇸 Estados Unidos</h3>
                                <div class="summary-cards" id="summaryCardsUs"></div>
                            </div>
                            <div class="regional-section" id="regional-eu">
                                <h3>🇪🇺 Europa</h3>
                                <div class="summary-cards" id="summaryCardsEu"></div>
                            </div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Evolução Diária</h2>
                        </div>
                        <div class="chart-filters-container">
                            <div class="filter-group"><label>Comparar Regiões:</label>
                                <div id="region-checkbox-group" class="checkbox-wrapper"><input type="checkbox"
                                        id="region-all" value="all" onchange="handleRegionSelection(this)"
                                        checked><label for="region-all">Todas</label><input type="checkbox"
                                        id="region-br" value="br" onchange="handleRegionSelection(this)"><label
                                        for="region-br">Brasil</label><input type="checkbox" id="region-us" value="us"
                                        onchange="handleRegionSelection(this)"><label for="region-us">USA</label><input
                                        type="checkbox" id="region-eu" value="eu"
                                        onchange="handleRegionSelection(this)"><label for="region-eu">Europa</label>
                                </div>
                            </div>
                            <div class="filter-group"><label for="evolutionOperationFilter">Filtrar por
                                    Operação:</label><select id="evolutionOperationFilter"
                                    onchange="updateEvolutionChartWithFilters()">
                                    <option value="all" selected>Todas as Operações</option>
                                </select></div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container chart-full"><canvas id="evolucaoCompletaChart"></canvas></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Análise Comparativa Diária</h2>
                        </div>
                        <div id="dailyComparisonContainer">
                            <div class="comparison-container" id="dailyComparisonTotal"></div>
                            <div class="comparison-container" id="dailyComparisonBr"></div>
                            <div class="comparison-container" id="dailyComparisonUs"></div>
                            <div class="comparison-container" id="dailyComparisonEu"></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Projeção para o Fim do Mês</h2>
                        </div>
                        <div class="summary-cards" id="projectionCards"></div>
                    </div>

                    <div id="view-operacoes" class="view-section">
            
                        <div id="operacoes-sub-funis" class="operacoes-sub-view active">
                            <div class="section-header">
                                <h2 class="section-title">Funis Agregados por Operação (JN/MG/GRID - Dados Reais)</h2>
                            </div>
                            <div id="aggregated-funnel-container" class="charts-grid" style="grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 20px;">
                                <p style="grid-column: 1 / -1; text-align: center; padding: 20px;">Calculando funis...</p>
                                </div>
            
                            <div class="section-header" style="margin-top: 30px;">
                                <h2 class="section-title">Tabela Comparativa de Funis Agregados</h2>
                            </div>
                            <div id="aggregated-funnel-table-container" class="chart-container chart-full" style="height: auto; padding: 0; overflow-x: auto;">
                                 <p style="text-align: center; padding: 20px;">Calculando tabela...</p>
                                 </div>
                            </div>
            
                        <div id="operacoes-sub-consolidado" class="operacoes-sub-view">
                             <div class="section-header" style="margin-top: 20px;"> <h2 class="section-title">Visão Operacional Consolidada (Dados 'TOTAL')</h2>
                            </div>
                            <div id="operational-view-container">
                                <p style="padding: 20px; text-align: center;">Carregando dados operacionais...</p>
                                 </div>
                        </div>
                        <div id="operacoes-sub-comparacao" class="operacoes-sub-view">
                            <div class="section-header">
                               <h2 class="section-title">Comparação de Funis por País</h2>
                           </div>
           
                           <div class="filters comparison-filters">
                               <div class="filter-group">
                                    <label for="compare-country-select">Selecione o País:</label>
                                   <select id="compare-country-select" onchange="renderComparisonView()">
                                        <option value="">-- País --</option>
                                       </select>
                               </div>
                               <div class="filter-group">
                                   <label for="compare-niche-select">Filtrar por Nicho (Opcional):</label>
                                   <select id="compare-niche-select" onchange="renderComparisonView()">
                                       <option value="all">Todos os Nichos</option>
                                       <option value="CC">Apenas CC</option>
                                       <option value="EMP">Apenas EMP</option>
                                   </select>
                               </div>
                           </div>
           
                           <div id="comparison-table-container" style="margin-top: 25px;">
                                <p style="text-align: center; padding: 20px; color: var(--text-light);">Selecione um país para iniciar a comparação.</p>
                                </div>
           
                       </div>
            
                    </div>

                    <div id="view-proportion" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Proporção de Investimento / Leads</h2>
                            <div class="metric-selector-container">
                                <div id="metric-toggle" class="metric-toggle"><button class="toggle-btn active"
                                        data-metric="gasto">📊 Investimento</button><button class="toggle-btn"
                                        data-metric="leads">👥 Leads</button></div>
                            </div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container">
                                <h2>🌍 Por Região</h2><canvas id="regionInvestmentPieChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>💻 Por Plataforma</h2><canvas id="platformInvestmentPieChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>📊 Por Nicho (BR)</h2><canvas id="nicheBrChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>📊 Por Nicho (US)</h2><canvas id="nicheUsChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div id="view-segments" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise Comparativa por Segmento de Negócio</h2>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container">
                                <h2>🇺🇸 Cartão de Crédito (US)</h2>
                                <div id="segmentUsCcTable"></div>
                            </div>
                            <div class="chart-container">
                                <h2>🇺🇸 Empréstimo (US)</h2>
                                <div id="segmentUsEmpTable"></div>
                            </div>
                            <div class="chart-container">
                                <h2>🇧🇷 Cartão de Crédito (BR)</h2>
                                <div id="segmentBrCcTable"></div>
                            </div>
                            <div class="chart-container">
                                <h2>🇧🇷 Empréstimo (BR)</h2>
                                <div id="segmentBrEmpTable"></div>
                            </div>
                            <div class="chart-container">
                                <h2>🇩🇪 Cartão de Crédito (DE)</h2>
                                <div id="segmentDeCcTable"></div>
                            </div>
                            <div class="chart-container">
                                <h2>🇫🇷 Cartão de Crédito (FR)</h2>
                                <div id="segmentFrCcTable"></div>
                            </div>
                        </div>
                    </div>

                    <div id="view-companies" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Resultados Consolidados por Empresa</h2>
                        </div>
                        <div class="regional-cards-wrapper" id="company-cards-wrapper"></div>
                        <div class="section-header">
                            <h2 class="section-title">Distribuição do Gasto Total por Empresa</h2>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container"><canvas id="companyTotalGastoPieChart"></canvas></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Evolução do Investimento por Empresa</h2>
                        </div>
                        <div class="chart-filters-container">
                            <div class="filter-group"><label>Selecionar Empresas:</label>
                                <div id="company-checkbox-group" class="checkbox-wrapper"></div>
                            </div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container chart-full"><canvas id="companyEvolutionChart"></canvas></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Distribuição Regional do Investimento por Empresa</h2>
                        </div>
                        <div class="charts-grid" id="companyDistributionCharts"></div>
                    </div>

                    <div id="view-metas-geral" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Visão Geral das Metas Diárias</h2>
                        </div>
                        <div class="summary-cards" style="grid-template-columns: 1fr 1fr; align-items: stretch;">
                            <div id="metas-kpi-cards"></div>
                            <div id="sprint-kpi-cards"></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">🚀 Sprint 1M - Plano de Aceleração Diária (até 18/10)</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 25px;">
                            <div id="sprint-1m-table" style="overflow-x: auto;"></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">🎯 Sprint Fim de Semana (até 18/10)</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 25px;">
                            <div id="sprint-1810-table-container" style="overflow-x: auto;">
                            </div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Performance Detalhada vs. Metas Diárias</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 0;">
                            <div id="metas-detailed-table"></div>
                        </div>
                        <div class="section-header">
                            <h2 class="section-title">Simulador de Aceleração para Metas Gerais</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 25px;">
                            <div id="metas-acceleration-table" style="overflow-x: auto;"></div>
                        </div>
                    </div>
                    <div id="view-metas-planner" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Planejador de Metas (Simulador de Pacing)</h2>
                        </div>

                        <div class="chart-filters-container"
                            style="display: flex; justify-content: space-around; align-items: flex-end;">
                                                        <div class="filter-group" style="flex-grow: 1;">
                                                                                                <label
                                    for="plannerOperationFilter" style="display: flex; align-items: center;">
                                                                        1. Selecione a Operação (Total)
                                                                        <span class="info-tooltip"
                                        data-tooltip-text="A projeção irá distribuir o gasto total pelas sub-operações (ex: 01, 02) com base na média de performance dos últimos 7 dias.">(?)</span>
                                                                    </label>
                                                                <select id="plannerOperationFilter"
                                    style="width: 100%;">
                                                                        <option value="">-- Carregando operações --
                                    </option>
                                                                    </select>
                                                                                            </div>
                                                        <div class="filter-group">
                                                                <label for="plannerTargetSpend">2. Meta de Gasto
                                    Total</label>
                                                                <input type="number" id="plannerTargetSpend"
                                    placeholder="500000" style="width: 200px;">
                                                            </div>
                                                        <div class="filter-group">
                                                                <label for="plannerEndDate">3. Data Final</label>
                                                                <input type="date" id="plannerEndDate"
                                    style="width: 200px;">
                                                            </div>
                                                        <button id="plannerCalculateBtn"
                                style="padding: 10px 15px; height: 44px; margin-left: 15px;">📊 Calcular Plano</button>
                                                    </div>

                        <div class="summary-cards" id="plannerSummaryCards" style="margin-top: 25px; display: none;">
                        </div>

                        <div class="charts-grid" style="margin-top: 25px; display: none;" id="plannerChartContainer">
                            <div class="chart-container chart-full">
                                <h2>Evolução Planejada vs. Real</h2>
                                <canvas id="plannerChart"></canvas>
                            </div>
                        </div>

                        <div style="display: none;" id="plannerTableContainer">
                            <div class="section-header" style="margin-top: 20px;">
                                <h2 class="section-title">Plano de Gasto Diário</h2>
                            </div>
                            <div class="chart-container chart-full" style="height: auto; padding: 0;">
                                <div id="plannerTable" style="overflow-x: auto;"></div>
                            </div>
                        </div>
                    </div>

                    <div id="view-managers" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise de Performance por Gestor (Aquisição)</h2>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container chart-full">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                                    <h2 style="margin-bottom: 0;">📊 Evolução Diária por Gestor</h2>
                                    <div class="custom-select-wrapper">
                                        <label>Selecione o(s) Gestor(es):</label>
                                        <div class="custom-select" id="manager-select-container">
                                            <button class="custom-select-trigger"
                                                id="manager-select-trigger">Selecione...</button>
                                            <div class="custom-select-options" id="manager-select-options">
                                                <input type="text" id="manager-search-input"
                                                    placeholder="Buscar gestor..." class="custom-select-search">
                                                <div id="manager-options-list" class="custom-options-list"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <canvas id="gestorEvolucaoDiariaChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>📈 Operações por Gestor</h2><canvas id="managerOpsCountChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>💸 CPA Médio por Gestor</h2><canvas id="gestorCpaChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>💰 Maior Investimento</h2><canvas id="gestorInvestimentoTotalChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>🎯 Melhor ROAS</h2><canvas id="gestorRoasChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div id="view-coordination" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise de Performance por Coordenação (Aquisição)</h2>
                            <div class="custom-select-wrapper">
                                <label>Filtrar por Coordenação:</label>
                                <div class="custom-select" id="coord-select-container">
                                    <button class="custom-select-trigger" id="coord-select-trigger">Todos</button>
                                    <div class="custom-select-options" id="coord-select-options">
                                        <input type="text" id="coord-search-input" placeholder="Buscar..."
                                            class="custom-select-search">
                                        <div id="coord-options-list" class="custom-options-list">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="coordination-summary-cards" class="regional-cards-wrapper">
                        </div>

                        <div class="section-header">
                            <h2 class="section-title">Análise Gráfica</h2>
                        </div>

                        <div class="charts-grid" style="grid-template-columns: 2fr 1fr; gap: 25px;">
                            <div class="chart-container" style="grid-column: 1 / 2;">
                                <h2>📈 Evolução Diária (Gasto, ROAS, CPA)</h2>
                                <canvas id="coordinationEvolutionChart"></canvas>
                            </div>

                            <div style="grid-column: 2 / 3; display: flex; flex-direction: column; gap: 25px;">
                                <div class="chart-container">
                                    <h2>📊 Proporção de Gasto</h2>
                                    <canvas id="coordinationSpendPieChart"></canvas>
                                </div>
                                <div class="chart-container" style="height: auto;">
                                    <h2>📋 Nº de Operações</h2>
                                    <canvas id="coordinationOpsCountChart"></canvas>
                                </div>
                            </div>
                        </div>

                        <div class="section-header">
                            <h2 class="section-title">Operações por Coordenador</h2>
                        </div>
                        <div id="coordination-ops-list-container" class="regional-cards-wrapper">
                        </div>
                    </div>

                    <div id="view-adops" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise de Performance por AdOps (Monetização)</h2>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-full" style="grid-column: 1 / -1;">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 15px;">
                                    <h2 style="margin-bottom: 0;">📈 Evolução Diária por AdOps</h2>
                                    <div class="custom-select-wrapper">
                                        <label>Selecione o(s) AdOps:</label>
                                        <div class="custom-select" id="adops-select-container">
                                            <button class="custom-select-trigger"
                                                id="adops-select-trigger">Selecione...</button>
                                            <div class="custom-select-options" id="adops-select-options">
                                                <input type="text" id="adops-search-input" placeholder="Buscar AdOps..."
                                                    class="custom-select-search">
                                                <div id="adops-options-list" class="custom-options-list"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="chart-container chart-full">
                                    <canvas id="adopsEvolutionChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container">
                                <h2>📈 Receita Total por AdOps</h2><canvas id="adopsRevenueChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>💰 Investimento Gerenciado</h2><canvas id="adopsInvestmentChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>🎯 ROAS Médio por AdOps</h2><canvas id="adopsRoasChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>👥 Leads Gerenciados</h2><canvas id="adopsLeadsChart"></canvas>
                            </div>
                            <div class="chart-container">
                                <h2>📋 Operações por AdOps</h2><canvas id="adopsOpsCountChart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div id="view-correlation" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">🔗 Análise de Correlação entre Métricas</h2>
                        </div>
                        <div class="chart-filters-container">
                            <div class="filter-group">
                                <label for="correlationAccountFilter">Selecione a Conta:</label>
                                <select id="correlationAccountFilter" onchange="renderCorrelationChart()"
                                    style="width: 350px;"></select>
                            </div>
                            <div class="filter-group">
                                <label for="correlationMetricX">Métrica do Eixo X:</label>
                                <select id="correlationMetricX" onchange="renderCorrelationChart()"></select>
                            </div>
                            <div class="filter-group">
                                <label for="correlationMetricY">Métrica do Eixo Y:</label>
                                <select id="correlationMetricY" onchange="renderCorrelationChart()"></select>
                            </div>
                        </div>
                        <div class="chart-container chart-full">
                            <h3 id="correlation-result-text" style="text-align:center; margin-bottom: 15px;">Selecione
                                uma conta e as métricas.</h3>
                            <canvas id="correlationChart"></canvas>
                        </div>
                        <div id="correlation-explanation-box" class="explanation-box"
                            style="display: none; margin-top: 25px;"></div>
                    </div>

                    <div id="view-forecast" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">🔮 Previsão Avançada de Performance</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: 600px;">
                            <canvas id="advancedForecastChart"></canvas>
                        </div>
                        <div id="forecast-text-analysis" class="explanation-box"
                            style="display: none; margin-top: 25px;"></div>
                    </div>

                    <div id="view-jn-analysis" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise de Performance por Conta (JN)</h2>
                        </div>
                        <div class="chart-filters-container">
                            <div class="filter-group"><label>Modo de Visualização:</label>
                                <div class="checkbox-wrapper"><input type="radio" id="jn-mode-single"
                                        name="jn-view-mode" value="single" onchange="toggleJnViewMode('single')"
                                        checked><label for="jn-mode-single">Visão Única</label><input type="radio"
                                        id="jn-mode-compare" name="jn-view-mode" value="compare"
                                        onchange="toggleJnViewMode('compare')"><label for="jn-mode-compare">Modo de
                                        Comparação</label></div>
                            </div>
                            <div class="filter-group"><label>Métricas do Gráfico:</label>
                                <div id="jn-metric-checkbox-group" class="checkbox-wrapper"><input type="checkbox"
                                        id="jn-metric-gasto" value="gasto" onchange="renderJnAnalysisView()"
                                        checked><label for="jn-metric-gasto">Gasto</label><input type="checkbox"
                                        id="jn-metric-cpa" value="cpa" onchange="renderJnAnalysisView()" checked><label
                                        for="jn-metric-cpa">CPA</label><input type="checkbox" id="jn-metric-cpm"
                                        value="cpm" onchange="renderJnAnalysisView()"><label
                                        for="jn-metric-cpm">CPM</label><input type="checkbox" id="jn-metric-ctr"
                                        value="ctr" onchange="renderJnAnalysisView()"><label
                                        for="jn-metric-ctr">CTR</label></div>
                            </div>
                        </div>
                        <div id="jn-single-view-controls" class="chart-filters-container">
                            <div class="filter-group"><label for="jnAccountFilter">Selecione uma Conta:</label><select
                                    id="jnAccountFilter" onchange="renderJnAnalysisView()" style="width: 450px;">
                                    <option value="">-- Carregando contas --</option>
                                </select></div>
                        </div>
                        <div id="jn-compare-view-controls" class="chart-filters-container" style="display: none;">
                            <div class="comparison-controls-wrapper">
                                <div class="search-container">
                                    <div class="filter-group"><label for="jnAccountSearch">Buscar conta por
                                            palavra-chave:</label><input type="search" id="jnAccountSearch"
                                            onkeyup="handleJnAccountSearch()" placeholder="Digite para buscar..."
                                            style="width: 100%;">
                                        <div id="jnSearchResults" class="search-results"></div>
                                    </div>
                                </div>
                                <div class="selected-accounts-container"><label>Contas em comparação:</label>
                                    <div id="jnSelectedAccounts" class="selected-accounts-list"></div><button
                                        onclick="clearJnComparison()"
                                        style="background: #6c757d; margin-top: auto; padding: 5px 10px; font-size: 0.8em;">Limpar
                                        Seleção</button>
                                </div>
                            </div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container chart-full">
                                <div id="jn-currency-warning" class="currency-warning-box"></div><canvas
                                    id="jnEvolutionChart"></canvas>
                            </div>
                        </div>
                        <div id="jn-funnel-container" style="display: none; margin-top: 25px;"></div>
                        <div class="section-header" style="margin-top: 20px;">
                            <h2 class="section-title">Dados Diários Agregados</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 0;">
                            <div id="jn-daily-table" style="overflow-x: auto;"></div>
                        </div>
                    </div>

                    <div id="view-mg-analysis" class="view-section">
                        <div class="section-header">
                            <h2 class="section-title">Análise de Performance por Conta (MG)</h2>
                        </div>
                        <div class="chart-filters-container">
                            <div class="filter-group"><label>Modo de Visualização:</label>
                                <div class="checkbox-wrapper"><input type="radio" id="mg-mode-single"
                                        name="mg-view-mode" value="single" onchange="toggleMgViewMode('single')"
                                        checked><label for="mg-mode-single">Visão Única</label><input type="radio"
                                        id="mg-mode-compare" name="mg-view-mode" value="compare"
                                        onchange="toggleMgViewMode('compare')"><label for="mg-mode-compare">Modo de
                                        Comparação</label></div>
                            </div>
                            <div class="filter-group"><label>Métricas do Gráfico:</label>
                                <div id="mg-metric-checkbox-group" class="checkbox-wrapper"><input type="checkbox"
                                        id="mg-metric-gasto" value="gasto" onchange="renderMgAnalysisView()"
                                        checked><label for="mg-metric-gasto">Gasto</label><input type="checkbox"
                                        id="mg-metric-cpa" value="cpa" onchange="renderMgAnalysisView()" checked><label
                                        for="mg-metric-cpa">CPA</label><input type="checkbox" id="mg-metric-cpm"
                                        value="cpm" onchange="renderMgAnalysisView()"><label
                                        for="mg-metric-cpm">CPM</label><input type="checkbox" id="mg-metric-ctr"
                                        value="ctr" onchange="renderMgAnalysisView()"><label
                                        for="mg-metric-ctr">CTR</label></div>
                            </div>
                        </div>
                        <div id="mg-single-view-controls" class="chart-filters-container">
                            <div class="filter-group"><label for="mgAccountFilter">Selecione uma Conta:</label><select
                                    id="mgAccountFilter" onchange="renderMgAnalysisView()" style="width: 450px;">
                                    <option value="">-- Carregando contas --</option>
                                </select></div>
                        </div>
                        <div id="mg-compare-view-controls" class="chart-filters-container" style="display: none;">
                            <div class="comparison-controls-wrapper">
                                <div class="search-container">
                                    <div class="filter-group"><label for="mgAccountSearch">Buscar conta por
                                            palavra-chave:</label><input type="search" id="mgAccountSearch"
                                            onkeyup="handleMgAccountSearch()" placeholder="Digite para buscar..."
                                            style="width: 100%;">
                                        <div id="mgSearchResults" class="search-results"></div>
                                    </div>
                                </div>
                                <div class="selected-accounts-container"><label>Contas em comparação:</label>
                                    <div id="mgSelectedAccounts" class="selected-accounts-list"></div><button
                                        onclick="clearMgComparison()"
                                        style="background: #6c757d; margin-top: auto; padding: 5px 10px; font-size: 0.8em;">Limpar
                                        Seleção</button>
                                </div>
                            </div>
                        </div>
                        <div class="charts-grid">
                            <div class="chart-container chart-full">
                                <div id="mg-currency-warning" class="currency-warning-box"></div><canvas
                                    id="mgEvolutionChart"></canvas>
                            </div>
                        </div>
                        <div id="mg-funnel-container" style="display: none; margin-top: 25px;"></div>
                        <div class="section-header" style="margin-top: 20px;">
                            <h2 class="section-title">Dados Diários Agregados</h2>
                        </div>
                        <div class="chart-container chart-full" style="height: auto; padding: 0;">
                            <div id="mg-daily-table" style="overflow-x: auto;"></div>
                        </div>
                    </div>

                </div>
            </div>
            <div id="view-grid-analysis" class="view-section">
                <div class="section-header">
                    <h2 class="section-title">Análise de Performance por Conta (GRID)</h2>
                </div>
                <div class="chart-filters-container">
                    <div class="filter-group"><label>Modo de Visualização:</label>
                        <div class="checkbox-wrapper"><input type="radio" id="grid-mode-single" name="grid-view-mode" value="single" onchange="toggleGridViewMode('single')" checked><label for="grid-mode-single">Visão Única</label><input type="radio" id="grid-mode-compare" name="grid-view-mode" value="compare" onchange="toggleGridViewMode('compare')"><label for="grid-mode-compare">Modo de Comparação</label></div>
                    </div>
                    <div class="filter-group"><label>Métricas do Gráfico:</label>
                        <div id="grid-metric-checkbox-group" class="checkbox-wrapper"><input type="checkbox" id="grid-metric-gasto" value="gasto" onchange="renderGridAnalysisView()" checked><label for="grid-metric-gasto">Gasto</label><input type="checkbox" id="grid-metric-cpa" value="cpa" onchange="renderGridAnalysisView()" checked><label for="grid-metric-cpa">CPA</label><input type="checkbox" id="grid-metric-cpm" value="cpm" onchange="renderGridAnalysisView()"><label for="grid-metric-cpm">CPM</label><input type="checkbox" id="grid-metric-ctr" value="ctr" onchange="renderGridAnalysisView()"><label for="grid-metric-ctr">CTR</label></div>
                    </div>
                </div>
                <div id="grid-single-view-controls" class="chart-filters-container">
                    <div class="filter-group"><label for="gridAccountFilter">Selecione uma Conta:</label><select id="gridAccountFilter" onchange="renderGridAnalysisView()" style="width: 450px;">
                            <option value="">-- Carregando contas --</option>
                        </select></div>
                </div>
                <div id="grid-compare-view-controls" class="chart-filters-container" style="display: none;">
                    <div class="comparison-controls-wrapper">
                        <div class="search-container">
                            <div class="filter-group"><label for="gridAccountSearch">Buscar conta por palavra-chave:</label><input type="search" id="gridAccountSearch" onkeyup="handleGridAccountSearch()" placeholder="Digite para buscar..." style="width: 100%;">
                                <div id="gridSearchResults" class="search-results"></div>
                            </div>
                        </div>
                        <div class="selected-accounts-container"><label>Contas em comparação:</label>
                            <div id="gridSelectedAccounts" class="selected-accounts-list"></div><button onclick="clearGridComparison()" style="background: #6c757d; margin-top: auto; padding: 5px 10px; font-size: 0.8em;">Limpar Seleção</button>
                        </div>
                    </div>
                </div>
                <div class="charts-grid">
                    <div class="chart-container chart-full">
                        <div id="grid-currency-warning" class="currency-warning-box"></div><canvas id="gridEvolutionChart"></canvas>
                    </div>
                </div>
                <div id="grid-funnel-container" style="display: none; margin-top: 25px;"></div>
                <div class="section-header" style="margin-top: 20px;">
                    <h2 class="section-title">Dados Diários Agregados</h2>
                </div>
                <div class="chart-container chart-full" style="height: auto; padding: 0;">
                    <div id="grid-daily-table" style="overflow-x: auto;"></div>
                </div>
            </div>
            <div id="view-mg-analysis" class="view-section">
                <div class="section-header">
                    <h2 class="section-title">Análise de Performance por Conta (MG)</h2>
                </div>
                <div class="chart-filters-container">
                    <div class="filter-group"><label>Modo de Visualização:</label>
                        <div class="checkbox-wrapper"><input type="radio" id="mg-mode-single" name="mg-view-mode"
                                value="single" onchange="toggleMgViewMode('single')" checked><label
                                for="mg-mode-single">Visão Única</label><input type="radio" id="mg-mode-compare"
                                name="mg-view-mode" value="compare" onchange="toggleMgViewMode('compare')"><label
                                for="mg-mode-compare">Modo de Comparação</label></div>
                    </div>
                    <div class="filter-group"><label>Métricas do Gráfico:</label>
                        <div id="mg-metric-checkbox-group" class="checkbox-wrapper"><input type="checkbox"
                                id="mg-metric-gasto" value="gasto" onchange="renderMgAnalysisView()" checked><label
                                for="mg-metric-gasto">Gasto</label><input type="checkbox" id="mg-metric-cpa" value="cpa"
                                onchange="renderMgAnalysisView()" checked><label for="mg-metric-cpa">CPA</label><input
                                type="checkbox" id="mg-metric-cpm" value="cpm" onchange="renderMgAnalysisView()"><label
                                for="mg-metric-cpm">CPM</label><input type="checkbox" id="mg-metric-ctr" value="ctr"
                                onchange="renderMgAnalysisView()"><label for="mg-metric-ctr">CTR</label></div>
                    </div>
                </div>
                <div id="mg-single-view-controls" class="chart-filters-container">
                    <div class="filter-group"><label for="mgAccountFilter">Selecione uma Conta:</label><select
                            id="mgAccountFilter" onchange="renderMgAnalysisView()" style="width: 450px;">
                            <option value="">-- Carregando contas --</option>
                        </select></div>
                </div>
                <div id="mg-compare-view-controls" class="chart-filters-container" style="display: none;">
                    <div class="comparison-controls-wrapper">
                        <div class="search-container">
                            <div class="filter-group"><label for="mgAccountSearch">Buscar conta por
                                    palavra-chave:</label><input type="search" id="mgAccountSearch"
                                    onkeyup="handleMgAccountSearch()" placeholder="Digite para buscar..."
                                    style="width: 100%;">
                                <div id="mgSearchResults" class="search-results"></div>
                            </div>
                        </div>
                        <div class="selected-accounts-container"><label>Contas em comparação:</label>
                            <div id="mgSelectedAccounts" class="selected-accounts-list"></div><button
                                onclick="clearMgComparison()"
                                style="background: #6c757d; margin-top: auto; padding: 5px 10px; font-size: 0.8em;">Limpar
                                Seleção</button>
                        </div>
                    </div>
                </div>
                <div class="charts-grid">
                    <div class="chart-container chart-full">
                        <div id="mg-currency-warning" class="currency-warning-box"></div><canvas
                            id="mgEvolutionChart"></canvas>
                    </div>
                </div>
                <div id="mg-funnel-container" style="display: none; margin-top: 25px;"></div>
                <div class="section-header" style="margin-top: 20px;">
                    <h2 class="section-title">Dados Diários Agregados</h2>
                </div>
                <div class="chart-container chart-full" style="height: auto; padding: 0;">
                    <div id="mg-daily-table" style="overflow-x: auto;"></div>
                </div>
            </div>
    </div>
    </main>
    </div>
    </div>

    <script>
        const SHEET_ID = '1iMEXFAfdB--bCzNYF8DkyTbzxjRARAHXaUX2_KBUvpc';
        const SHEET_NAME = 'Controle_diario';
        const SHEET_NAME_FORECAST = 'Previsoes_Avancadas'; // ADICIONE ESTA LINHA
        const SHEET_NAME_JN = 'EXTRAÇAO JN';
        const SHEET_NAME_MG = 'EXTRAÇAO MG';
        const SHEET_NAME_GRID = 'EXTRAÇAO GRID'; // <-- ADICIONADO
        const EXCLUDED_MANAGERS = ['NICOLE', 'MARCELO', 'AMANDA'];
        const REGION_COLORS = { 'all': { investment: '#6a82fb', roas: '#fd7e14', leads: '#9b59b6' }, 'br': { investment: '#009739', roas: '#2ecc71', leads: '#1abc9c' }, 'us': { investment: '#DC143C', roas: '#e74c3c', leads: '#c0392b' }, 'eu': { investment: '#4169E1', roas: '#3498db', leads: '#2980b9' } };
        const SEGMENT_US_CC = ['MG US CC TOTAL', 'FM US CC TOTAL', 'CL US CC TOTAL', 'GRID US CC TOTAL', 'JN US CC TOTAL'];
        const SEGMENT_US_EMP = ['JN US EMP TOTAL', 'MG US EMP TOTAL'];
        const SEGMENT_BR_CC = ['JN BR CC TOTAL', 'MG BR CC TOTAL'];
        const SEGMENT_BR_EMP = ['JN BR EMP TOTAL', 'MG BR EMP TOTAL'];
        const SEGMENT_DE_CC = ['JN DE CC TOTAL', 'MG DE CC TOTAL'];
        const SEGMENT_FR_CC = ['JN FR CC TOTAL', 'MG FR CC TOTAL'];
        // Adicione esta linha perto do topo do seu <script>
        let selectedManagersForChart = [];
        let selectedCoordinatorsForChart = []; // Adicione esta linha
        let selectedAdopsForChart = []; // Adicione esta linha
        let comparisonTableSortState = {}; // Adicione esta linha
        let aggregatedFunnelTableSortState = {}; // Adicione esta linha

        const COMPANIES = {
            'MG': { name: 'MG', color: '#3498db' }, 'JN': { name: 'JN', color: '#2ecc71' }, 'GRID': { name: 'GRID', color: '#e74c3c' }, 'FM': { name: 'FM', color: '#f1c40f' }, 'CL': { name: 'CL', color: '#9b59b6' }, 'ND': { name: 'ND', color: '#34495e' }
        };

        const GOALS_DATA = {
            'JN EMP BR': { investimento: 65000, roas: 0.90 }, 'JN CC BR': { investimento: 100000, roas: 0.90 }, 'JN CC EUA': { investimento: 500000, roas: 0.80 }, 'JN EMP EUA': { investimento: 375000, roas: 0.80 }, 'JN CC UK': { investimento: 25000, roas: 0.70 }, 'JN CC DE': { investimento: 25000, roas: 0.70 }, 'JN CC AU': { investimento: 25000, roas: 0.70 }, 'JN CC FR': { investimento: 25000, roas: 0.70 }, 'JN CC ES': { investimento: 0, roas: 0.70 }, 'ND CC US': { investimento: 25000, roas: 0.70 }, 'ND CC DE': { investimento: 0, roas: 0.65 }, 'ND CC IT': { investimento: 0, roas: 0.65 }, 'MG CC BR': { investimento: 65000, roas: 0.90 }, 'MG EMP BR': { investimento: 100000, roas: 0.90 }, 'MG CC US': { investimento: 250000, roas: 0.80 }, 'MG EMP US': { investimento: 125000, roas: 0.80 }, 'MG CC FR': { investimento: 15000, roas: 0.70 }, 'MG CC DE': { investimento: 15000, roas: 0.70 }, 'CL CC US': { investimento: 250000, roas: 0.80 }, 'GRID 1 CC US': { investimento: 250000, roas: 0.80 }, 'FM CC US': { investimento: 250000, roas: 0.80 }, 'FM CC FR': { investimento: 15000, roas: 0.70 }, 'FM CC UK': { investimento: 15000, roas: 0.70 }
        };

        // --- METAS ATUALIZADAS PARA A VISÃO OPERACIONAL ---
        const OPERATIONAL_GOALS = {}; // Será preenchido dinamicamente

        const goalsEurope = { roas: -0.30, ctr: 25, cvr: 50 };
        const goalsUSA = { roas: -0.20, ctr: 30, cvr: 50 };
        const goalsBrazil = { roas: -0.10, ctr: 25, cvr: 50 };
        const goalsMexicoAustralia = { roas: -0.30, ctr: 25, cvr: 50 };

        const investmentGoals = {
            'JN CC EUA': 300000, 'MG US CC': 300000, 'JN US CC': 300000,
            'JN EMP EUA': 60000, 'MG US EMP': 30000, 'JN US EMP': 60000,
            'JN CC BR': 50000, 'MG BR CC': 50000,
            'JN EMP BR': 30000, 'MG BR EMP': 30000,
        };

        // Função para construir o objeto de metas dinamicamente
        function buildOperationalGoals() {
            const allOps = Object.keys(GOALS_DATA);
            allOps.forEach(opKey => {
                const upperOp = opKey.toUpperCase();
                let baseGoal = {};
                if (upperOp.includes(' US') || upperOp.includes(' EUA')) baseGoal = { ...goalsUSA };
                else if (upperOp.includes(' BR')) baseGoal = { ...goalsBrazil };
                else if (upperOp.includes(' UK') || upperOp.includes(' FR') || upperOp.includes(' DE') || upperOp.includes(' IT') || upperOp.includes(' ES')) baseGoal = { ...goalsEurope };
                else if (upperOp.includes(' AU') || upperOp.includes(' MX')) baseGoal = { ...goalsMexicoAustralia };

                // Aplica exceções
                if (upperOp === 'ND CC IT') baseGoal.ctr = 5;

                // Aplica metas de investimento específicas
                if (investmentGoals[opKey]) {
                    baseGoal.investimento = investmentGoals[opKey];
                }
                OPERATIONAL_GOALS[opKey] = baseGoal;
            });
        }

        // Regras de busca específicas para operações JN
        const SPECIAL_JN_RULES = {
            'JN AU CC': [['JN', 'APAC'], ['AU', 'CC']],
            'JN FR CC': [['JN', 'EMEA'], ['FR', 'CC']],
            'JN DE CC': [['JN', 'EMEA'], ['DE', 'CC']],
            'JN UK CC': [['JN', 'EMEA'], ['UK', 'CC']],
            'JN BR CC': [['JN', 'LATAM'], ['BR', 'CC']],
            'JN BR EMP': [['JN', 'LATAM'], ['BR', 'EMP']],
            'JN US CC': [['JN', 'NAM'], ['US', 'CC']],
            'JN CC EUA': [['JN', 'NAM'], ['US', 'CC']], // Alias para JN US CC
            'JN US EMP': [['JN', 'NAM'], ['US', 'EMP']],
            'JN EMP EUA': [['JN', 'NAM'], ['US', 'EMP']], // Alias para JN US EMP
        };

        const KEYWORD_MAP = {
            'BR': ['BR', 'BRASIL'], 'US': ['US', 'USA', 'EUA'],
            'CC': ['CC', 'CREDIT CARD'], 'EMP': ['EMP', 'EMPRESTIMO', 'EMPRÉSTIMO']
        };

        const KNOWN_KEYWORDS = new Set([
            'MG', 'JN', 'GRID', 'FM', 'CL', 'ND', 'BR', 'US', 'EUA',
            'UK', 'DE', 'AU', 'FR', 'ES', 'IT', 'CC', 'EMP'
        ]);
        // Adicione esta constante no topo do seu script
        const SPRINT_1810_TARGETS = {
            'EUA': { meta: 800000, ordem: 1 },
            'GRID US': { meta: 100000, ordem: 2, parent: 'EUA' },
            'JN US': { meta: 300000, ordem: 3, parent: 'EUA' },
            'MG US': { meta: 300000, ordem: 4, parent: 'EUA' },
            'JN US EMP': { meta: 70000, ordem: 5, parent: 'EUA' },
            'MG US EMP': { meta: 30000, ordem: 6, parent: 'EUA' },
            'Brasil': { meta: 170000, ordem: 7 },
            'Europa': { meta: 100000, ordem: 8 }
        };

        const SPRINT_1M_DEADLINE = new Date(Date.UTC(2025, 9, 12));
        const SPRINT_1M_GOAL = 1000000;
        const SPRINT_1M_RULES = {
            'JN CC EUA': { finalTarget: 300000 },
            'CL CC US': { target: 10000 },
            'FM CC US': { exclude: true },
            'JN CC BR': { target: 40000 },
            'MG EMP BR': { target: 25000 },
        };
        const SPRINT_1M_BASE_OPERATIONS = ['JN CC EUA', 'JN EMP EUA', 'MG CC US', 'MG EMP US', 'JN CC BR', 'GRID 1 CC US', 'JN CC FR', 'JN CC DE', 'MG CC BR', 'MG CC DE', 'MG CC FR', 'MG EMP BR', 'CL CC US', 'ND CC US', 'JN EMP BR'];

        let rawData = [], filteredData = [], charts = {};
        let rawDataJn = [], filteredDataJn = [];
        let rawDataMg = [], filteredDataMg = [];
        let rawDataGrid = [], filteredDataGrid = []; // <-- ADICIONADO
        let rawDataForecast = [];
        let segmentDataCache = {}, tableSortState = {}, metasTableSortState = {};
        let jnTableSortState = {};
        let mgTableSortState = {};
        let gridTableSortState = {}; // <-- ADICIONADO
        let gridComparedAccounts = []; // <-- ADICIONADO

        let jnComparedAccounts = [];
        let mgComparedAccounts = [];
        const FANCY_COLORS = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6', '#34495e', '#1abc9c', '#e67e22'];
        const METRIC_COLORS = { spend: '#3498db', cpa: '#e74c3c', cpm: '#f1c40f', ctr: '#2ecc71' };

        Chart.register(ChartDataLabels);

        // --- UTILITY FUNCTIONS ---
        function hexToRgba(hex, alpha = 1) { if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) return `rgba(200,200,200,${alpha})`; let c = hex.substring(1).split(''); if (c.length === 3) { c = [c[0], c[0], c[1], c[1], c[2], c[2]]; } c = '0x' + c.join(''); return `rgba(${(c >> 16) & 255}, ${(c >> 8) & 255}, ${c & 255}, ${alpha})`; }
        function parseMonetaryValue(v) { let valueStr = String(v || '0'); valueStr = valueStr.replace(/[R$\s]/g, ''); if (valueStr.lastIndexOf(',') > valueStr.lastIndexOf('.')) { valueStr = valueStr.replace(/\./g, '').replace(',', '.'); } else { valueStr = valueStr.replace(/,/g, ''); } return parseFloat(valueStr) || 0; }
        function parseDate(dateStr) { if (!dateStr || typeof dateStr !== 'string') return null; const parts = dateStr.split('/'); if (parts.length === 3) { return new Date(Date.UTC(parseInt(parts[2], 10), parseInt(parts[1], 10) - 1, parseInt(parts[0], 10))); } return null; }
        function formatDate(dateObj, simple = false) { if (!dateObj) return null; const day = dateObj.getUTCDate().toString().padStart(2, '0'); const month = (dateObj.getUTCMonth() + 1).toString().padStart(2, '0'); if (simple) return `${day}/${month}`; return `${day}/${month}/${dateObj.getUTCFullYear()}`; }
        function endsWithTOTAL(text) { return /\bTOTAL\s*$/i.test(text || ''); }
        function formatCurrency(value, accountName = '') { const isUsd = accountName && accountName.toUpperCase().includes('USD'); const locale = isUsd ? 'en-US' : 'pt-BR'; const currency = isUsd ? 'USD' : 'BRL'; if (isNaN(value) || value === null) { return (0).toLocaleString(locale, { style: 'currency', currency: currency }); } return value.toLocaleString(locale, { style: 'currency', currency: currency }); }
        function formatKilo(num, accountName = '') { const symbol = (accountName && accountName.toUpperCase().includes('USD')) ? '$' : 'R$'; if (Math.abs(num) >= 1000000) return `${symbol} ` + (num / 1000000).toFixed(1).replace('.', ',') + 'M'; if (Math.abs(num) >= 1000) return `${symbol} ` + (num / 1000).toFixed(1).replace('.', ',') + 'k'; return formatCurrency(num, accountName); }
        function getPlatformFromOperation(opName) { return (opName || '').substring(0, 2).toUpperCase() === 'ND' ? 'Meta Ads' : 'Google Ads'; }
        function getGoalKeyFromOperation(opName) { let cleanOp = opName.replace(' TOTAL', '').trim(); if (cleanOp.startsWith('GRID US')) return 'GRID 1 CC US'; const parts = cleanOp.split(' '); if (parts.length < 3) return cleanOp; const company = parts[0]; const country = parts[1]; const niche = parts.slice(2).join(' '); let potentialKey = `${company} ${niche} ${country}`; if (GOALS_DATA[potentialKey]) return potentialKey; if (country === 'US') { const euaKey = `${company} ${niche} EUA`; if (GOALS_DATA[euaKey]) return euaKey; } return potentialKey; }

        // --- DATA LOADING & CACHING ---
        function parseCsv(csvText) { return new Promise((resolve, reject) => { Papa.parse(csvText, { header: true, skipEmptyLines: true, complete: resolve, error: reject }); }); }

        async function loadAllData(forceRefresh = false) {
            document.getElementById('loader').style.display = 'flex';
            document.getElementById('updateBtn').disabled = true;
            document.getElementById('status').textContent = '⏳ Carregando dados...';
            try {
                // Adicionado gridResponse e fetch para SHEET_NAME_GRID
                const [mainResponse, jnResponse, mgResponse, gridResponse, forecastResponse] = await Promise.all([
                    fetch(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME)}`, { cache: forceRefresh ? 'reload' : 'default' }),
                    fetch(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME_JN)}`, { cache: forceRefresh ? 'reload' : 'default' }),
                    fetch(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME_MG)}`, { cache: forceRefresh ? 'reload' : 'default' }),
                    fetch(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME_GRID)}`, { cache: forceRefresh ? 'reload' : 'default' }), // <-- NOVO FETCH
                    fetch(`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME_FORECAST)}`, { cache: forceRefresh ? 'reload' : 'default' })
                ]);

                // Adicionado gridResponse.ok na verificação
                if (!mainResponse.ok || !jnResponse.ok || !mgResponse.ok || !gridResponse.ok || !forecastResponse.ok) throw new Error(`A resposta da rede não foi bem-sucedida.`);

                // Adicionado gridCsvText
                const [mainCsvText, jnCsvText, mgCsvText, gridCsvText, forecastCsvText] = await Promise.all([mainResponse.text(), jnResponse.text(), mgResponse.text(), gridResponse.text(), forecastResponse.text()]);

                // Adicionado gridResults e parseCsv(gridCsvText)
                const [mainResults, jnResults, mgResults, gridResults, forecastResults] = await Promise.all([parseCsv(mainCsvText), parseCsv(jnCsvText), parseCsv(mgCsvText), parseCsv(gridCsvText), parseCsv(forecastCsvText)]);

                // Processamento dos dados principais (rawData)
                rawData = mainResults.data.map(row => ({
                    data: row.DATA,
                    operacao: row['OPERAÇÃO'],
                    gasto: parseMonetaryValue(row.GASTO),
                    receita: parseMonetaryValue(row.RECEITA),
                    cpa: parseMonetaryValue(row.CPA),
                    leads: parseInt(row['TOTAL DE LEADS'] || 0),
                    responsavelAquisicao: row['RESPONSÁVEL AQUISIÇÃO'],
                    responsavelMonetizacao: row['ADOPS'],
                    coordenadorAquisicao: row['COORDENADOR(A) AQUISIÇÃO']
                })).filter(row => row.operacao && row.operacao.trim() !== '');

                // Função reutilizável para mapear dados de contas (JN, MG, GRID)
                const mapAccountData = (row) => ({
                    day: row['Day'] ? String(row['Day']).trim() : null,
                    accountName: row['Account Name'] ? String(row['Account Name']).trim() : null,
                    impressions: parseInt(String(row['Impressions'] || '0').replace(/,/g, '')),
                    clicks: parseInt(String(row['Clicks'] || '0').replace(/,/g, '')),
                    ctr: parseFloat(String(row['CTR'] || '0').replace('%', '').replace(',', '.')),
                    conversions: parseFloat(String(row['Conversions'] || '0').replace(',', '.')),
                    convRate: parseFloat(String(row['Conv. rate'] || '0').replace('%', '').replace(',', '.')),
                    spend: parseMonetaryValue(row['Cost (Spend)'] || row['Cost']),
                    cpm: parseMonetaryValue(row['Avg. CPM']),
                    cpc: parseMonetaryValue(row['Avg. CPC']),
                    cpa: parseMonetaryValue(row['Cost / conv.'])
                });

                // Processamento dos dados JN e MG
                rawDataJn = jnResults.data.map(mapAccountData).filter(row => row.accountName && row.day);
                rawDataMg = mgResults.data.map(mapAccountData).filter(row => row.accountName && row.day);

                // --- Processamento dos dados GRID ---
                rawDataGrid = gridResults.data.map(mapAccountData).filter(row => row.accountName && row.day);
                // --- FIM ---

                // Processamento dos dados de Forecast
                rawDataForecast = forecastResults.data.map(row => ({
                    data: new Date(row.Data),
                    gasto: parseFloat(row.Previsao_Gasto),
                    receita: parseFloat(row.Previsao_Receita)
                }));

                return rawData;

            } catch (error) {
                document.getElementById('status').textContent = `❌ Erro no carregamento: ${error.message}`;
                console.error("Erro detalhado:", error);
            } finally {
                document.getElementById('loader').style.display = 'none';
                document.getElementById('updateBtn').disabled = false;
                if (!document.getElementById('status').textContent.includes('Erro')) {
                    document.getElementById('status').textContent = `✅ Dados atualizados!`;
                }
            }
        }
        // Adicione esta função inteira ao seu JavaScript
        // SUBSTITUA a sua função antiga por esta versão completa
        function renderSprint1810Table(allFilteredData, ontemData) {
            const container = document.getElementById('sprint-1810-table-container');
            if (!container || !ontemData || ontemData.length === 0) return;

            const sprintEndDate = parseDate('18/10/2025');
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);

            // Dias restantes para melhorar, incluindo hoje. Se hoje for dia 18, resta 1 dia para agir.
            const daysLeft = Math.max(1, (sprintEndDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24) + 1);

            // Função interna agora usa 'ontemData', que já está filtrado para o último dia.
            const getSpendForCategory = (category, dataset) => {
                let filteredData = [];
                const op = category.toUpperCase();

                if (op === 'BRASIL') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().includes('BR'));
                } else if (op === 'EUA') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().includes('US'));
                } else if (op === 'EUROPA') {
                    filteredData = dataset.filter(r => ['FR', 'DE', 'UK', 'AU'].some(c => r.operacao.toUpperCase().includes(c)));
                } else if (op === 'GRID US') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().startsWith('GRID') && r.operacao.toUpperCase().includes('US'));
                } else if (op === 'JN US') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().startsWith('JN') && r.operacao.toUpperCase().includes('US') && !r.operacao.toUpperCase().includes('EMP'));
                } else if (op === 'MG US') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().startsWith('MG') && r.operacao.toUpperCase().includes('US') && !r.operacao.toUpperCase().includes('EMP'));
                } else if (op === 'JN US EMP') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().startsWith('JN') && r.operacao.toUpperCase().includes('US') && r.operacao.toUpperCase().includes('EMP'));
                } else if (op === 'MG US EMP') {
                    filteredData = dataset.filter(r => r.operacao.toUpperCase().startsWith('MG') && r.operacao.toUpperCase().includes('US') && r.operacao.toUpperCase().includes('EMP'));
                }
                return filteredData.reduce((sum, r) => sum + r.gasto, 0);
            };

            let tableHTML = `<table class="performance-table">
        <thead>
            <tr>
                <th>Operação/Região</th>
                <th>Meta Diária (18/10)</th>
                <th>Gasto Último Dia</th>
                <th style="min-width: 180px;">Progresso</th>
                <th>Gap para Meta</th>
                <th>Incremento Diário Nec.</th>
            </tr>
        </thead>
        <tbody>`;

            let totals = { meta: 0, gastoUltimoDia: 0, gap: 0, incremento: 0 };

            const sortedCategories = Object.keys(SPRINT_1810_TARGETS).sort((a, b) => SPRINT_1810_TARGETS[a].ordem - SPRINT_1810_TARGETS[b].ordem);

            for (const category of sortedCategories) {
                const item = SPRINT_1810_TARGETS[category];
                const target = item.meta;
                const lastDaySpend = getSpendForCategory(category, ontemData); // Usa os dados de ontem
                const gap = target - lastDaySpend;
                const dailyIncrementNeeded = gap > 0 ? gap / daysLeft : 0;
                const progress = target > 0 ? (lastDaySpend / target) * 100 : 0;
                const isSubItem = !!item.parent;

                tableHTML += `
            <tr style="${isSubItem ? 'font-size: 0.9em; background-color: #f8f9fa;' : ''}">
                <td style="${isSubItem ? 'padding-left: 30px;' : ''}">${category}</td>
                <td>${formatCurrency(target)}</td>
                <td>${formatCurrency(lastDaySpend)}</td>
                <td>
                    <div class="progress-bar-container">
                        <div class="progress-bar"><div class="progress-bar-inner ${progress >= 100 ? 'positive' : ''}" style="width: ${Math.min(100, progress)}%;"></div></div>
                        <span class="progress-percent">${progress.toFixed(1)}%</span>
                    </div>
                </td>
                <td class="${gap <= 0 ? 'delta-positive' : 'delta-negative'}">${formatCurrency(gap)}</td>
                <td style="font-weight: bold; color: var(--color-negative);">${gap > 0 ? `+${formatCurrency(dailyIncrementNeeded)}` : 'R$ 0,00'}</td>
            </tr>`;

                if (!isSubItem) {
                    totals.meta += target;
                    totals.gastoUltimoDia += lastDaySpend;
                    totals.gap += gap;
                    totals.incremento += dailyIncrementNeeded;
                }
            }

            const totalProgress = totals.meta > 0 ? (totals.gastoUltimoDia / totals.meta) * 100 : 0;

            tableHTML += `</tbody>
        <tfoot>
            <tr>
                <td>Total Geral</td>
                <td>${formatCurrency(totals.meta)}</td>
                <td>${formatCurrency(totals.gastoUltimoDia)}</td>
                <td>
                     <div class="progress-bar-container">
                        <div class="progress-bar"><div class="progress-bar-inner ${totalProgress >= 100 ? 'positive' : ''}" style="width: ${Math.min(100, totalProgress)}%;"></div></div>
                        <span class="progress-percent">${totalProgress.toFixed(1)}%</span>
                    </div>
                </td>
                <td>${formatCurrency(totals.gap)}</td>
                <td>+${formatCurrency(totals.incremento)}</td>
            </tr>
        </tfoot>
    </table>`;

            container.innerHTML = tableHTML;
        }
        // ADICIONE ESTE BLOCO DE NOVAS FUNÇÕES NO FINAL DO SEU SCRIPT

        /**
         * Popula o dropdown de seleção de operação do planejador.
         * Usa apenas sub-operações (não-TOTAL).
         */
        // 1. SUBSTITUA ESTA FUNÇÃO
        function populatePlannerOperationFilter(data) {
            const select = document.getElementById('plannerOperationFilter');
            if (!select) return;

            // MODIFICADO: Agora pega apenas operações "TOTAL"
            const operations = [...new Set(data.map(r => r.operacao).filter(Boolean))]
                .filter(op => endsWithTOTAL(op)) // Apenas operações TOTAIS
                .sort();

            // MODIFICADO: Texto do select
            select.innerHTML = '<option value="">-- Selecione uma Operação Total --</option>';
            operations.forEach(op => {
                // MODIFICADO: Remove " TOTAL" do texto
                select.innerHTML += `<option value="${op}">${op.replace(' TOTAL', '')}</option>`;
            });
        }
        function getOperationKeyFromAccountName(accountName) {
            if (!accountName) return 'Desconhecida';
            const upperName = accountName.toUpperCase();

            let company = null;
            if (upperName.includes('JN')) company = 'JN';
            else if (upperName.includes('MG')) company = 'MG';
            else if (upperName.includes('GRID')) company = 'GRID';
            else if (upperName.includes('FM')) company = 'FM';
            else if (upperName.includes('CL')) company = 'CL';
            else if (upperName.includes('ND')) company = 'ND';


            let region = null;
            // Regra especial para JN NAM US
            if (company === 'JN' && upperName.includes('NAM') && (upperName.includes(' US ') || upperName.includes(' US|') || upperName.endsWith(' US'))) {
                region = 'US';
            } else if (upperName.includes(' US ') || upperName.includes(' EUA ') || upperName.includes('|US|') || upperName.endsWith(' US')) {
                 region = 'US';
            } else if (upperName.includes(' BR ') || upperName.includes(' BRASIL ') || upperName.includes('|BR|') || upperName.endsWith(' BR')) {
                 region = 'BR';
            } else if (upperName.includes(' DE ') || upperName.includes('|DE|') || upperName.endsWith(' DE')) {
                 region = 'DE';
            } else if (upperName.includes(' FR ') || upperName.includes('|FR|') || upperName.endsWith(' FR')) {
                 region = 'FR';
            } else if (upperName.includes(' UK ') || upperName.includes('|UK|') || upperName.endsWith(' UK')) {
                 region = 'UK';
            } else if (upperName.includes(' AU ') || upperName.includes('|AU|') || upperName.endsWith(' AU')) {
                 region = 'AU';
            }
             // Adicione outras regiões se necessário (ES, IT, MX...)
             else if (upperName.includes(' ES ') || upperName.includes('|ES|') || upperName.endsWith(' ES')) { region = 'ES'; }
             else if (upperName.includes(' IT ') || upperName.includes('|IT|') || upperName.endsWith(' IT')) { region = 'IT'; }
             else if (upperName.includes(' MX ') || upperName.includes('|MX|') || upperName.endsWith(' MX')) { region = 'MX'; }

            let niche = null;
            if (upperName.includes(' CC ') || upperName.includes('CREDIT') || upperName.includes('|CC|')) {
                niche = 'CC';
            } else if (upperName.includes(' EMP ') || upperName.includes('EMPRÉSTIMO') || upperName.includes('EMPRESTIMO') || upperName.includes('|EMP|')) {
                niche = 'EMP';
            }

            if (company && region && niche) {
                // Ajusta EUA para US na chave final
                const finalRegion = region === 'EUA' ? 'US' : region;
                return `${company} ${finalRegion} ${niche}`;
            }

            // Fallback: Tenta encontrar uma correspondência em GOALS_DATA (menos preciso)
            const parts = upperName.split(/[\s|_-]+/); // Divide por espaço, pipe, underscore, hífen
            const foundCompany = parts.find(p => ['JN', 'MG', 'GRID', 'FM', 'CL', 'ND'].includes(p));
            const foundRegion = parts.find(p => ['US', 'EUA', 'BR', 'DE', 'FR', 'UK', 'AU', 'ES', 'IT', 'MX'].includes(p));
            const foundNiche = parts.find(p => ['CC', 'EMP'].includes(p));
            if (foundCompany && foundRegion && foundNiche) {
                 // Ajusta EUA para US
                 const finalRegion = foundRegion === 'EUA' ? 'US' : foundRegion;
                 return `${foundCompany} ${finalRegion} ${foundNiche}`;
            }

            console.warn(`Não foi possível classificar a conta: ${accountName}`); // Log para contas não classificadas
            return `Outros (${company || '?'})`; // Retorna uma chave genérica se não identificar
        }

        /**
         * Gera o código SVG para um funil de operação individual.
         * Recebe o nome da operação e os totais agregados.
         */
        function createSingleOperationFunnelSVG(operationName, totals) {
            const ctr = totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0;
            const cvr = totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0;

            // Dimensões e cálculos (iguais aos da renderAccountFunnel)
            const svgWidth = 400; // Um pouco menor para caber melhor na grade
            const svgHeight = 200;
            const sectionHeight = svgHeight / 3;
            const funnelTopWidth = svgWidth;
            const funnelBottomWidth = svgWidth * 0.3;
            const topX = 0;
            const topRightX = funnelTopWidth;
            const mid1_LeftX = (funnelTopWidth - (funnelTopWidth * 0.75)) / 2;
            const mid1_RightX = funnelTopWidth - mid1_LeftX;
            const mid2_LeftX = (funnelTopWidth - (funnelTopWidth * 0.52)) / 2;
            const mid2_RightX = funnelTopWidth - mid2_LeftX;
            const bottomX = (funnelTopWidth - funnelBottomWidth) / 2;
            const bottomRightX = funnelTopWidth - bottomX;

            // Formatação de números grandes
            const formatFunnelValue = (value) => {
                if (!value) return '0'; // Retorna '0' se o valor for nulo ou indefinido
                if (value >= 1000000) return (value / 1000000).toFixed(1).replace('.',',') + 'M';
                if (value >= 1000) return (value / 1000).toFixed(0) + 'k';
                // Para conversões que podem ser decimais
                return value.toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: (value % 1 !== 0 ? 2 : 0) });
            };


            const funnelHTML = `
                <div class="funnel-wrapper" style="padding: 20px 15px; border-radius: var(--border-radius); box-shadow: var(--shadow); border: 1px solid var(--border-color); background: var(--bg-light);">
                    <h3 style="font-size: 1.2em; margin-bottom: 15px; color: var(--text-color); text-align: center;">${operationName}</h3>
                    <svg class="funnel-svg" viewBox="0 0 ${svgWidth + 80} ${svgHeight}" preserveAspectRatio="xMidYMid meet" style="max-width: 100%; display: block; margin: 0 auto;">

                        <g class="funnel-section-group">
                            <title>Impressões: ${totals.impressions.toLocaleString('pt-BR')}</title>
                            <polygon class="funnel-polygon" points="${topX},0 ${topRightX},0 ${mid1_RightX},${sectionHeight} ${mid1_LeftX},${sectionHeight}" fill="#6a82fb" />
                            <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight / 2 - 8}" font-size="12">Impressões</text>
                            <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight / 2 + 18}" font-size="24">${formatFunnelValue(totals.impressions)}</text>
                        </g>

                        <g class="funnel-section-group">
                            <title>Cliques: ${totals.clicks.toLocaleString('pt-BR')} (CTR: ${ctr.toFixed(1)}%)</title>
                            <polygon class="funnel-polygon" points="${mid1_LeftX},${sectionHeight} ${mid1_RightX},${sectionHeight} ${mid2_RightX},${sectionHeight * 2} ${mid2_LeftX},${sectionHeight * 2}" fill="#5087f8" />
                            <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight * 1.5 - 8}" font-size="12">Cliques</text>
                            <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight * 1.5 + 18}" font-size="24">${formatFunnelValue(totals.clicks)}</text>
                        </g>

                        <g class="funnel-section-group">
                            <title>Conversões: ${totals.conversions.toLocaleString('pt-BR', { maximumFractionDigits: 2 })} (CVR: ${cvr.toFixed(1)}%)</title>
                            <polygon class="funnel-polygon" points="${mid2_LeftX},${sectionHeight * 2} ${mid2_RightX},${sectionHeight * 2} ${bottomRightX},${svgHeight} ${bottomX},${svgHeight}" fill="#3478e8" />
                            <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight * 2.5 - 8}" font-size="12">Conversões</text>
                            <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight * 2.5 + 18}" font-size="24">${formatFunnelValue(totals.conversions)}</text>
                        </g>

                        <defs>
                            <marker id="arrowhead" markerWidth="8" markerHeight="5" refX="0" refY="2.5" orient="auto">
                                <polygon points="0 0, 8 2.5, 0 5" fill="#adb5bd" />
                            </marker>
                        </defs>

                        <path class="funnel-loss-arrow" stroke="#adb5bd" stroke-width="1.5" fill="none" d="M ${topRightX + 10} ${sectionHeight * 0.4} Q ${topRightX + 40} ${sectionHeight * 0.9}, ${mid1_RightX + 10} ${sectionHeight * 1.4}" marker-end="url(#arrowhead)"></path>
                        <text class="funnel-loss-text" fill="#6c757d" font-size="13" x="${topRightX + 45}" y="${sectionHeight * 0.95}">
                            ${ctr.toFixed(1)}%
                        </text>

                        <path class="funnel-loss-arrow" stroke="#adb5bd" stroke-width="1.5" fill="none" d="M ${mid1_RightX + 10} ${sectionHeight * 1.4} Q ${mid1_RightX + 30} ${sectionHeight * 1.9}, ${mid2_RightX + 10} ${sectionHeight * 2.4}" marker-end="url(#arrowhead)"></path>
                         <text class="funnel-loss-text" fill="#6c757d" font-size="13" x="${mid1_RightX + 35}" y="${sectionHeight * 1.95}">
                            ${cvr.toFixed(1)}%
                        </text>
                    </svg>
                </div>
            `;
            return funnelHTML;
        }

        /**
         * Agrega dados de JN, MG, GRID por operação e renderiza os funis.
         */
        /**
         * Agrega dados de JN, MG, GRID por operação e chama as funções
         * para renderizar os funis SVG e a tabela comparativa.
         */
         /**
         * Agrega dados de JN, MG, GRID por CATEGORIA (US CC, US EMP, etc.)
         * e chama as funções para renderizar os funis SVG e a tabela comparativa.
         */
        function renderAggregatedFunnel() {
            const svgContainer = document.getElementById('aggregated-funnel-container');
            const tableContainer = document.getElementById('aggregated-funnel-table-container');

            if (!svgContainer || !tableContainer) return;
            console.log("--- renderAggregatedFunnel (por Categoria) Iniciada ---"); // Log

            // 1. Combina os dados filtrados das três fontes
            const combinedData = [...filteredDataJn, ...filteredDataMg, ...filteredDataGrid];
            console.log(`Total de ${combinedData.length} linhas detalhadas (filtradas por data) para agregar por categoria.`);

            if (combinedData.length === 0) {
                 const placeholder = '<p style="grid-column: 1 / -1; text-align: center; padding: 20px; color: var(--text-light);">Nenhum dado detalhado de contas (JN/MG/GRID) encontrado para o período selecionado.</p>';
                 svgContainer.innerHTML = placeholder;
                 tableContainer.innerHTML = placeholder.replace('grid-column: 1 / -1; ','');
                 console.warn("Sem dados detalhados para agregar.");
                 return;
            }

            // 2. Agrega por CHAVE DE CATEGORIA usando a nova função
            const aggregatedCategories = combinedData.reduce((acc, row) => {
                const categoryKey = getCategoryKeyFromAccountName(row.accountName); // Usa a nova função
                if (categoryKey) { // Só agrega se pertencer a uma categoria definida
                     if (!acc[categoryKey]) {
                         acc[categoryKey] = { impressions: 0, clicks: 0, conversions: 0, spend: 0 };
                     }
                     acc[categoryKey].impressions += Number(row.impressions) || 0;
                     acc[categoryKey].clicks += Number(row.clicks) || 0;
                     acc[categoryKey].conversions += Number(row.conversions) || 0;
                     acc[categoryKey].spend += Number(row.spend) || 0;
                 } else {
                     // Log opcional para contas não categorizadas
                     // console.log(`Conta não categorizada: ${row.accountName}`);
                 }
                return acc;
            }, {});
            console.log("Dados agregados por CATEGORIA:", aggregatedCategories);


            // 3. Converte para array, calcula métricas e ordena (pode remover filtro de impressões se quiser mostrar todas as categorias)
            const categoryData = Object.entries(aggregatedCategories)
                // .filter(([key, data]) => data.impressions > 100) // Pode remover ou ajustar este filtro
                .map(([categoryKey, data]) => { // Calcula métricas
                    const ctr = data.impressions > 0 ? (data.clicks / data.impressions) * 100 : 0;
                    const cvrClicks = data.clicks > 0 ? (data.conversions / data.clicks) * 100 : 0;
                    const cvrImpr = data.impressions > 0 ? (data.conversions / data.impressions) * 100 : 0;
                    const cpa = data.conversions > 0 ? data.spend / data.conversions : 0;
                    const cpm = data.impressions > 0 ? (data.spend / data.impressions) * 1000 : 0;
                    return {
                        opKey: categoryKey, // Mantém opKey para compatibilidade com a função da tabela
                        impressions: data.impressions,
                        clicks: data.clicks,
                        conversions: data.conversions,
                        spend: data.spend,
                        ctr,
                        cvrClicks,
                        cvrImpr,
                        cpa,
                        cpm
                    };
                })
                // Ordena por uma ordem específica desejada, depois alfabeticamente
                .sort((a, b) => {
                     const order = ["US CC", "US EMP", "BR CC", "BR EMP", "Europa CC"];
                     const indexA = order.indexOf(a.opKey);
                     const indexB = order.indexOf(b.opKey);
                     if (indexA !== -1 && indexB !== -1) return indexA - indexB; // Ordena pela lista
                     if (indexA !== -1) return -1; // Coloca itens da lista primeiro
                     if (indexB !== -1) return 1;
                     return a.opKey.localeCompare(b.opKey); // Ordena outros alfabeticamente
                 });

            console.log(`Dados finais das categorias para renderizar (${categoryData.length}):`, categoryData);

            if (categoryData.length === 0) {
                const placeholder = '<p style="grid-column: 1 / -1; text-align: center; padding: 20px; color: var(--text-light);">Nenhuma das categorias agregadas (US CC, BR EMP, etc.) teve dados no período selecionado.</p>';
                 svgContainer.innerHTML = placeholder;
                 tableContainer.innerHTML = placeholder.replace('grid-column: 1 / -1; ','');
                 console.warn("Nenhuma categoria com dados encontrada após agregação.");
                 return;
            }

            // 4. Renderiza os Funis SVG para cada CATEGORIA
            svgContainer.innerHTML = '';
            categoryData.forEach(catData => {
                 const svgTotals = { impressions: catData.impressions, clicks: catData.clicks, conversions: catData.conversions };
                 // Passa a CHAVE DA CATEGORIA (catData.opKey) como nome
                 svgContainer.innerHTML += createSingleOperationFunnelSVG(catData.opKey, svgTotals);
            });
            console.log("Funis SVG renderizados.");

            // 5. Renderiza a Tabela Comparativa para as CATEGORIAS
            _renderAndAttachSortListenersForAggregatedFunnelTable('aggregated-funnel-table-container', categoryData);
            console.log("Tabela agregada renderizada.");
        }
        /**
         * Helper para renderizar a tabela comparativa de funis agregados e adicionar listeners de ordenação.
         */
         function _renderAndAttachSortListenersForAggregatedFunnelTable(elementId, data) {
            const container = document.getElementById(elementId);
            if (!container) return;

            const currentSort = aggregatedFunnelTableSortState[elementId] || { key: 'impressions', order: 'desc' }; // Default sort
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };

             // Ordena os dados ANTES de renderizar
            const sortedData = [...data].sort((a, b) => {
                const valA = a[currentSort.key];
                const valB = b[currentSort.key];
                // CPA é melhor menor, strings ordenam alfabeticamente
                if (currentSort.key === 'opKey') {
                     return currentSort.order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else if (currentSort.key === 'cpa') {
                    // Trata CPA 0 ou inválido como 'pior' (maior valor) na ordenação
                     const effectiveA = (valA && isFinite(valA) && valA > 0) ? valA : Infinity;
                     const effectiveB = (valB && isFinite(valB && valB > 0)) ? valB : Infinity;
                    return currentSort.order === 'asc' ? effectiveA - effectiveB : effectiveB - effectiveA;
                } else { // Outras métricas numéricas (Impressões, Cliques, Conv, CTR, CVRs, Spend) são melhores maiores
                    return currentSort.order === 'asc' ? valA - valB : valB - valA;
                }
            });

            // Define os cabeçalhos da tabela
            const headers = [
                // MUDE O LABEL AQUI
                { key: 'opKey', label: 'Categoria Agregada' }, // <- MUDOU DE 'Operação'
                { key: 'impressions', label: 'Impressões', format: v => v.toLocaleString('pt-BR') },
                { key: 'clicks', label: 'Cliques', format: v => v.toLocaleString('pt-BR') },
                { key: 'ctr', label: 'CTR (Cliques/Impr.)', format: v => `${v.toFixed(1)}%`, positive: true },
                { key: 'conversions', label: 'Conversões', format: v => v.toLocaleString('pt-BR', { maximumFractionDigits: 1 }) },
                { key: 'cvrClicks', label: 'CVR (Conv./Cliques)', format: v => `${v.toFixed(1)}%`, positive: true },
                { key: 'cvrImpr', label: 'CVR (Conv./Impr.)', format: v => `${v.toFixed(2)}%`, positive: true },
                { key: 'spend', label: 'Gasto', format: v => formatCurrency(v) },
                { key: 'cpm', label: 'CPM', format: v => formatCurrency(v), lowerIsBetter: true },
                { key: 'cpa', label: 'CPA', format: v => formatCurrency(v), lowerIsBetter: true }
            ];

            // Constrói o HTML da tabela
            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                // Adiciona classe 'sortable' e data-sort
                tableHtml += `<th class="sortable" data-sort="${h.key}" style="${h.key === 'opKey' ? 'text-align: left;' : 'text-align: right;'}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedData.forEach(row => {
                tableHtml += `<tr>`;
                headers.forEach(h => {
                    const value = row[h.key];
                    const formattedValue = h.format ? h.format(value) : value;
                    // Aplica alinhamento
                    tableHtml += `<td style="${h.key === 'opKey' ? 'text-align: left; font-weight: 600;' : 'text-align: right;'}">${formattedValue}</td>`;
                });
                tableHtml += `</tr>`;
            });
             tableHtml += `</tbody>`;

             // --- Calcula Totais/Médias para o Footer ---
             const totals = sortedData.reduce((acc, row) => {
                 acc.impressions += row.impressions;
                 acc.clicks += row.clicks;
                 acc.conversions += row.conversions;
                 acc.spend += row.spend;
                 return acc;
             }, { impressions: 0, clicks: 0, conversions: 0, spend: 0 });

             const overallMetrics = {
                 ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
                 cvrClicks: totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0,
                 cvrImpr: totals.impressions > 0 ? (totals.conversions / totals.impressions) * 100 : 0,
                 cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0
             };

             tableHtml += `<tfoot><tr>`;
             headers.forEach(h => {
                  let footerValue = '';
                  if (h.key === 'opKey') footerValue = 'TOTAL / MÉDIA';
                  else if (h.key === 'impressions') footerValue = totals.impressions.toLocaleString('pt-BR');
                  else if (h.key === 'clicks') footerValue = totals.clicks.toLocaleString('pt-BR');
                  else if (h.key === 'conversions') footerValue = totals.conversions.toLocaleString('pt-BR', { maximumFractionDigits: 1 });
                  else if (h.key === 'spend') footerValue = formatCurrency(totals.spend);
                  else if (h.key === 'ctr') footerValue = `${overallMetrics.ctr.toFixed(1)}%`;
                  else if (h.key === 'cvrClicks') footerValue = `${overallMetrics.cvrClicks.toFixed(1)}%`;
                  else if (h.key === 'cvrImpr') footerValue = `${overallMetrics.cvrImpr.toFixed(2)}%`;
                  else if (h.key === 'cpa') footerValue = formatCurrency(overallMetrics.cpa);
                  // Aplica alinhamento
                  tableHtml += `<td style="${h.key === 'opKey' ? 'text-align: left;' : 'text-align: right;'}">${footerValue}</td>`;
             });
             tableHtml += `</tr></tfoot></table>`;


            container.innerHTML = tableHtml;

            // Adiciona listeners de ordenação
            container.querySelectorAll('.performance-table .sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const sortKey = th.dataset.sort;
                    // Usa a função sortTable genérica, passando o cache correto e a função de renderização
                    // Precisamos recriar o cache temporário aqui, pois a função sortTable espera um objeto
                    const tempDataCache = { [elementId]: data };
                    sortTable(elementId, sortKey, tempDataCache, aggregatedFunnelTableSortState, _renderAndAttachSortListenersForAggregatedFunnelTable);
                });
            });
        }
        /**
         * Renderiza a tabela de comparação de funis com base nos filtros de País e Nicho.
         */
         /**
         * Renderiza a tabela de comparação de funis com base nos filtros de País e Nicho.
         */
        /**
         * Renderiza a tabela de comparação de funis com base nos filtros de País e Nicho. CORRIGIDO CPM
         */
         function renderComparisonView() {
            console.log("--- renderComparisonView chamada ---");

            const country = document.getElementById('compare-country-select').value;
            const niche = document.getElementById('compare-niche-select').value;
            const container = document.getElementById('comparison-table-container');

            if (!container) {
                 console.error("Container da tabela de comparação não encontrado!");
                 return;
            }

            console.log(`Filtros selecionados -> País: ${country || 'Nenhum'}, Nicho: ${niche}`);

            if (!country) {
                container.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-light);">Selecione um país para iniciar a comparação.</p>';
                console.log("Nenhum país selecionado, mostrando placeholder.");
                return;
            }

             // 1. Combina os dados JÁ FILTRADOS POR DATA
             const combinedData = [...filteredDataJn, ...filteredDataMg, ...filteredDataGrid];
             console.log(`Total de ${combinedData.length} linhas de dados detalhados (filtrados por data) combinadas.`);

             if (combinedData.length === 0) {
                 container.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-light);">Não há dados detalhados (JN/MG/GRID) para o período selecionado.</p>';
                 console.warn("Não há dados detalhados combinados após filtro de data.");
                 return;
             }

             // 2. Agrega por chave de operação, incluindo GASTO (spend)
             const aggregatedOps = combinedData.reduce((acc, row) => {
                 const opKey = getOperationKeyFromAccountName(row.accountName);
                  if (opKey && !opKey.startsWith('Desconhecida') && !opKey.startsWith('Outros')) {
                     if (!acc[opKey]) {
                         acc[opKey] = { impressions: 0, clicks: 0, conversions: 0, spend: 0 };
                     }
                     acc[opKey].impressions += Number(row.impressions) || 0;
                     acc[opKey].clicks += Number(row.clicks) || 0;
                     acc[opKey].conversions += Number(row.conversions) || 0;
                     acc[opKey].spend += Number(row.spend) || 0;
                 }
                 return acc;
            }, {});
            console.log("Dados agregados por chave de operação (antes de filtrar por país/nicho):", aggregatedOps);


             // 3. Filtra por País e Nicho e calcula métricas derivadas
             const comparisonData = Object.entries(aggregatedOps)
                 .map(([opKey, data]) => ({ opKey, ...data }))
                 .filter(op => {
                     const parts = op.opKey.split(' ');
                     const opCountry = parts.length > 1 ? parts[1] : null;
                     const opNiche = parts.length > 2 ? parts[2] : null;
                     const countryMatch = opCountry === country;
                     const nicheMatch = (niche === 'all' || opNiche === niche);
                     return countryMatch && nicheMatch && (op.impressions > 0 || op.clicks > 0 || op.conversions > 0 || op.spend > 0);
                 })
                 .map(op => { // Calcula métricas
                     const ctr = op.impressions > 0 ? (op.clicks / op.impressions) * 100 : 0;        // Cliques / Impressões
                     const cvrClicks = op.clicks > 0 ? (op.conversions / op.clicks) * 100 : 0;     // Conversões / Cliques
                     const cvrImpr = op.impressions > 0 ? (op.conversions / op.impressions) * 100 : 0; // Conversões / Impressões
                     const cpa = op.conversions > 0 ? op.spend / op.conversions : 0;
                     // --- ADICIONA CÁLCULO CPM ---
                     const cpm = op.impressions > 0 ? (op.spend / op.impressions) * 1000 : 0;    // (Gasto / Impressões) * 1000
                     // --- FIM ADIÇÃO ---
                     return { ...op, ctr, cvrClicks, cvrImpr, cpa, cpm }; // Inclui cpm no retorno
                 });

            console.log(`Dados para comparação (após filtro País/Nicho): ${comparisonData.length} operações`, comparisonData);

            if (comparisonData.length === 0) {
                 container.innerHTML = `<p style="text-align: center; padding: 20px; color: var(--text-light);">Nenhuma operação encontrada para o País '${country}' ${niche !== 'all' ? `e Nicho '${niche}'` : ''} no período selecionado.</p>`;
                 console.warn("Nenhuma operação encontrada após aplicar filtros de país/nicho.");
                 return;
            }

            // 4. Renderiza a tabela com ordenação
            console.log("Chamando _renderAndAttachSortListenersForComparisonTable...");
             _renderAndAttachSortListenersForComparisonTable('comparison-table-container', comparisonData);
        }
        
        /**
         * Helper para renderizar a tabela de comparação e adicionar listeners de ordenação.
         */
         /**
         * Helper para renderizar a tabela de comparação e adicionar listeners de ordenação. CORRIGIDO
         */
        /**
         * Helper para renderizar a tabela de comparação e adicionar listeners de ordenação. CORRIGIDO CPM + LABELS
         */
         function _renderAndAttachSortListenersForComparisonTable(elementId, data) {
            const container = document.getElementById(elementId);
            if (!container) {
                 console.error(`Container com ID "${elementId}" não encontrado.`);
                 return;
             }

            const currentSort = comparisonTableSortState[elementId] || { key: 'impressions', order: 'desc' };
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };

            const sortedData = [...data].sort((a, b) => {
                const valA = a[currentSort.key];
                const valB = b[currentSort.key];
                if (currentSort.key === 'opKey') {
                     return currentSort.order === 'asc' ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
                } else if (currentSort.key === 'cpa' || currentSort.key === 'cpm') { // CPA e CPM são melhores menores
                     const effectiveA = (valA && isFinite(valA) && valA > 0) ? valA : Infinity;
                     const effectiveB = (valB && isFinite(valB && valB > 0)) ? valB : Infinity;
                    return currentSort.order === 'asc' ? effectiveA - effectiveB : effectiveB - effectiveA;
                } else { // Outras métricas numéricas
                     const numA = Number(valA) || 0;
                     const numB = Number(valB) || 0;
                    return currentSort.order === 'asc' ? numA - numB : numB - numA;
                }
            });

            // Adiciona CPM aos maxValues
            const maxValues = {
                impressions: Math.max(...sortedData.map(d => d.impressions), 0),
                clicks: Math.max(...sortedData.map(d => d.clicks), 0),
                conversions: Math.max(...sortedData.map(d => d.conversions), 0),
                ctr: Math.max(...sortedData.map(d => d.ctr), 0),
                cvrClicks: Math.max(...sortedData.map(d => d.cvrClicks), 0),
                cvrImpr: Math.max(...sortedData.map(d => d.cvrImpr), 0),
                spend: Math.max(...sortedData.map(d => d.spend), 0),
                cpa: Math.max(...sortedData.map(d => d.cpa).filter(cpa => cpa > 0 && isFinite(cpa)), 0),
                cpm: Math.max(...sortedData.map(d => d.cpm).filter(cpm => cpm > 0 && isFinite(cpm)), 0) // Max CPM válido
            };
             for(const key in maxValues) { if(maxValues[key] === 0) maxValues[key] = 1; }

            // Atualiza labels e adiciona CPM
            const headers = [
                { key: 'opKey', label: 'Operação' },
                { key: 'impressions', label: 'Impressões', format: v => v.toLocaleString('pt-BR') },
                { key: 'clicks', label: 'Cliques', format: v => v.toLocaleString('pt-BR') },
                { key: 'ctr', label: 'CTR (Cliques/Impr.)', format: v => `${v.toFixed(1)}%`, positive: true }, // Label corrigida
                { key: 'conversions', label: 'Conversões', format: v => v.toLocaleString('pt-BR', { maximumFractionDigits: 1 }) },
                { key: 'cvrClicks', label: 'CVR (Conv./Cliques)', format: v => `${v.toFixed(1)}%`, positive: true }, // Label corrigida
                { key: 'cvrImpr', label: 'CVR (Conv./Impr.)', format: v => `${v.toFixed(2)}%`, positive: true }, // Label corrigida
                { key: 'spend', label: 'Gasto', format: v => formatCurrency(v) },
                { key: 'cpm', label: 'CPM', format: v => formatCurrency(v), lowerIsBetter: true }, // CPM adicionado
                { key: 'cpa', label: 'CPA', format: v => formatCurrency(v), lowerIsBetter: true }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedData.forEach(row => {
                tableHtml += `<tr>`;
                headers.forEach(h => {
                    const value = row[h.key];
                    const formattedValue = (h.format && typeof h.format === 'function') ? h.format(value) : (value != null ? value : '-');
                    let barWidth = 0;
                    let cellClass = '';

                    if (h.key === 'opKey') {
                         cellClass = '';
                    } else if (typeof value === 'number' && isFinite(value) && maxValues[h.key] > 0) {
                        barWidth = (value / maxValues[h.key]) * 100;
                         if (h.lowerIsBetter) { // CPA e CPM
                             const validValues = sortedData.map(d=>d[h.key]).filter(v => v > 0 && isFinite(v)).sort((a,b)=>a-b);
                             const medianValue = validValues.length > 0 ? validValues[Math.floor(validValues.length/2)] : 0;
                             cellClass = (value > 0 && value <= medianValue) ? 'positive-metric' : (value > 0 ? 'negative-metric' : '');
                             cellClass += ' lower-is-better';
                         } else if (h.positive) { // CTR, CVRs
                              const validValues = sortedData.map(d=>d[h.key]).filter(v => isFinite(v)).sort((a,b)=>a-b);
                              const medianValue = validValues.length > 0 ? validValues[Math.floor(validValues.length/2)] : 0;
                             cellClass = value >= medianValue ? 'positive-metric' : 'negative-metric';
                         }
                        barWidth = Math.min(100, Math.max(0, barWidth));
                    } else {
                         cellClass = 'text-muted';
                    }

                    tableHtml += `<td class="${cellClass}" style="${h.key === 'opKey' ? 'text-align: left; font-weight: 600;' : 'text-align: right;'}">`;
                    if (barWidth > 0 && h.key !== 'opKey') {
                        tableHtml += `<div class="data-bar-container">
                                          <div class="data-bar" style="width: ${barWidth.toFixed(1)}%;"></div>
                                          <span>${formattedValue}</span>
                                      </div>`;
                    } else {
                        tableHtml += formattedValue;
                    }
                    tableHtml += `</td>`;
                });
                tableHtml += `</tr>`;
            });
             tableHtml += `</tbody>`;

            // --- Calcula Totais/Médias para o Footer ---
            const totals = sortedData.reduce((acc, row) => {
                acc.impressions += row.impressions;
                acc.clicks += row.clicks;
                acc.conversions += row.conversions;
                acc.spend += row.spend;
                return acc;
            }, { impressions: 0, clicks: 0, conversions: 0, spend: 0 });

            const overallMetrics = {
                ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
                cvrClicks: totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0,
                cvrImpr: totals.impressions > 0 ? (totals.conversions / totals.impressions) * 100 : 0,
                cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0,
                cpm: totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0 // CPM Médio Total
            };

            tableHtml += `<tfoot><tr>`;
            headers.forEach(h => {
                 let footerValue = '';
                 if (h.key === 'opKey') footerValue = 'TOTAL / MÉDIA';
                 else if (h.key === 'impressions') footerValue = totals.impressions.toLocaleString('pt-BR');
                 else if (h.key === 'clicks') footerValue = totals.clicks.toLocaleString('pt-BR');
                 else if (h.key === 'conversions') footerValue = totals.conversions.toLocaleString('pt-BR', { maximumFractionDigits: 1 });
                 else if (h.key === 'spend') footerValue = formatCurrency(totals.spend);
                 else if (h.key === 'ctr') footerValue = `${overallMetrics.ctr.toFixed(1)}%`;
                 else if (h.key === 'cvrClicks') footerValue = `${overallMetrics.cvrClicks.toFixed(1)}%`;
                 else if (h.key === 'cvrImpr') footerValue = `${overallMetrics.cvrImpr.toFixed(2)}%`;
                 else if (h.key === 'cpm') footerValue = formatCurrency(overallMetrics.cpm); // Adiciona CPM ao footer
                 else if (h.key === 'cpa') footerValue = formatCurrency(overallMetrics.cpa);
                 tableHtml += `<td style="${h.key === 'opKey' ? 'text-align: left;' : 'text-align: right;'}">${footerValue}</td>`;
            });
            tableHtml += `</tr></tfoot></table>`; // Fecha a tabela

            container.innerHTML = tableHtml;

            // Adiciona listeners de ordenação
            container.querySelectorAll('.performance-table .sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const sortKey = th.dataset.sort;
                    const tempDataCache = { [elementId]: data };
                    sortTable(elementId, sortKey, tempDataCache, comparisonTableSortState, _renderAndAttachSortListenersForComparisonTable);
                });
            });
        }

        // 2. SUBSTITUA ESTA FUNÇÃO
        async function runGoalPlanner() {
            const selectedTotalOp = document.getElementById('plannerOperationFilter').value;
            const targetSpend = parseFloat(document.getElementById('plannerTargetSpend').value);
            const endDateStr = document.getElementById('plannerEndDate').value;

            const summaryContainer = document.getElementById('plannerSummaryCards');
            const chartContainer = document.getElementById('plannerChartContainer');
            const tableContainer = document.getElementById('plannerTableContainer');

            if (!selectedTotalOp || !targetSpend || !endDateStr) {
                alert("Por favor, preencha todos os campos: Operação, Meta de Gasto e Data Final.");
                return;
            }

            // --- 1. Encontrar Sub-operações ---
            const opPrefix = selectedTotalOp.replace(' TOTAL', '').trim();
            const allOpsInRawData = [...new Set(rawData.map(r => r.operacao).filter(Boolean))];
            const subOps = allOpsInRawData.filter(op => op.startsWith(opPrefix) && !endsWithTOTAL(op));

            if (subOps.length === 0) {
                alert(`Nenhuma sub-operação (ex: ${opPrefix} 01, ${opPrefix} 02) foi encontrada para a operação total '${selectedTotalOp}'. Não é possível calcular o pacing.`);
                return;
            }

            // --- 2. Calcular Datas ---
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            const endDate = new Date(endDateStr + 'T00:00:00Z');
            endDate.setUTCHours(0, 0, 0, 0);

            // O plano começa amanhã
            const tomorrow = new Date(today);
            tomorrow.setUTCDate(today.getUTCDate() + 1);

            if (endDate < tomorrow) {
                alert("A Data Final deve ser a partir de amanhã.");
                return;
            }

            const daysRemaining = Math.max(1, (endDate.getTime() - tomorrow.getTime()) / (1000 * 60 * 60 * 24) + 1);

            // --- 3. Calcular Gasto Acumulado (do grupo) ---
            // Filtra rawData UMA VEZ para todas as sub-operações
            const groupRawData = rawData.filter(r => subOps.includes(r.operacao) && r.data);

            const currentTotalSpend = groupRawData.reduce((sum, r) => sum + r.gasto, 0);

            // --- 4. Calcular Gasto Acumulado por Sub-op (para a tabela) ---
            const currentSpendPerSubOp = subOps.reduce((acc, op) => {
                acc[op] = 0;
                return acc;
            }, {});
            groupRawData.forEach(r => {
                if (currentSpendPerSubOp.hasOwnProperty(r.operacao)) {
                    currentSpendPerSubOp[r.operacao] += r.gasto;
                }
            });

            // --- 5. Calcular Incremento Total ---
            const totalRemainingSpend = targetSpend - currentTotalSpend;
            const totalDailyIncrement = totalRemainingSpend > 0 ? totalRemainingSpend / daysRemaining : 0;

            if (totalRemainingSpend <= 0) {
                alert(`Parabéns! A meta de ${formatCurrency(targetSpend)} já foi atingida (Gasto atual: ${formatCurrency(currentTotalSpend)}).`);
            }

            // --- 6. Calcular Pesos (Weighting) ---
            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setUTCDate(today.getUTCDate() - 7);

            const subOpSpendL7D = subOps.reduce((acc, op) => {
                acc[op] = 0;
                return acc;
            }, {});
            let totalSpendL7D = 0;

            groupRawData.forEach(r => {
                const rowDate = parseDate(r.data);
                if (rowDate >= sevenDaysAgo && rowDate < today) { // Gasto dos últimos 7 dias, sem incluir hoje
                    if (subOpSpendL7D.hasOwnProperty(r.operacao)) {
                        subOpSpendL7D[r.operacao] += r.gasto;
                        totalSpendL7D += r.gasto;
                    }
                }
            });

            // Calcular pesos e incremento diário por sub-op
            const weights = {};
            const dailyIncrementPerSubOp = {};

            subOps.forEach(op => {
                if (totalSpendL7D > 0) {
                    // Distribuição ponderada
                    weights[op] = subOpSpendL7D[op] / totalSpendL7D;
                } else {
                    // Distribuição igual (caso de operações novas sem gasto nos L7D)
                    weights[op] = 1 / subOps.length;
                }
                dailyIncrementPerSubOp[op] = totalDailyIncrement * weights[op];
            });

            // --- 7. Exibir Resumo (para o GRUPO) ---
            summaryContainer.style.display = 'grid';
            summaryContainer.innerHTML =
                createCardHTML({ icon: '💰', title: 'Gasto Real (Acumulado)', value: formatCurrency(currentTotalSpend) }) +
                createCardHTML({ icon: '🎯', title: 'Meta de Gasto Total', value: formatCurrency(targetSpend) }) +
                createCardHTML({ icon: '💸', title: 'Gasto Restante', value: formatCurrency(totalRemainingSpend) }) +
                createCardHTML({ icon: '🏃', title: 'Incremento Diário (Total)', value: formatCurrency(totalDailyIncrement) }) +
                createCardHTML({ icon: '📅', title: 'Dias Restantes', value: `${daysRemaining} dias` });

            // --- 8. Renderizar Gráfico (para o GRUPO) ---
            // Precisamos agregar os dados reais do grupo por dia
            const groupDailyData = groupRawData.reduce((acc, r) => {
                if (!acc[r.data]) {
                    acc[r.data] = { gasto: 0 };
                }
                acc[r.data].gasto += r.gasto;
                return acc;
            }, {});

            const sortedGroupData = Object.keys(groupDailyData)
                .sort((a, b) => parseDate(a) - parseDate(b))
                .map(date => ({ data: date, gasto: groupDailyData[date].gasto }));

            // A função renderPlannerChart existente funciona perfeitamente se passarmos os dados do grupo
            renderPlannerChart(sortedGroupData, currentTotalSpend, targetSpend, endDate, daysRemaining, totalDailyIncrement);

            // --- 9. Renderizar Tabela (detalhada) ---
            renderPlannerTable(currentSpendPerSubOp, dailyIncrementPerSubOp, tomorrow, daysRemaining);

            chartContainer.style.display = 'grid';
            tableContainer.style.display = 'block';
        }

        /**
         * Classifica um nome de conta em uma categoria agregada (US CC, US EMP, BR CC, BR EMP, EU CC).
         * Retorna a string da categoria ou null se não corresponder.
         */
         function getCategoryKeyFromAccountName(accountName) {
            if (!accountName) return null;
            const upperName = accountName.toUpperCase();

            // Flags para país e nicho
            let isUS = upperName.includes(' US ') || upperName.includes(' EUA ') || upperName.includes('|US|') || upperName.endsWith(' US') || (upperName.includes('JN') && upperName.includes('NAM')); // Considera JN NAM
            let isBR = upperName.includes(' BR ') || upperName.includes(' BRASIL ') || upperName.includes('|BR|') || upperName.endsWith(' BR');
            let isEU = upperName.includes(' UK ') || upperName.includes('|UK|') || upperName.endsWith(' UK') ||
                       upperName.includes(' FR ') || upperName.includes('|FR|') || upperName.endsWith(' FR') ||
                       upperName.includes(' DE ') || upperName.includes('|DE|') || upperName.endsWith(' DE');
            // Adicione outros países da Europa se necessário (ES, IT...)

            let isCC = upperName.includes(' CC ') || upperName.includes('CREDIT') || upperName.includes('|CC|');
            let isEMP = upperName.includes(' EMP ') || upperName.includes('EMPRÉSTIMO') || upperName.includes('EMPRESTIMO') || upperName.includes('|EMP|');

            // Define a categoria com base nas flags
            if (isUS && isCC) return "US CC";
            if (isUS && isEMP) return "US EMP";
            if (isBR && isCC) return "BR CC";
            if (isBR && isEMP) return "BR EMP";
            if (isEU && isCC) return "Europa CC"; // Agrupa UK, FR, DE em Europa CC

            return null; // Não pertence a nenhuma categoria agregada
        }

        // 3. SUBSTITUA ESTA FUNÇÃO
        function renderPlannerChart(actualData, currentSpend, targetSpend, endDate, daysRemaining, dailyIncrement) {
            const labels = [];
            const actualDataPoints = [];
            let cumulativeSpend = 0;

            // MODIFICADO: Aceita o novo formato de dados
            // Preenche com dados históricos reais
            actualData.forEach(row => {
                labels.push(row.data); // row.data já está formatado 'dd/mm/yyyy'
                cumulativeSpend += row.gasto;
                actualDataPoints.push(cumulativeSpend);
            });

            const lastActualDate = actualData.length > 0 ? parseDate(actualData[actualData.length - 1].data) : new Date(new Date().setUTCHours(0, 0, 0, 0));

            // Cria os pontos da projeção
            const planDataPoints = [];
            let projectedSpend = currentSpend;

            // Ponto de partida da projeção (último dia real)
            planDataPoints.push(currentSpend);

            // O loop começa de amanhã
            const tomorrow = new Date(lastActualDate.getTime());
            tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);

            for (let i = 0; i < daysRemaining; i++) {
                const nextDay = new Date(tomorrow.getTime() + (1000 * 60 * 60 * 24 * i));
                projectedSpend += dailyIncrement;

                labels.push(formatDate(nextDay));
                planDataPoints.push(projectedSpend);
            }

            // Garante que o último ponto da projeção esteja no gráfico e com o valor exato
            if (daysRemaining > 0) {
                labels[labels.length - 1] = formatDate(endDate);
                planDataPoints[planDataPoints.length - 1] = targetSpend;
            }

            // Preenche os dados reais com 'null' para o futuro
            const fullActualData = [...actualDataPoints, ...Array(planDataPoints.length - (actualDataPoints.length > 0 ? 1 : 0)).fill(null)];

            const datasets = [
                {
                    label: 'Gasto Real (Acumulado)',
                    data: fullActualData,
                    borderColor: '#2ecc71',
                    backgroundColor: 'transparent',
                    yAxisID: 'yCumulative',
                    tension: 0.1,
                    pointRadius: 4
                },
                {
                    label: 'Projeção da Meta',
                    // Começa do último ponto real
                    data: [...Array(actualDataPoints.length - 1).fill(null), ...planDataPoints],
                    borderColor: '#6a82fb',
                    backgroundColor: hexToRgba('#6a82fb', 0.1),
                    fill: true,
                    borderDash: [5, 5],
                    yAxisID: 'yCumulative',
                    tension: 0.1,
                    pointRadius: 4
                }
            ];

            const options = {
                interaction: { mode: 'index', intersect: false },
                plugins: { datalabels: { display: false } },
                scales: {
                    x: { title: { display: true, text: 'Data' }, grid: { display: false } },
                    yCumulative: {
                        type: 'linear',
                        position: 'left',
                        title: { display: true, text: 'Gasto Acumulado (R$)' },
                        ticks: { callback: v => formatKilo(v) }
                    }
                }
            };

            createOrUpdateChart('plannerChart', 'line', { labels, datasets }, options);
        }

        // 4. SUBSTITUA ESTA FUNÇÃO
        function renderPlannerTable(currentSpendPerSubOp, dailyIncrementPerSubOp, startDate, daysRemaining) {
            const container = document.getElementById('plannerTable');
            const subOps = Object.keys(currentSpendPerSubOp).sort();

            // Reutiliza a classe da tabela de Sprint para um bom layout largo
            let tableHTML = `<table class="performance-table sprint-table"><thead><tr><th>Data</th>`;

            subOps.forEach(op => {
                tableHTML += `<th>${op} (Gasto Diário)</th>`;
                tableHTML += `<th>${op} (Acumulado)</th>`;
            });

            tableHTML += `<th>Total Diário</th><th>Total Acumulado</th></tr></thead><tbody>`;

            // Clona os gastos atuais para iniciar o acumulado do plano
            const cumulativePlanPerSubOp = { ...currentSpendPerSubOp };
            let cumulativeTotalPlan = Object.values(currentSpendPerSubOp).reduce((a, b) => a + b, 0);

            for (let i = 0; i < daysRemaining; i++) {
                const nextDay = new Date(startDate.getTime() + (1000 * 60 * 60 * 24 * i));
                let dailyTotalIncrement = 0;

                tableHTML += `<tr><td>${formatDate(nextDay)}</td>`;

                subOps.forEach(op => {
                    const dailyIncrement = dailyIncrementPerSubOp[op];
                    cumulativePlanPerSubOp[op] += dailyIncrement;
                    dailyTotalIncrement += dailyIncrement;

                    tableHTML += `<td style="color: var(--color-positive);">+${formatCurrency(dailyIncrement)}</td>`;
                    tableHTML += `<td>${formatCurrency(cumulativePlanPerSubOp[op])}</td>`;
                });

                cumulativeTotalPlan += dailyTotalIncrement;
                tableHTML += `<td style="font-weight:bold; color: var(--color-positive);">+${formatCurrency(dailyTotalIncrement)}</td>`;
                tableHTML += `<td style="font-weight:bold;">${formatCurrency(cumulativeTotalPlan)}</td>`;
                tableHTML += `</tr>`;
            }

            tableHTML += `</tbody></table>`;
            container.innerHTML = tableHTML;
        }

        // 5. SUBSTITUA ESTA FUNÇÃO (para incluir o listener do planner)
        function setupEventListeners() {
          // --- Controle da Sidebar (Minimizar/Expandir) ---
          const sidebarToggleBtn = document.getElementById('sidebar-toggle');
          if (sidebarToggleBtn) {
              sidebarToggleBtn.addEventListener('click', () => {
                  document.body.classList.toggle('sidebar-minimized');
                  localStorage.setItem('sidebarState', document.body.classList.contains('sidebar-minimized') ? 'minimized' : 'expanded');
                  setTimeout(() => Object.values(charts).forEach(chart => chart && chart.resize()), 350); // Delay menor pode ser suficiente
              });
          }
          if (localStorage.getItem('sidebarState') === 'minimized') {
              document.body.classList.add('sidebar-minimized');
          }

          // --- Controle da Navegação Principal e Submenus ---
          const sidebarMenu = document.querySelector('.sidebar-menu');
          const viewSections = document.querySelectorAll('.view-section');
          const mainTitle = document.getElementById('main-title');
          const allNavButtons = document.querySelectorAll('.sidebar-nav .nav-btn');
          let comparisonFiltersPopulated = false; // Flag ainda útil

          if (!sidebarMenu) return;

          sidebarMenu.addEventListener('click', (event) => {
              const button = event.target.closest('.nav-btn');
              if (!button) return;

              const targetId = button.dataset.target;
              const parentViewId = button.dataset.parentView || targetId;
              const tooltip = button.dataset.tooltip;

              if (!targetId || !parentViewId) return;

              // --- 1. Atualiza Botões ---
              allNavButtons.forEach(btn => btn.classList.remove('active'));
              button.classList.add('active');
              if (button.dataset.parentView) {
                  const parentButton = sidebarMenu.querySelector(`.nav-btn[data-target="${parentViewId}"]`);
                  if (parentButton) parentButton.classList.add('active');
              }

              // --- 2. Atualiza Seções Principais e Sub-views ---
              viewSections.forEach(section => {
                  const shouldSectionBeActive = section.id === parentViewId;
                  section.classList.toggle('active', shouldSectionBeActive);

                  if (shouldSectionBeActive) {
                      const subViews = section.querySelectorAll('.operacoes-sub-view');
                      if (subViews.length > 0) {
                          subViews.forEach(subView => {
                              const shouldSubViewBeActive = subView.id === targetId;
                              subView.classList.toggle('active', shouldSubViewBeActive);

                              // Tenta popular filtros SEMPRE que a subview for ativada,
                              // mas a função interna pode decidir não fazer nada se já feito.
                              if (subView.id === 'operacoes-sub-comparacao' && shouldSubViewBeActive) {
                                  // Adiciona log para saber se está tentando popular
                                  console.log("Tentando popular filtros de comparação...");
                                  // Chama a função que agora pode ter a flag interna ou verificar se já tem opções
                                  populateComparisonFilters();
                              }
                          });
                      }
                  } else {
                       section.querySelectorAll('.operacoes-sub-view').forEach(sv => sv.classList.remove('active'));
                  }
              });

              // --- 3. Atualiza Título ---
              if (mainTitle && tooltip) {
                  mainTitle.textContent = tooltip;
              }

              // --- 4. Redimensiona Gráficos ---
              setTimeout(() => {
                  const activeMainView = document.querySelector('.view-section.active');
                  if (activeMainView) {
                      const activeSubView = activeMainView.querySelector('.operacoes-sub-view.active');
                      const containerToScan = activeSubView || activeMainView;
                      containerToScan.querySelectorAll('canvas').forEach(canvas => {
                          const chartInstance = charts[canvas.id];
                          if (chartInstance && typeof chartInstance.resize === 'function') {
                               try { chartInstance.resize(); } catch (e) { console.warn("Erro resize:", canvas.id, e); }
                          }
                      });
                  }
              }, 50);
          });

          // --- Mantém as outras lógicas ---
          document.querySelectorAll('#metric-toggle .toggle-btn').forEach(btn => { /* ...código mantido... */ });
          const plannerButton = document.getElementById('plannerCalculateBtn');
          if (plannerButton) { plannerButton.addEventListener('click', runGoalPlanner); }

          // Inicializa o estado visual
          const initialActiveButton = sidebarMenu.querySelector('.nav-btn.active');
          if (initialActiveButton) {
              // Atraso leve para garantir que os dados iniciais tenham chance de carregar antes do primeiro clique simulado
              setTimeout(() => {
                   initialActiveButton.click();
              }, 100);
          }
      }
      /**
         * Popula os filtros da aba de comparação (País).
         */
         /**
         * Popula os filtros da aba de comparação (País).
         */
        function populateComparisonFilters() {
            const countrySelect = document.getElementById('compare-country-select');
            if (!countrySelect) {
                 console.error("Select 'compare-country-select' não encontrado.");
                 return;
            }

            // Verifica se já foi populado para evitar trabalho repetido
            if (countrySelect.options.length > 1 && countrySelect.options[1]?.value) { // Verifica se há mais que o placeholder
                 console.log("Filtros de país já populados. Pulando.");
                 return;
            }
             console.log("Iniciando população dos filtros de país...");


            // Usa rawData para garantir que temos todos os nomes de conta possíveis ANTES da filtragem por data
            const combinedRawData = [...rawDataJn, ...rawDataMg, ...rawDataGrid];

            if (combinedRawData.length === 0) {
                console.warn("Não há dados detalhados (Jn, Mg, Grid) carregados INICIALMENTE para extrair países.");
                countrySelect.innerHTML = '<option value="">-- Sem Dados --</option>';
                return;
            }
            console.log(`Total de ${combinedRawData.length} linhas de dados detalhados (raw) encontradas.`);


            // Usa getOperationKeyFromAccountName para extrair chaves de operação
            const operationKeys = new Set();
            combinedRawData.forEach(row => {
                 // Adiciona um log para cada nome de conta sendo processado
                 // console.log(`Processando conta: ${row.accountName}`);
                 const opKey = getOperationKeyFromAccountName(row.accountName);
                 if (opKey && !opKey.startsWith('Desconhecida') && !opKey.startsWith('Outros')) {
                      operationKeys.add(opKey);
                 }
            });

             console.log("Chaves de Operação únicas encontradas:", [...operationKeys]);


             // Extrai países (segunda parte da chave, com 2 letras) das chaves das operações
             const countries = new Set();
             operationKeys.forEach(opKey => {
                 const parts = opKey.split(' ');
                 // Verifica se a segunda parte existe, tem 2 letras e é Maiúscula
                 if (parts.length >= 2 && parts[1].length === 2 && /^[A-Z]{2}$/.test(parts[1])) {
                     console.log(`País encontrado: ${parts[1]} (da chave: ${opKey})`); // Log país encontrado
                     countries.add(parts[1]);
                 } else {
                      console.log(`Chave de operação "${opKey}" não tem formato de país esperado (ex: JN US CC).`);
                 }
             });

             console.log("Países ÚNICOS extraídos:", [...countries]);

            // Popula o select
            countrySelect.innerHTML = '<option value="">-- País --</option>'; // Limpa e adiciona placeholder
            if (countries.size > 0) {
                 [...countries].sort().forEach(countryCode => {
                     countrySelect.innerHTML += `<option value="${countryCode}">${countryCode}</option>`;
                 });
                 console.log("Dropdown de países populado com sucesso.");
            } else {
                 console.warn("Nenhum código de país válido (ex: US, BR, DE) foi encontrado nas chaves de operação extraídas.");
                 countrySelect.innerHTML = '<option value="">-- Nenhum País --</option>';
            }
        }
        function processGridData() { // Chamada se necessário no futuro
            populateGridAccountFilter();
        }
        function populateGridAccountFilter() {
            const select = document.getElementById('gridAccountFilter');
            // Muda a fonte dos dados
            if (!select || rawDataGrid.length === 0) return;
            // Muda a fonte dos dados
            const accounts = [...new Set(rawDataGrid.map(r => r.accountName))].sort();
            select.innerHTML = '<option value="">Selecione uma conta...</option>';
            accounts.forEach(acc => {
                select.innerHTML += `<option value="${acc}">${acc}</option>`;
            });
        }
        function toggleGridViewMode(mode) {
            const singleControls = document.getElementById('grid-single-view-controls');
            const compareControls = document.getElementById('grid-compare-view-controls');
            if (mode === 'single') {
                singleControls.style.display = 'flex';
                compareControls.style.display = 'none';
                clearGridComparison(); // Limpa a comparação ao voltar para visão única
            } else { // modo 'compare'
                singleControls.style.display = 'none';
                compareControls.style.display = 'flex';
                document.getElementById('gridAccountFilter').value = ''; // Limpa seleção única
                renderGridAnalysisView(); // Re-renderiza para limpar o gráfico se necessário
            }
        }
        function handleGridAccountSearch() {
            const searchTerm = document.getElementById('gridAccountSearch').value.toLowerCase();
            const resultsContainer = document.getElementById('gridSearchResults');
            if (!searchTerm) {
                resultsContainer.innerHTML = '';
                return;
            }
            // Muda a fonte dos dados
            const allAccounts = [...new Set(rawDataGrid.map(r => r.accountName))].sort();
            // Muda a variável de comparação
            const filteredAccounts = allAccounts.filter(acc =>
                acc.toLowerCase().includes(searchTerm) && !gridComparedAccounts.includes(acc)
            );

            resultsContainer.innerHTML = filteredAccounts.map(acc =>
                // Muda a função chamada no onclick
                `<div class="search-result-item" onclick="addGridAccountToComparison('${acc.replace(/'/g, "\\'")}')">${acc}</div>`
            ).join('');
        }

        function addGridAccountToComparison(accountName) {
            // Muda a variável de comparação
            if (!gridComparedAccounts.includes(accountName)) {
                gridComparedAccounts.push(accountName);
                renderGridSelectedAccounts(); // Muda a função chamada
                renderGridAnalysisView();     // Muda a função chamada
            }
            document.getElementById('gridAccountSearch').value = '';
            document.getElementById('gridSearchResults').innerHTML = '';
        }

        function removeGridAccountFromComparison(accountName) {
            // Muda a variável de comparação
            gridComparedAccounts = gridComparedAccounts.filter(acc => acc !== accountName);
            renderGridSelectedAccounts(); // Muda a função chamada
            renderGridAnalysisView();     // Muda a função chamada
        }

        function renderGridSelectedAccounts() {
            const container = document.getElementById('gridSelectedAccounts');
            // Muda a variável de comparação e a função no onclick
            container.innerHTML = gridComparedAccounts.map((acc, index) =>
                `<span class="account-pill" style="background-color: ${FANCY_COLORS[index % FANCY_COLORS.length]}">
                    ${acc}
                    <span class="remove-pill" onclick="removeGridAccountFromComparison('${acc.replace(/'/g, "\\'")}')">&times;</span>
                </span>`
            ).join('');
        }

        function clearGridComparison() {
            gridComparedAccounts = []; // Muda a variável
            renderGridSelectedAccounts(); // Muda a função
            renderGridAnalysisView();     // Muda a função
        }

        function renderGridAnalysisView() {
            renderGridEvolutionChart(); // Muda a função

            const mode = document.querySelector('input[name="grid-view-mode"]:checked').value;
            let accountsForTable = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('gridAccountFilter').value;
                if (selectedAccount) {
                    accountsForTable.push(selectedAccount);
                }
            } else {
                accountsForTable = [...gridComparedAccounts]; // Muda a variável
            }

            let aggregatedData = [];
            if (accountsForTable.length > 0) {
                // Muda a fonte dos dados
                const dataToAggregate = filteredDataGrid.filter(r => accountsForTable.includes(r.accountName));

                const dailySums = dataToAggregate.reduce((acc, row) => {
                    if (!acc[row.day]) {
                        acc[row.day] = { day: row.day, spend: 0, impressions: 0, clicks: 0, conversions: 0 };
                    }
                    acc[row.day].spend += row.spend;
                    acc[row.day].impressions += row.impressions;
                    acc[row.day].clicks += row.clicks;
                    acc[row.day].conversions += row.conversions;
                    return acc;
                }, {});

                aggregatedData = Object.values(dailySums).map(day => ({
                    day: day.day,
                    spend: day.spend,
                    impressions: day.impressions,
                    clicks: day.clicks,
                    conversions: day.conversions,
                    ctr: day.impressions > 0 ? (day.clicks / day.impressions) * 100 : 0,
                    convRate: day.clicks > 0 ? (day.conversions / day.clicks) * 100 : 0,
                    cpa: day.conversions > 0 ? day.spend / day.conversions : 0,
                    cpm: day.impressions > 0 ? (day.spend / day.impressions) * 1000 : 0,
                    cpc: day.clicks > 0 ? day.spend / day.clicks : 0
                }));
            }

            // Muda o ID do elemento e a função de renderização/ordenação
            _renderAndAttachSortListenersForGridTable('grid-daily-table', aggregatedData, accountsForTable);
            // Muda o ID do container e a fonte dos dados para o funil
            renderAccountFunnel('grid-funnel-container', filteredDataGrid, mode === 'single' ? accountsForTable[0] : null);
        }

        function _renderAndAttachSortListenersForGridTable(elementId, data, accounts) {
            const container = document.getElementById(elementId);
            if (!container) return;

             if (!data || data.length === 0) {
                 container.innerHTML = (accounts && accounts.length > 0) ?
                     '<p style="padding: 20px; text-align: center;">Nenhum dado encontrado para a(s) conta(s) no período selecionado.</p>' :
                     '<p style="padding: 20px; text-align: center;">Selecione uma ou mais contas para ver os dados diários agregados.</p>';
                 return;
             }

            // Muda o estado de ordenação
            const currentSort = gridTableSortState[elementId] || { key: 'day', order: 'desc' }; // Default sort by day desc
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };

            // Ordena os dados ANTES de renderizar
            const sortedData = [...data].sort((a, b) => {
                const valA = currentSort.key === 'day' ? new Date(a[currentSort.key]) : a[currentSort.key];
                const valB = currentSort.key === 'day' ? new Date(b[currentSort.key]) : b[currentSort.key];
                // Tratamento para string (dia) vs número
                if (typeof valA === 'string' || valA instanceof Date) { // Trata datas corretamente
                     const dateA = new Date(valA);
                     const dateB = new Date(valB);
                     return currentSort.order === 'asc' ? dateA - dateB : dateB - dateA;
                } else {
                     return currentSort.order === 'asc' ? valA - valB : valB - valA;
                }
            });


            const currencyReferenceAccount = accounts.length > 0 ? accounts[0] : ''; // Para formatCurrency

            const headers = [
                { key: 'day', label: 'Dia' }, { key: 'spend', label: 'Gasto' }, { key: 'impressions', label: 'Impressões' },
                { key: 'clicks', label: 'Cliques' }, { key: 'ctr', label: 'CTR' }, { key: 'conversions', label: 'Conversões' },
                { key: 'convRate', label: 'Tx. Conv.' }, { key: 'cpa', label: 'CPA' }, { key: 'cpm', label: 'CPM' },
                { key: 'cpc', label: 'CPC' }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedData.forEach(row => { // Usa sortedData aqui
                tableHtml += `<tr>
                    <td>${formatDate(new Date(row.day + 'T00:00:00Z'))}</td>
                    <td>${formatCurrency(row.spend, currencyReferenceAccount)}</td>
                    <td>${row.impressions.toLocaleString('pt-BR')}</td>
                    <td>${row.clicks.toLocaleString('pt-BR')}</td>
                    <td>${(row.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${row.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                    <td>${(row.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${formatCurrency(row.cpa, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpm, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpc, currencyReferenceAccount)}</td>
                </tr>`;
            });
            tableHtml += `</tbody>`;

            // Cálculo dos totais/médias (igual ao JN)
             const totals = data.reduce((acc, row) => {
                acc.spend += row.spend;
                acc.impressions += row.impressions;
                acc.clicks += row.clicks;
                acc.conversions += row.conversions;
                return acc;
            }, { spend: 0, impressions: 0, clicks: 0, conversions: 0 });

            const weightedAvg = {
                ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
                convRate: totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0,
                cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0,
                cpm: totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0,
                cpc: totals.clicks > 0 ? totals.spend / totals.clicks : 0,
            };

            tableHtml += `<tfoot><tr>
                <td>Total / Média</td>
                <td>${formatCurrency(totals.spend, currencyReferenceAccount)}</td>
                <td>${totals.impressions.toLocaleString('pt-BR')}</td>
                <td>${totals.clicks.toLocaleString('pt-BR')}</td>
                <td>${(weightedAvg.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${totals.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                <td>${(weightedAvg.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${formatCurrency(weightedAvg.cpa, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpm, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpc, currencyReferenceAccount)}</td>
            </tr></tfoot></table>`;


            container.innerHTML = tableHtml;

            // Adiciona listeners de ordenação
            container.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const sortKey = th.dataset.sort;
                    // Muda o estado de ordenação
                    const currentState = gridTableSortState[elementId] || {};
                    // Define a ordem padrão (asc para dia, cpa; desc para outros)
                    let defaultOrder = (sortKey === 'day' || sortKey === 'cpa' || sortKey === 'cpm' || sortKey === 'cpc') ? 'asc' : 'desc';
                    const nextOrder = (currentState.key === sortKey && currentState.order === defaultOrder) ? (defaultOrder === 'asc' ? 'desc' : 'asc') : defaultOrder;

                    gridTableSortState[elementId] = { key: sortKey, order: nextOrder };
                    // Re-renderiza a tabela com os dados ordenados
                    _renderAndAttachSortListenersForGridTable(elementId, data, accounts);
                });
            });
        }


        function renderGridEvolutionChart() {
            const canvasId = 'gridEvolutionChart'; // Muda o ID
            const mode = document.querySelector('input[name="grid-view-mode"]:checked').value; // Muda o name do radio

            let accountsToRender = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('gridAccountFilter').value; // Muda o ID
                if (selectedAccount) accountsToRender.push(selectedAccount);
            } else {
                accountsToRender = [...gridComparedAccounts]; // Muda a variável
            }

            // Currency mismatch warning
            const warningDiv = document.getElementById('grid-currency-warning'); // Muda o ID
            if (mode === 'compare' && accountsToRender.length > 1) {
                const currencies = new Set(accountsToRender.map(acc => {
                    // Adapte esta lógica se a nomenclatura das contas GRID for diferente
                    if (acc.toUpperCase().includes('USD')) return 'USD';
                    if (acc.toUpperCase().includes('BRL')) return 'BRL';
                    return 'Outra';
                }));
                if (currencies.size > 1) {
                    warningDiv.innerHTML = `⚠️ <strong>Atenção:</strong> Você está comparando contas com moedas diferentes (${[...currencies].join(', ')}). Os valores nos eixos monetários podem não ser diretamente comparáveis.`;
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } else {
                warningDiv.style.display = 'none';
            }

            // Placeholder se nenhuma conta for selecionada
            if (accountsToRender.length === 0) {
                if (charts[canvasId]) charts[canvasId].destroy();
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#6c757d";
                    ctx.fillText("Selecione uma ou mais contas para visualizar o gráfico.", canvas.width / 2, canvas.height / 2 - 20);
                }
                return;
            }

            // Métricas selecionadas
            const selectedMetrics = Array.from(document.querySelectorAll('#grid-metric-checkbox-group input:checked')).map(cb => cb.value); // Muda o ID
            const allDatasets = [];
            const allDates = new Set();

            // Encontra todas as datas únicas para as contas selecionadas
            accountsToRender.forEach(accountName => {
                // Muda a fonte dos dados
                filteredDataGrid.filter(r => r.accountName === accountName).forEach(r => allDates.add(r.day));
            });
            const sortedLabelsFull = [...allDates].sort((a, b) => new Date(a) - new Date(b));
            const sortedLabels = sortedLabelsFull.map(d => formatDate(new Date(d + 'T00:00:00Z'), true)); // Formato DD/MM

            // Cria os datasets para cada conta e métrica selecionada
            accountsToRender.forEach((accountName, index) => {
                // Muda a fonte dos dados
                const accountData = filteredDataGrid.filter(r => r.accountName === accountName);
                const color = FANCY_COLORS[index % FANCY_COLORS.length];

                const mapDataToLabels = (metric) => {
                    const dataMap = new Map(accountData.map(r => [r.day, r[metric]]));
                    return sortedLabelsFull.map(date => dataMap.get(date) ?? null);
                };

                // Adiciona datasets com base nas métricas selecionadas
                if (selectedMetrics.includes('gasto')) { allDatasets.push({ label: mode === 'single' ? `Gasto` : `Gasto - ${accountName}`, data: mapDataToLabels('spend'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.spend : color, tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpm')) { allDatasets.push({ label: mode === 'single' ? `CPM` : `CPM - ${accountName}`, data: mapDataToLabels('cpm'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.cpm : color, borderDash: [2, 2], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpa')) { allDatasets.push({ label: mode === 'single' ? `CPA` : `CPA - ${accountName}`, data: mapDataToLabels('cpa'), yAxisID: 'y2', borderColor: mode === 'single' ? METRIC_COLORS.cpa : color, borderDash: [5, 5], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('ctr')) { allDatasets.push({ label: mode === 'single' ? `CTR` : `CTR - ${accountName}`, data: mapDataToLabels('ctr'), yAxisID: 'y1', borderColor: mode === 'single' ? METRIC_COLORS.ctr : color, tension: 0.4, backgroundColor: 'transparent' }); }
            });

            // Opções do gráfico (iguais às do JN)
            const options = {
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: { display: selectedMetrics.some(m => ['gasto', 'cpm'].includes(m)), position: 'left', title: { display: true, text: `Gasto / CPM` }, ticks: { callback: (v) => formatCurrency(v, accountsToRender[0] || '') } }, // Usa a primeira conta como referência de moeda
                    y1: { display: selectedMetrics.includes('ctr'), position: 'right', title: { display: true, text: 'CTR (%)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) + '%' } },
                    y2: { display: selectedMetrics.includes('cpa'), position: 'right', title: { display: true, text: `CPA` }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => formatCurrency(v, accountsToRender[0] || '') } } // Usa a primeira conta como referência de moeda
                }
            };

            createOrUpdateChart(canvasId, 'line', { labels: sortedLabels, datasets: allDatasets }, options);
        }

        function initializeDashboard() {
            buildOperationalGoals();
            populateJnAccountFilter();
            populateMgAccountFilter();
            populateGridAccountFilter(); // <-- ADICIONADO
            const allTotalData = rawData.filter(r => endsWithTOTAL(r.operacao));
            populatePlannerOperationFilter(rawData);
            populateEvolutionFilters(allTotalData);
            populateCompanyCheckboxes();
            populateCorrelationFilters(); // ADICIONE ESTA LINHA
            populateManagerFilter(rawData); // Popula o seletor de gestores
            populateAdopsFilter(rawData); // <== ADICIONE ESTA LINHA
            populateCoordinationFilter(rawData);
            populateComparisonFilters();
            filterAndRenderAll();
        }

        function filterAndRenderAll() {
            const dateStartStr = document.getElementById('dateFilterStart').value;
            const dateEndStr = document.getElementById('dateFilterEnd').value;

            // Filtro para rawData -> filteredData
            let dateStartForMain = null, dateEndForMain = null;
            if (dateStartStr) { dateStartForMain = new Date(Date.UTC(...dateStartStr.split('-').map((n, i) => i === 1 ? n - 1 : n))); }
            if (dateEndStr) { dateEndForMain = new Date(Date.UTC(...dateEndStr.split('-').map((n, i) => i === 1 ? n - 1 : n))); dateEndForMain.setUTCHours(23, 59, 59, 999); }
            filteredData = rawData.filter(row => {
                const rowDate = parseDate(row.data);
                if (dateStartForMain && (!rowDate || rowDate < dateStartForMain)) return false;
                if (dateEndForMain && (!rowDate || rowDate > dateEndForMain)) return false;
                return true;
            });

            // Filtro para dados detalhados (JN, MG, GRID)
            let dateStartForDetail = null, dateEndForDetail = null;
            if (dateStartStr) { dateStartForDetail = new Date(dateStartStr + 'T00:00:00Z'); }
            if (dateEndStr) { dateEndForDetail = new Date(dateEndStr + 'T23:59:59Z'); }

            const filterDetailData = (rawDataArray) => {
                 return rawDataArray.filter(row => {
                    if (!row.day) return false;
                    try {
                        const rowDate = new Date(row.day + 'T00:00:00Z');
                        if (dateStartForDetail && rowDate < dateStartForDetail) return false;
                        if (dateEndForDetail && rowDate > dateEndForDetail) return false;
                    } catch (e) { return false; }
                    return true;
                });
            }

            filteredDataJn = filterDetailData(rawDataJn);
            filteredDataMg = filterDetailData(rawDataMg);
            filteredDataGrid = filterDetailData(rawDataGrid);

            updateDashboard(); // Renderiza partes gerais que usam filteredData
            renderJnAnalysisView(); // Renderiza view JN (usa filteredDataJn)
            renderMgAnalysisView(); // Renderiza view MG (usa filteredDataMg)
            renderGridAnalysisView(); // Renderiza view GRID (usa filteredDataGrid)
            renderAggregatedFunnel(); // <-- ADICIONADO (usa filteredDataJn, Mg, Grid)
            // Certifique-se que renderOperationalView usa filteredData (já deve estar correto)
            renderOperationalView();
        }

        function clearFilters() {
            document.getElementById('dateFilterStart').value = '';
            document.getElementById('dateFilterEnd').value = '';
            filterAndRenderAll();
        }

        function updateDashboard() {
            const hasData = filteredData.length > 0;
            document.getElementById('mainContent').style.display = hasData ? 'block' : 'none';
            if (hasData) {
                const dataNoTotal = filteredData.filter(r => !endsWithTOTAL(r.operacao));
                const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao));
                updateSummaryCards(dataOnlyTotal);
                updateRegionalSummaryCards(dataOnlyTotal);
                updateDailyComparison(dataOnlyTotal);
                updateProjectionCards(dataOnlyTotal);
                updateCharts(dataNoTotal, dataOnlyTotal);
            }
        }

        function updateCharts(dataNoTotal, dataOnlyTotal) {
            updateEvolutionChartWithFilters();
            renderOperationalView();
            updateProportionCharts();
            renderNicheComparisonCharts(dataOnlyTotal, document.querySelector('#metric-toggle .toggle-btn.active').dataset.metric); // Correção aqui
            renderManagerCharts(dataNoTotal);


            renderCoordinationView(filteredData);
            renderManagerEvolutionChart(dataNoTotal); // Renderiza o novo gráfico de evolução

            renderAdopsCharts(dataOnlyTotal);
            renderAdopsEvolutionChart(dataOnlyTotal); // <== ADICIONE ESTA LINHA
            renderBusinessSegmentTables(dataOnlyTotal);
            renderCompanyView(dataOnlyTotal);
            renderMetasView(dataOnlyTotal, filteredData);
            renderAdvancedForecastChart();
        }

        // --- Funções do Dashboard Principal ---
        function updateEvolutionChartWithFilters() {
            const selectedRegions = Array.from(document.querySelectorAll('#region-checkbox-group input:checked')).map(cb => cb.value);
            const operationFilter = document.getElementById('evolutionOperationFilter');
            const selectedOperation = operationFilter.value;
            const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao));
            const baseData = selectedOperation === 'all' ? dataOnlyTotal : dataOnlyTotal.filter(r => r.operacao === selectedOperation);

            operationFilter.disabled = selectedRegions.length > 1 && !selectedRegions.includes('all');

            const datasetsToRender = [];
            const allDates = new Set();

            selectedRegions.forEach(regionKey => {
                let regionData;
                let regionLabel;
                if (regionKey === 'all') {
                    regionData = baseData;
                    regionLabel = 'Todas';
                } else {
                    regionLabel = regionKey.toUpperCase();
                    regionData = baseData.filter(row => {
                        const op = row.operacao.toUpperCase();
                        if (regionKey === 'br') return op.includes('BR');
                        if (regionKey === 'us') return op.includes('US');
                        if (regionKey === 'eu') return ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p));
                        return false;
                    });
                }

                if (regionData && regionData.length > 0) {
                    const dailyData = {};
                    regionData.forEach(row => {
                        if (row.data) {
                            if (!dailyData[row.data]) dailyData[row.data] = { gasto: 0, receita: 0, leads: 0 };
                            dailyData[row.data].gasto += row.gasto;
                            dailyData[row.data].receita += row.receita;
                            dailyData[row.data].leads += row.leads;
                            allDates.add(row.data);
                        }
                    });
                    datasetsToRender.push({ key: regionKey, label: regionLabel, data: dailyData });
                }
            });

            const sortedLabels = Array.from(allDates).sort((a, b) => parseDate(a) - parseDate(b));
            const finalChartJsDatasets = [];

            datasetsToRender.forEach(dataset => {
                const investmentColor = REGION_COLORS[dataset.key]?.investment || '#cccccc';
                const roasColor = REGION_COLORS[dataset.key]?.roas || '#aaaaaa';
                const leadsColor = REGION_COLORS[dataset.key]?.leads || '#888888';
                const cpaColor = '#2ecc71'; // Cor verde definida para CPA

                const gastoData = sortedLabels.map(date => dataset.data[date]?.gasto ?? null);
                const roasData = sortedLabels.map(date => {
                    const dayData = dataset.data[date];
                    return (dayData && dayData.gasto > 0) ? (dayData.receita / dayData.gasto) : null;
                });
                const leadsData = sortedLabels.map(date => dataset.data[date]?.leads ?? null);

                // --- INÍCIO: Cálculo CPA Adicionado ---
                const cpaData = sortedLabels.map(date => {
                    const dayData = dataset.data[date];
                    return (dayData && dayData.leads > 0) ? (dayData.gasto / dayData.leads) : null;
                });
                // --- FIM: Cálculo CPA Adicionado ---

                finalChartJsDatasets.push({
                    label: `Investimento (${dataset.label})`,
                    data: gastoData,
                    yAxisID: 'y',
                    borderColor: investmentColor,
                    backgroundColor: hexToRgba(investmentColor, 0.1),
                    fill: datasetsToRender.length === 1,
                    tension: 0.4
                });
                finalChartJsDatasets.push({
                    label: `ROAS (${dataset.label})`,
                    data: roasData,
                    yAxisID: 'y1',
                    borderColor: roasColor,
                    backgroundColor: 'transparent',
                    borderDash: [5, 5],
                    tension: 0.4,
                    fill: false
                });
                finalChartJsDatasets.push({
                    label: `Leads (${dataset.label})`,
                    data: leadsData,
                    yAxisID: 'y2',
                    borderColor: leadsColor,
                    backgroundColor: 'transparent',
                    borderDash: [2, 2],
                    tension: 0.4,
                    fill: false
                });
                // --- INÍCIO: Dataset CPA Adicionado ---
                finalChartJsDatasets.push({
                    label: `CPA (${dataset.label})`,
                    data: cpaData,
                    yAxisID: 'y3', // Novo eixo ID
                    borderColor: cpaColor, // Cor verde
                    backgroundColor: 'transparent',
                    borderDash: [1, 4], // Estilo diferente de tracejado
                    tension: 0.4,
                    fill: false
                });
                // --- FIM: Dataset CPA Adicionado ---
            });

            createOrUpdateChart('evolucaoCompletaChart', 'line', {
                labels: sortedLabels,
                datasets: finalChartJsDatasets
            }, {
                scales: {
                    y: { // Eixo do Investimento (Esquerda)
                        title: { display: true, text: 'Valores (R$)' },
                        ticks: { callback: (v) => formatKilo(v) }
                    },
                    y1: { // Eixo do ROAS (Direita 1)
                        position: 'right',
                        title: { display: true, text: 'ROAS (x)' },
                        grid: { drawOnChartArea: false },
                        ticks: { callback: (v) => v.toFixed(2) }
                    },
                    y2: { // Eixo dos Leads (Direita 2)
                        position: 'right',
                        title: { display: true, text: 'Leads' },
                        grid: { drawOnChartArea: false },
                        ticks: { callback: (v) => v.toLocaleString('pt-BR') }
                        // Pode precisar ajustar o padding ou afterFit se os títulos sobrepuserem
                        // afterFit: (scale) => { scale.width = 65; }
                    },
                    // --- INÍCIO: Eixo Y CPA Adicionado (Direita 3) ---
                    y3: {
                        position: 'right',
                        title: { display: true, text: 'CPA (R$)' },
                        grid: { drawOnChartArea: false },
                        ticks: {
                            callback: (v) => formatCurrency(v),
                            padding: 5 // Espaçamento para evitar sobreposição
                        }
                        // Pode precisar ajustar o padding ou afterFit se os títulos sobrepuserem
                        // afterFit: (scale) => { scale.width = 75; }
                    }
                    // --- FIM: Eixo Y CPA Adicionado ---
                }
            });
        }
        function handleRegionSelection(checkbox) { const allCheckbox = document.getElementById('region-all'); const regionCheckboxes = document.querySelectorAll('#region-checkbox-group input:not(#region-all)'); if (checkbox.id === 'region-all' && checkbox.checked) { regionCheckboxes.forEach(cb => cb.checked = false); } else if (checkbox.id !== 'region-all') { if (Array.from(regionCheckboxes).some(cb => cb.checked)) { allCheckbox.checked = false; } } if (!document.querySelector('#region-checkbox-group input:checked')) { allCheckbox.checked = true; } updateEvolutionChartWithFilters(); }
        function updateSummaryCards(data) { const totalGasto = data.reduce((s, r) => s + r.gasto, 0); const totalReceita = data.reduce((s, r) => s + r.receita, 0); const totalLeads = data.reduce((s, r) => s + r.leads, 0); const roasMedio = totalGasto > 0 ? (totalReceita / totalGasto) : 0; const cpaMedio = totalLeads > 0 ? (totalGasto / totalLeads) : 0; const roasDiffFrom1 = (roasMedio - 1) * 100; document.getElementById('summaryCards').innerHTML = createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(totalGasto), footerHTML: `<div class="secondary-metrics"><div class="metric-item"><span class="metric-label">Total de Leads</span><span class="metric-value">${totalLeads.toLocaleString('pt-BR')}</span></div><div class="metric-item"><span class="metric-label">CPA Médio</span><span class="metric-value">${formatCurrency(cpaMedio)}</span></div></div>` }) + createCardHTML({ icon: '📈', title: 'Receita Total', value: formatCurrency(totalReceita) }) + createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roasMedio.toFixed(2)}x`, delta: roasDiffFrom1, deltaPositiveOverride: roasDiffFrom1 >= 0 }); }
        function updateRegionalSummaryCards(data) { const regions = [{ key: 'br', containerId: 'summaryCardsBr', filter: (op) => op.includes('BR') }, { key: 'us', containerId: 'summaryCardsUs', filter: (op) => op.includes('US') }, { key: 'eu', containerId: 'summaryCardsEu', filter: (op) => ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p)) }]; regions.forEach(region => { const regionalData = data.filter(row => region.filter(row.operacao.toUpperCase())); const totalGasto = regionalData.reduce((s, r) => s + r.gasto, 0); const totalReceita = regionalData.reduce((s, r) => s + r.receita, 0); const totalLeads = regionalData.reduce((s, r) => s + r.leads, 0); const roasMedio = totalGasto > 0 ? (totalReceita / totalGasto) : 0; const cpaMedio = totalLeads > 0 ? (totalGasto / totalLeads) : 0; const roasDiffFrom1 = (roasMedio - 1) * 100; const container = document.getElementById(region.containerId); if (container) { if (totalGasto > 0) { container.parentElement.style.display = 'block'; container.innerHTML = createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(totalGasto), footerHTML: `<div class="secondary-metrics"><div class="metric-item"><span class="metric-label">Total de Leads</span><span class="metric-value">${totalLeads.toLocaleString('pt-BR')}</span></div><div class="metric-item"><span class="metric-label">CPA Médio</span><span class="metric-value">${formatCurrency(cpaMedio)}</span></div></div>` }) + createCardHTML({ icon: '📈', title: 'Receita Total', value: formatCurrency(totalReceita) }) + createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roasMedio.toFixed(2)}x`, delta: roasDiffFrom1, deltaPositiveOverride: roasDiffFrom1 >= 0 }); } else { container.parentElement.style.display = 'none'; } } }); }
        function updateDailyComparison(data) { const allDates = [...new Set(data.map(r => r.data))].map(d => parseDate(d)).sort((a, b) => b - a); if (allDates.length === 0) return; const d1 = allDates[0]; const findDate = (offset) => allDates.find(d => (d1 - d) / (1000 * 60 * 60 * 24) === offset); const dates = { d1: d1, d2: findDate(1), d4: findDate(3), d8: findDate(7) }; const getMetricsForDate = (targetDate, dataset) => { if (!targetDate) return { gasto: 0, receita: 0, leads: 0, roas: 0, cpa: 0, date: null }; const dateStr = formatDate(targetDate); const dataForDate = dataset.filter(r => r.data === dateStr); const gasto = dataForDate.reduce((s, r) => s + r.gasto, 0); const receita = dataForDate.reduce((s, r) => s + r.receita, 0); const leads = dataForDate.reduce((s, r) => s + r.leads, 0); return { gasto, receita, leads, roas: gasto > 0 ? receita / gasto : 0, cpa: leads > 0 ? gasto / leads : 0, date: dateStr }; }; const createComparisonTableHTML = (title, metrics) => { const calcDelta = (v1, v2) => { if (v2 === 0) return v1 > 0 ? Infinity : 0; return ((v1 / v2) - 1) * 100; }; const formatDelta = (delta) => { if (!isFinite(delta) || isNaN(delta)) return `<span class="delta-neutral">-</span>`; const cls = delta >= 0 ? 'delta-positive' : 'delta-negative'; const sign = delta > 0 ? '+' : ''; return `<span class="${cls}">${sign}${delta.toFixed(1)}%</span>`; }; let html = `<h3>${title}</h3><table class="comparison-table"><thead><tr> <th>Métrica</th> <th>Ontem (${metrics.d1.date || 'N/A'})</th> <th>D-2 (${metrics.d2.date || 'N/A'})</th><th>%</th> <th>D-4 (${metrics.d4.date || 'N/A'})</th><th>%</th> <th>D-8 (${metrics.d8.date || 'N/A'})</th><th>%</th> </tr></thead><tbody>`; const rows = [{ label: 'Investimento', format: (v) => formatCurrency(v), key: 'gasto' }, { label: 'Receita', format: (v) => formatCurrency(v), key: 'receita' }, { label: 'Leads', format: (v) => v.toLocaleString('pt-BR'), key: 'leads' }, { label: 'ROAS', format: (v) => `${v.toFixed(2)}x`, key: 'roas' }, { label: 'CPA', format: (v) => formatCurrency(v), key: 'cpa', inverse: true }]; rows.forEach(r => { const v1 = metrics.d1[r.key], v2 = metrics.d2[r.key], v4 = metrics.d4[r.key], v8 = metrics.d8[r.key]; let d2 = calcDelta(v1, v2), d4 = calcDelta(v1, v4), d8 = calcDelta(v1, v8); if (r.inverse) { d2 *= -1; d4 *= -1; d8 *= -1; } html += `<tr> <td>${r.label}</td> <td>${r.format(v1)}</td> <td>${r.format(v2)}</td><td>${formatDelta(d2)}</td> <td>${r.format(v4)}</td><td>${formatDelta(d4)}</td> <td>${r.format(v8)}</td><td>${formatDelta(d8)}</td> </tr>`; }); return html + '</tbody></table>'; }; const totalMetrics = { d1: getMetricsForDate(dates.d1, data), d2: getMetricsForDate(dates.d2, data), d4: getMetricsForDate(dates.d4, data), d8: getMetricsForDate(dates.d8, data) }; document.getElementById('dailyComparisonTotal').innerHTML = createComparisonTableHTML('📊 Comparativo Total', totalMetrics); const regions = [{ key: 'br', containerId: 'dailyComparisonBr', filter: (op) => op.includes('BR'), title: '🇧🇷 Brasil' }, { key: 'us', containerId: 'dailyComparisonUs', filter: (op) => op.includes('US'), title: '🇺🇸 Estados Unidos' }, { key: 'eu', containerId: 'dailyComparisonEu', filter: (op) => ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p)), title: '🇪🇺 Europa' }]; regions.forEach(region => { const regionalData = data.filter(row => region.filter(row.operacao.toUpperCase())); const regionalMetrics = { d1: getMetricsForDate(dates.d1, regionalData), d2: getMetricsForDate(dates.d2, regionalData), d4: getMetricsForDate(dates.d4, regionalData), d8: getMetricsForDate(dates.d8, regionalData) }; const container = document.getElementById(region.containerId); if (regionalMetrics.d1.gasto > 0 || regionalMetrics.d2.gasto > 0) { container.innerHTML = createComparisonTableHTML(region.title, regionalMetrics); container.style.display = 'block'; } else { container.style.display = 'none'; } }); }
        function updateProjectionCards(data) { const projectionContainer = document.getElementById('projectionCards'); projectionContainer.innerHTML = ''; const dates = [...new Set(data.map(r => r.data))].filter(Boolean); if (dates.length < 1) return; const lastDayOfMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0); const lastDateInData = parseDate(dates.sort((a, b) => parseDate(a) - parseDate(b)).pop()); const daysRemaining = Math.max(0, (lastDayOfMonth - lastDateInData) / (1000 * 60 * 60 * 24)); const totalGasto = data.reduce((s, r) => s + r.gasto, 0); const avgDailyGasto = totalGasto / dates.length; const projectedGasto = totalGasto + (avgDailyGasto * daysRemaining); const subtitle = `*Baseado na média de ${dates.length} dia(s) do período`; projectionContainer.innerHTML = createCardHTML({ icon: '🔮', title: 'Projeção de Gasto', value: formatCurrency(projectedGasto), isProjection: true, subtitle: subtitle }); }
        function createCardHTML(config) { const deltaClass = (config.deltaPositiveOverride !== undefined) ? (config.deltaPositiveOverride ? 'positive' : 'negative') : (config.delta > 0 ? 'positive' : 'negative'); const deltaHTML = config.delta ? `<span class="delta ${deltaClass}">${config.delta > 0 ? '▲' : '▼'} ${Math.abs(config.delta).toFixed(1)}%</span>` : ''; const subtitleHTML = config.subtitle ? `<div class="subtitle">${config.subtitle}</div>` : ''; const footerHTML = config.footerHTML ? config.footerHTML : ''; const valueClass = 'value'; return `<div class="card ${config.isProjection ? 'projection' : ''}"><div class="card-header"><h3>${config.icon} ${config.title}</h3>${deltaHTML}</div><div class="${valueClass}">${config.value}</div>${subtitleHTML}${footerHTML}</div>`; }
        function calculateChartHeight(numBars, minHeight = 250, barHeight = 40) { return Math.max(minHeight, numBars * barHeight + 100); }
        function updateProportionCharts() { const metric = document.querySelector('#metric-toggle .toggle-btn.active').dataset.metric; const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao)); renderRegionSummaryCharts(dataOnlyTotal, metric); renderPlatformSummaryCharts(dataOnlyTotal, metric); renderNicheComparisonCharts(dataOnlyTotal, metric); }
        function renderRegionSummaryCharts(data, metric = 'gasto') { const regionTotals = { europa: 0, brasil: 0, usa: 0 }; data.forEach(row => { const op = row.operacao.toUpperCase(); if (op.includes('BR')) regionTotals.brasil += row[metric]; else if (op.includes('US')) regionTotals.usa += row[metric]; else if (['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p))) regionTotals.europa += row[metric]; }); createOrUpdateChart('regionInvestmentPieChart', 'pie', { labels: ['Europa', 'Brasil', 'USA'], datasets: [{ data: [regionTotals.europa, regionTotals.brasil, regionTotals.usa], backgroundColor: ['#4169E1', '#009739', '#DC143C'] }] }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }); }
        function renderNicheComparisonCharts(data, metric = 'gasto') { const nicheSpending = { us_cc: 0, us_emp: 0, br_cc: 0, br_emp: 0 }; data.forEach(row => { const op = row.operacao.toUpperCase(); if (op.includes('US')) { if (op.includes('CC')) nicheSpending.us_cc += row[metric]; if (op.includes('EMP')) nicheSpending.us_emp += row[metric]; } else if (op.includes('BR')) { if (op.includes('CC')) nicheSpending.br_cc += row[metric]; if (op.includes('EMP')) nicheSpending.br_emp += row[metric]; } }); const pieOptions = { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }; createOrUpdateChart('nicheUsChart', 'pie', { labels: ['Cartão de Crédito', 'Empréstimo'], datasets: [{ data: [nicheSpending.us_cc, nicheSpending.us_emp], backgroundColor: ['#3498db', '#e67e22'] }] }, pieOptions); createOrUpdateChart('nicheBrChart', 'pie', { labels: ['Cartão de Crédito', 'Empréstimo'], datasets: [{ data: [nicheSpending.br_cc, nicheSpending.br_emp], backgroundColor: ['#2ecc71', '#f1c40f'] }] }, pieOptions); }
        function renderPlatformSummaryCharts(data, metric = 'gasto') { const platformData = { 'Meta Ads': 0, 'Google Ads': 0 }; data.forEach(row => { platformData[getPlatformFromOperation(row.operacao)] += row[metric]; }); createOrUpdateChart('platformInvestmentPieChart', 'pie', { labels: Object.keys(platformData), datasets: [{ data: Object.values(platformData), backgroundColor: ['#3b5998', '#4285F4'] }] }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }); }
        function renderManagerCharts(data) { const includedData = data.filter(row => row.responsavelAquisicao && !EXCLUDED_MANAGERS.includes(row.responsavelAquisicao.toUpperCase())); const managerSummary = {}; includedData.forEach(row => { const manager = row.responsavelAquisicao; if (!managerSummary[manager]) managerSummary[manager] = { gasto: 0, receita: 0, leads: 0, ops: new Set() }; managerSummary[manager].gasto += row.gasto; managerSummary[manager].receita += row.receita; managerSummary[manager].leads += row.leads; managerSummary[manager].ops.add(row.operacao); }); const managers = Object.keys(managerSummary); const horizontalBarOptions = (formatter) => ({ indexAxis: 'y', plugins: { legend: { display: false }, datalabels: { display: true, anchor: 'end', align: 'end', color: '#555', font: { size: 12, weight: '600' }, formatter: formatter, offset: 4 } }, scales: { x: { grid: { display: false }, ticks: { display: false } }, y: { grid: { display: false }, ticks: { font: { size: 14 } } } } }); const sortedByGasto = [...managers].sort((a, b) => managerSummary[b].gasto - managerSummary[a].gasto); createOrUpdateChart('gestorInvestimentoTotalChart', 'bar', { labels: sortedByGasto, datasets: [{ label: 'Investimento Total', data: sortedByGasto.map(m => managerSummary[m].gasto), backgroundColor: '#3498db' }] }, horizontalBarOptions((v) => formatKilo(v))); const sortedByRoas = [...managers].sort((a, b) => (managerSummary[b].gasto > 0 ? managerSummary[b].receita / managerSummary[b].gasto : 0) - (managerSummary[a].gasto > 0 ? managerSummary[a].receita / managerSummary[a].gasto : 0)); createOrUpdateChart('gestorRoasChart', 'bar', { labels: sortedByRoas, datasets: [{ label: 'ROAS Médio', data: sortedByRoas.map(m => managerSummary[m].gasto > 0 ? managerSummary[m].receita / managerSummary[m].gasto : 0), backgroundColor: '#9b59b6' }] }, horizontalBarOptions((v) => v.toFixed(2) + 'x')); const sortedByCPA = [...managers].sort((a, b) => (managerSummary[a].leads > 0 ? managerSummary[a].gasto / managerSummary[a].leads : Infinity) - (managerSummary[b].leads > 0 ? managerSummary[b].gasto / managerSummary[b].leads : Infinity)); createOrUpdateChart('gestorCpaChart', 'bar', { labels: sortedByCPA, datasets: [{ label: 'CPA Médio', data: sortedByCPA.map(m => managerSummary[m].leads > 0 ? managerSummary[m].gasto / managerSummary[m].leads : 0), backgroundColor: '#e67e22' }] }, horizontalBarOptions((v) => formatCurrency(v))); const sortedByOps = [...managers].sort((a, b) => managerSummary[b].ops.size - managerSummary[a].ops.size); createOrUpdateChart('managerOpsCountChart', 'bar', { labels: sortedByOps, datasets: [{ label: 'Nº de Operações', data: sortedByOps.map(m => managerSummary[m].ops.size), backgroundColor: '#1abc9c' }] }, horizontalBarOptions((v) => v)); }
        function renderAdopsCharts(data) { const adopsSummary = {}; const includedData = data.filter(row => row.responsavelMonetizacao && row.responsavelMonetizacao.trim() !== ""); includedData.forEach(row => { const adops = row.responsavelMonetizacao; if (!adopsSummary[adops]) { adopsSummary[adops] = { gasto: 0, receita: 0, leads: 0, ops: new Set() }; } adopsSummary[adops].gasto += row.gasto; adopsSummary[adops].receita += row.receita; adopsSummary[adops].leads += row.leads; adopsSummary[adops].ops.add(row.operacao); }); const adopsPersonnel = Object.keys(adopsSummary); const horizontalBarOptions = (formatter) => ({ indexAxis: 'y', plugins: { legend: { display: false }, datalabels: { display: true, anchor: 'end', align: 'end', color: '#555', font: { size: 12, weight: '600' }, formatter: formatter, offset: 4 } }, scales: { x: { grid: { display: false }, ticks: { display: false } }, y: { grid: { display: false }, ticks: { font: { size: 14 } } } } }); const sortedByRevenue = [...adopsPersonnel].sort((a, b) => adopsSummary[b].receita - adopsSummary[a].receita); createOrUpdateChart('adopsRevenueChart', 'bar', { labels: sortedByRevenue, datasets: [{ label: 'Receita Total', data: sortedByRevenue.map(m => adopsSummary[m].receita), backgroundColor: '#2ecc71' }] }, horizontalBarOptions((v) => formatCurrency(v))); const sortedByInvestment = [...adopsPersonnel].sort((a, b) => adopsSummary[b].gasto - adopsSummary[a].gasto); createOrUpdateChart('adopsInvestmentChart', 'bar', { labels: sortedByInvestment, datasets: [{ label: 'Investimento Gerenciado', data: sortedByInvestment.map(m => adopsSummary[m].gasto), backgroundColor: '#3498db' }] }, horizontalBarOptions((v) => formatCurrency(v))); const sortedByRoas = [...adopsPersonnel].sort((a, b) => (adopsSummary[b].gasto > 0 ? adopsSummary[b].receita / adopsSummary[b].gasto : 0) - (adopsSummary[a].gasto > 0 ? adopsSummary[a].receita / adopsSummary[a].gasto : 0)); createOrUpdateChart('adopsRoasChart', 'bar', { labels: sortedByRoas, datasets: [{ label: 'ROAS Médio', data: sortedByRoas.map(m => adopsSummary[m].gasto > 0 ? adopsSummary[m].receita / adopsSummary[m].gasto : 0), backgroundColor: '#9b59b6' }] }, horizontalBarOptions((v) => v.toFixed(2) + 'x')); const sortedByLeads = [...adopsPersonnel].sort((a, b) => adopsSummary[b].leads - adopsSummary[a].leads); createOrUpdateChart('adopsLeadsChart', 'bar', { labels: sortedByLeads, datasets: [{ label: 'Leads Gerenciados', data: sortedByLeads.map(m => adopsSummary[m].leads), backgroundColor: '#f1c40f' }] }, horizontalBarOptions((v) => v.toLocaleString('pt-BR'))); const sortedByOps = [...adopsPersonnel].sort((a, b) => adopsSummary[b].ops.size - adopsSummary[a].ops.size); createOrUpdateChart('adopsOpsCountChart', 'bar', { labels: sortedByOps, datasets: [{ label: 'Nº de Operações', data: sortedByOps.map(m => adopsSummary[m].ops.size), backgroundColor: '#e74c3c' }] }, horizontalBarOptions((v) => v)); }
        function renderBusinessSegmentTables(data) { createSegmentTable('segmentUsCcTable', SEGMENT_US_CC, data); createSegmentTable('segmentUsEmpTable', SEGMENT_US_EMP, data); createSegmentTable('segmentBrCcTable', SEGMENT_BR_CC, data); createSegmentTable('segmentBrEmpTable', SEGMENT_BR_EMP, data); createSegmentTable('segmentDeCcTable', SEGMENT_DE_CC, data); createSegmentTable('segmentFrCcTable', SEGMENT_FR_CC, data); }
        function createSegmentTable(elementId, segmentOperations, allData) { const segmentData = segmentOperations.map(op => { const rows = allData.filter(row => row.operacao === op); const gasto = rows.reduce((s, r) => s + r.gasto, 0); const receita = rows.reduce((s, r) => s + r.receita, 0); const leads = rows.reduce((s, r) => s + r.leads, 0); const roas = gasto > 0 ? receita / gasto : 0; const cpa = leads > 0 ? gasto / leads : 0; const receitaPorLead = leads > 0 ? receita / leads : 0; const perdaPorLead = cpa - receitaPorLead; const roasPercentage = (roas - 1) * 100; return { operacao: op, gasto, receita, leads, cpa, roasPercentage, perdaPorLead }; }); segmentDataCache[elementId] = segmentData; _renderAndAttachSortListeners(elementId, segmentData, tableSortState); }
        function _renderAndAttachSortListeners(elementId, dataToRender, stateObject) { const container = document.getElementById(elementId); if (!container) return; const currentSort = stateObject[elementId] || {}; const getSortIndicator = (key) => { if (currentSort.key !== key) return '⇅'; return currentSort.order === 'desc' ? '▼' : '▲'; }; const headers = [{ key: 'operacao', label: 'Operação' }, { key: 'gasto', label: 'Gasto' }, { key: 'leads', label: 'Leads' }, { key: 'cpa', label: 'CPA' }, { key: 'roasPercentage', label: 'ROAS' }, { key: 'perdaPorLead', label: 'Perda por Lead' }]; let tableHtml = `<table class="performance-table"><thead><tr>`; headers.forEach(h => { tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`; }); tableHtml += `</tr></thead><tbody>`; dataToRender.forEach(d => { const roasClass = d.roasPercentage >= 0 ? 'delta-positive' : 'delta-negative'; const roasSign = d.roasPercentage >= 0 ? '+' : ''; tableHtml += `<tr> <td>${d.operacao.replace(' TOTAL', '')}</td> <td>${formatCurrency(d.gasto)}</td> <td>${d.leads.toLocaleString('pt-BR')}</td> <td>${formatCurrency(d.cpa)}</td> <td><span class="${roasClass}">${roasSign}${d.roasPercentage.toFixed(0)}%</span></td> <td><span class="${d.perdaPorLead > 0 ? 'delta-negative' : 'delta-positive'}">${formatCurrency(d.perdaPorLead)}</span></td> </tr>`; }); container.innerHTML = tableHtml + `</tbody></table>`; container.querySelectorAll('.sortable').forEach(th => { th.addEventListener('click', () => { sortTable(elementId, th.dataset.sort, segmentDataCache, stateObject, _renderAndAttachSortListeners); }); }); }
        function sortTable(elementId, sortKey, cacheObject, stateObject, renderFunc) { const data = [...cacheObject[elementId]]; const currentState = stateObject[elementId] || {}; let defaultOrder = 'desc'; if (['cpa', 'perdaPorLead', 'operacao', 'day'].includes(sortKey)) { defaultOrder = 'asc'; } let nextOrder = defaultOrder; if (currentState.key === sortKey) { nextOrder = currentState.order === 'asc' ? 'desc' : 'asc'; } stateObject[elementId] = { key: sortKey, order: nextOrder }; data.sort((a, b) => { const valA = sortKey === 'day' ? new Date(a[sortKey]) : a[sortKey]; const valB = sortKey === 'day' ? new Date(b[sortKey]) : b[sortKey]; if (typeof valA === 'string') { return nextOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA); } else { return nextOrder === 'asc' ? valA - valB : valB - valA; } }); renderFunc(elementId, data, stateObject); }
        function renderCompanyView(data) { const companySummary = {}; Object.keys(COMPANIES).forEach(prefix => { companySummary[prefix] = { gasto: 0, receita: 0, leads: 0, opsData: [] }; }); data.forEach(row => { const prefix = row.operacao.substring(0, row.operacao.indexOf(' ')).toUpperCase(); if (COMPANIES[prefix]) { companySummary[prefix].gasto += row.gasto; companySummary[prefix].receita += row.receita; companySummary[prefix].leads += row.leads; companySummary[prefix].opsData.push(row); } }); const cardsContainer = document.getElementById('company-cards-wrapper'); cardsContainer.innerHTML = ''; Object.entries(companySummary).forEach(([prefix, summary]) => { if (summary.gasto > 0) { const company = COMPANIES[prefix]; const roas = summary.gasto > 0 ? summary.receita / summary.gasto : 0; const cpa = summary.leads > 0 ? summary.gasto / summary.leads : 0; let companyHTML = `<div class="regional-section"><h3>${company.name}</h3><div class="summary-cards">`; companyHTML += createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(summary.gasto) }); companyHTML += createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roas.toFixed(2)}x` }); companyHTML += createCardHTML({ icon: '💸', title: 'CPA Médio', value: formatCurrency(cpa) }); companyHTML += createCardHTML({ icon: '👥', title: 'Total de Leads', value: summary.leads.toLocaleString('pt-BR') }); companyHTML += `</div></div>`; cardsContainer.innerHTML += companyHTML; } }); const totalGastoData = Object.entries(companySummary).filter(([, summary]) => summary.gasto > 0).map(([prefix, summary]) => ({ label: COMPANIES[prefix].name, value: summary.gasto, color: COMPANIES[prefix].color })); if (totalGastoData.length > 0) { createOrUpdateChart('companyTotalGastoPieChart', 'pie', { labels: totalGastoData.map(d => d.label), datasets: [{ data: totalGastoData.map(d => d.value), backgroundColor: totalGastoData.map(d => d.color) }] }, { plugins: { datalabels: { display: true, formatter: (value, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (value / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }); } else { if (charts['companyTotalGastoPieChart']) charts['companyTotalGastoPieChart'].destroy(); const ctx = document.getElementById('companyTotalGastoPieChart').getContext('2d'); if (ctx) ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); } updateCompanyEvolutionChart(); const distributionContainer = document.getElementById('companyDistributionCharts'); distributionContainer.innerHTML = ''; Object.entries(companySummary).forEach(([prefix, summary]) => { if (summary.gasto > 0) { const company = COMPANIES[prefix]; const regionalSplit = { br: 0, us: 0, eu: 0 }; summary.opsData.forEach(row => { const op = row.operacao.toUpperCase(); if (op.includes('BR')) regionalSplit.br += row.gasto; else if (op.includes('US')) regionalSplit.us += row.gasto; else if (['DE', 'FR', 'UK', 'AU'].some(c => op.includes(c))) regionalSplit.eu += row.gasto; }); const canvasId = `companyDistribution-${prefix}`; const chartContainerHTML = ` <div class="chart-container"> <h2>Distribuição Regional - ${company.name}</h2> <canvas id="${canvasId}"></canvas> </div>`; distributionContainer.innerHTML += chartContainerHTML; setTimeout(() => { createOrUpdateChart(canvasId, 'pie', { labels: ['Brasil', 'Estados Unidos', 'Europa'], datasets: [{ label: 'Investimento', data: [regionalSplit.br, regionalSplit.us, regionalSplit.eu], backgroundColor: [REGION_COLORS.br.investment, REGION_COLORS.us.investment, REGION_COLORS.eu.investment] }] }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff' } } }); }, 0); } }); }
        function populateCompanyCheckboxes() { const container = document.getElementById('company-checkbox-group'); if (!container) return; container.innerHTML = ''; container.innerHTML += `<input type="checkbox" id="company-all" value="all" onchange="handleCompanySelection(this)" checked><label for="company-all">Todas</label>`; Object.entries(COMPANIES).forEach(([prefix, company]) => { container.innerHTML += ` <input type="checkbox" id="company-${prefix}" value="${prefix}" onchange="handleCompanySelection(this)"> <label for="company-${prefix}">${company.name}</label> `; }); }
        function handleCompanySelection(checkbox) { const allCheckbox = document.getElementById('company-all'); const companyCheckboxes = document.querySelectorAll('#company-checkbox-group input:not(#company-all)'); if (checkbox.id === 'company-all' && checkbox.checked) { companyCheckboxes.forEach(cb => cb.checked = false); } else if (checkbox.id !== 'company-all') { if (Array.from(companyCheckboxes).some(cb => cb.checked)) { allCheckbox.checked = false; } } if (!document.querySelector('#company-checkbox-group input:checked')) { allCheckbox.checked = true; } updateCompanyEvolutionChart(); }
        function updateCompanyEvolutionChart() { const selectedCompanyPrefixes = Array.from(document.querySelectorAll('#company-checkbox-group input:checked')).map(cb => cb.value); const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao)); const allDates = [...new Set(dataOnlyTotal.map(r => r.data))].sort((a, b) => parseDate(a) - parseDate(b)); const evolutionDatasets = []; const companiesToDisplay = selectedCompanyPrefixes.includes('all') ? Object.keys(COMPANIES) : selectedCompanyPrefixes; companiesToDisplay.forEach(prefix => { const company = COMPANIES[prefix]; if (!company) return; const dailyData = {}; dataOnlyTotal.filter(row => row.operacao.startsWith(prefix)).forEach(row => { if (!dailyData[row.data]) dailyData[row.data] = 0; dailyData[row.data] += row.gasto; }); const investmentData = allDates.map(date => dailyData[date] || 0); if (selectedCompanyPrefixes.includes('all') && !investmentData.some(val => val > 0)) { return; } evolutionDatasets.push({ label: company.name, data: investmentData, borderColor: company.color, backgroundColor: hexToRgba(company.color, 0.1), fill: false, tension: 0.4 }); }); createOrUpdateChart('companyEvolutionChart', 'line', { labels: allDates, datasets: evolutionDatasets }); }
        function _renderAndAttachSortListenersForMetasTable(elementId, dataToRender) { const container = document.getElementById(elementId); if (!container) return; const currentSort = metasTableSortState[elementId] || {}; const getSortIndicator = (key) => { if (currentSort.key !== key) return '⇅'; return currentSort.order === 'desc' ? '▼' : '▲'; }; const headers = [{ key: 'operacao', label: 'Operação' }, { key: 'atualInvestimento', label: 'Investimento de Ontem' }, { key: 'metaInvestimento', label: 'Meta Diária' }, { key: 'progressoInvest', label: 'Progresso', style: 'min-width: 180px;' }, { key: 'diffProgresso', label: 'Status Investimento' }, { key: 'gapInvestimento', label: 'Gap (R$)' }, { key: 'atualRoas', label: 'ROAS de Ontem' }, { key: 'roasMedioTotal', label: 'ROAS Médio Total' }, { key: 'metaRoas', label: 'Meta ROAS' }, { key: 'diffRoas', label: 'Status ROAS' }]; let tableHtml = `<table class="performance-table"><thead><tr>`; headers.forEach(h => { tableHtml += `<th class="sortable" data-sort="${h.key}" style="${h.style || ''}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`; }); tableHtml += `</tr></thead><tbody>`; dataToRender.forEach(d => { const progresso = Math.min(d.progressoInvest, 100); const roasClass = d.diffRoas >= 0 ? 'delta-positive' : 'delta-negative'; const roasSign = d.diffRoas >= 0 ? '+' : ''; const statusInvestClass = d.diffProgresso >= 0 ? 'delta-positive' : 'delta-negative'; const statusInvestSign = d.diffProgresso > 0 ? '+' : ''; const statusInvestText = !isNaN(d.diffProgresso) ? `${statusInvestSign}${d.diffProgresso.toFixed(1)} p.p.` : '-'; tableHtml += `<tr> <td>${d.operacao}</td> <td>${formatCurrency(d.atualInvestimento)}</td> <td>${formatCurrency(d.metaInvestimento)}</td> <td> <div class="progress-bar-container"> <div class="progress-bar"> <div class="progress-bar-inner" style="width: ${progresso}%;"></div> </div> <span class="progress-percent">${d.progressoInvest.toFixed(0)}%</span> </div> </td> <td><span class="${statusInvestClass}">${statusInvestText}</span></td> <td>${formatCurrency(d.gapInvestimento)}</td> <td>${(d.atualRoas * 100).toFixed(0)}%</td> <td>${(d.roasMedioTotal * 100).toFixed(0)}%</td> <td>${(d.metaRoas * 100).toFixed(0)}%</td> <td><span class="${roasClass}">${roasSign}${d.diffRoas.toFixed(1)} p.p.</span></td> </tr>`; }); container.innerHTML = tableHtml + `</tbody></table>`; container.querySelectorAll('.sortable').forEach(th => { th.addEventListener('click', () => { sortTable(elementId, th.dataset.sort, segmentDataCache, metasTableSortState, _renderAndAttachSortListenersForMetasTable); }); }); }
        function renderDailyGoalProgressionTable(gastoTotalOntem, metasData) { const container = document.getElementById('metas-acceleration-table'); if (!container) return; const totalMetaDiariaOriginal = metasData.reduce((sum, item) => sum + item.metaInvestimento, 0); const cenarios = [{ label: 'Cenário 1M/dia', target: 1000000 }, { label: 'Cenário 1.5M/dia', target: 1500000 }, { label: 'Cenário 2M/dia', target: 2000000 }, { label: 'Cenário 2.5M/dia', target: 2500000 }]; let tableHTML = `<table class="performance-table acceleration-table">`; tableHTML += `<thead><tr> <th rowspan="2" style="min-width: 200px;">Operação</th> <th rowspan="2">Gasto de Ontem</th> <th rowspan="2">Meta Original</th>`; cenarios.forEach((c, index) => { tableHTML += `<th colspan="2" class="${index === 0 ? 'scenario-group-start' : ''}">${c.label}</th>`; }); tableHTML += `</tr>`; tableHTML += `<tr>`; cenarios.forEach((c, index) => { tableHTML += `<th class="${index === 0 ? 'scenario-group-start' : ''}">Gasto Alvo</th><th>Acréscimo</th>`; }); tableHTML += `</tr></thead>`; tableHTML += `<tbody>`; metasData.forEach(op => { tableHTML += `<tr> <td>${op.operacao}</td> <td>${formatCurrency(op.atualInvestimento)}</td> <td>${formatCurrency(op.metaInvestimento)}</td>`; cenarios.forEach((c, index) => { const gapGlobal = c.target - gastoTotalOntem; const groupClass = index === 0 ? 'scenario-group-start' : ''; if (gapGlobal <= 0) { tableHTML += `<td class="delta-positive ${groupClass}">Atingido</td><td>-</td>`; } else { const peso = (totalMetaDiariaOriginal > 0) ? op.metaInvestimento / totalMetaDiariaOriginal : 0; const acrescimo = gapGlobal * peso; const gastoAlvo = op.atualInvestimento + acrescimo; tableHTML += `<td class="${groupClass}">${formatCurrency(gastoAlvo)}</td> <td class="delta-negative acrescimo-cell"><span>+${formatCurrency(acrescimo)}</span></td>`; } }); tableHTML += `</tr>`; }); container.innerHTML = tableHTML + '</tbody></table>'; }
        function renderSprint1MCard(allFilteredData, gastoTotalOntem) { const container = document.getElementById('sprint-kpi-cards'); if (!container) return; const progress = SPRINT_1M_GOAL > 0 ? (gastoTotalOntem / SPRINT_1M_GOAL) * 100 : 0; container.innerHTML = createCardHTML({ icon: '🚀', title: `Progresso Sprint 1M (até ${formatDate(SPRINT_1M_DEADLINE, true)})`, value: `${progress.toFixed(1)}%`, footerHTML: `<div class="progress-bar"><div class="progress-bar-inner" style="width: ${Math.min(progress, 100)}%;"></div></div> <div style="font-size: 0.9em; color: var(--text-light); margin-top: 5px;">${formatCurrency(gastoTotalOntem)} de ${formatCurrency(SPRINT_1M_GOAL)}</div>` }); }
        function renderSprint1MTable(allFilteredData, ontemData) { const container = document.getElementById('sprint-1m-table'); if (!container) return; const today = new Date(); today.setUTCHours(0, 0, 0, 0); const daysRemaining = Math.max(1, (SPRINT_1M_DEADLINE.getTime() - today.getTime()) / (1000 * 60 * 60 * 24) + 1); const opMetrics = {}; const sprintOperations = SPRINT_1M_BASE_OPERATIONS.filter(opKey => !SPRINT_1M_RULES[opKey]?.exclude); sprintOperations.forEach(opKey => { const opData = allFilteredData.filter(row => getGoalKeyFromOperation(row.operacao) === opKey); const totalGasto = opData.reduce((sum, r) => sum + r.gasto, 0); const totalReceita = opData.reduce((sum, r) => sum + r.receita, 0); const gastoOntem = ontemData.filter(row => getGoalKeyFromOperation(row.operacao) === opKey).reduce((sum, r) => sum + r.gasto, 0); opMetrics[opKey] = { roas: totalGasto > 0 ? totalReceita / totalGasto : 0, gastoOntem: gastoOntem }; }); const gastoTotalOntem = ontemData.reduce((sum, r) => sum + r.gasto, 0); let totalGapParaAcelerar = SPRINT_1M_GOAL - gastoTotalOntem; const tableData = []; let totalIncrementoFixo = 0; sprintOperations.forEach(opKey => { const rule = SPRINT_1M_RULES[opKey]; if (rule) { let incrementoDiario = 0; let metaDiariaFinal = 0; if (rule.finalTarget) { metaDiariaFinal = rule.finalTarget; const gap = metaDiariaFinal - opMetrics[opKey].gastoOntem; incrementoDiario = gap / daysRemaining; } else if (rule.target) { metaDiariaFinal = rule.target; const gap = metaDiariaFinal - opMetrics[opKey].gastoOntem; incrementoDiario = gap > 0 ? gap / daysRemaining : 0; } totalIncrementoFixo += incrementoDiario; tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal, incrementoDiario }); } }); const gapParaDistribuir = (totalGapParaAcelerar / daysRemaining) - totalIncrementoFixo; const opsParaDistribuir = sprintOperations.filter(opKey => !SPRINT_1M_RULES[opKey] && opMetrics[opKey].roas > 0.9); const pesoTotal = opsParaDistribuir.reduce((sum, opKey) => sum + (GOALS_DATA[opKey]?.investimento || 50000), 0); opsParaDistribuir.forEach(opKey => { const peso = (GOALS_DATA[opKey]?.investimento || 50000) / pesoTotal; const incrementoDiario = gapParaDistribuir > 0 ? gapParaDistribuir * peso : 0; const metaDiariaFinal = opMetrics[opKey].gastoOntem + (incrementoDiario * daysRemaining); tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal, incrementoDiario }); }); sprintOperations.forEach(opKey => { if (!tableData.find(d => d.operacao === opKey)) { tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal: opMetrics[opKey].gastoOntem, incrementoDiario: 0 }); } }); const dateHeaders = Array.from({ length: daysRemaining }, (_, i) => { const d = new Date(today); d.setUTCDate(today.getUTCDate() + i); return d; }); const dailySpendByOp = allFilteredData.reduce((acc, row) => { const key = getGoalKeyFromOperation(row.operacao); if (key) { if (!acc[key]) acc[key] = {}; acc[key][row.data] = (acc[key][row.data] || 0) + row.gasto; } return acc; }, {}); let tableHTML = `<table class="performance-table sprint-table"><thead><tr> <th>Operação</th><th>Gasto Ontem</th><th>Meta Diária Final</th><th>Gap p/ Meta</th><th>Incremento Diário</th>`; dateHeaders.forEach(d => tableHTML += `<th>${formatDate(d, true)}</th>`); tableHTML += `</tr></thead><tbody>`; tableData.sort((a, b) => sprintOperations.indexOf(a.operacao) - sprintOperations.indexOf(b.operacao)); tableData.forEach(d => { const gap = d.metaDiariaFinal - d.gastoOntem; tableHTML += `<tr> <td>${d.operacao}</td><td>${formatCurrency(d.gastoOntem)}</td> <td style="font-weight:bold;">${formatCurrency(d.metaDiariaFinal)}</td> <td class="${gap >= 0 ? 'delta-negative' : 'delta-positive'}">${formatCurrency(gap)}</td> <td style="font-style: italic; color: ${d.incrementoDiario >= 0 ? 'var(--color-negative)' : 'var(--color-positive)'};">${d.incrementoDiario >= 0 ? '+' : ''}${formatCurrency(d.incrementoDiario)}</td>`; dateHeaders.forEach((date, i) => { const plannedSpend = d.gastoOntem + (d.incrementoDiario * (i + 1)); const actualSpend = dailySpendByOp[d.operacao]?.[formatDate(date)]; if (actualSpend !== undefined) { const performanceClass = actualSpend >= plannedSpend ? 'delta-positive' : 'delta-negative'; const progressPct = plannedSpend > 0.01 ? (actualSpend / plannedSpend * 100).toFixed(0) : 100; tableHTML += `<td> <div class="daily-cell ${performanceClass}"> <div>Real: ${formatCurrency(actualSpend)} (${progressPct}%)</div> <div>Planj: ${formatCurrency(plannedSpend)}</div> </div></td>`; } else { tableHTML += `<td><div class="daily-cell"><div>Planj: ${formatCurrency(plannedSpend)}</div></div></td>`; } }); tableHTML += `</tr>`; }); tableHTML += `</tbody><tfoot><tr><td>Total</td>`; const footerTotals = { gastoOntem: tableData.reduce((s, d) => s + d.gastoOntem, 0), metaDiariaFinal: tableData.reduce((s, d) => s + d.metaDiariaFinal, 0), gap: tableData.reduce((s, d) => s + (d.metaDiariaFinal - d.gastoOntem), 0), incrementoDiario: tableData.reduce((s, d) => s + d.incrementoDiario, 0) }; tableHTML += `<td>${formatCurrency(footerTotals.gastoOntem)}</td> <td>${formatCurrency(footerTotals.metaDiariaFinal)}</td> <td>${formatCurrency(footerTotals.gap)}</td> <td>+${formatCurrency(footerTotals.incrementoDiario)}</td>`; dateHeaders.forEach((date, i) => { const totalPlanned = tableData.reduce((s, d) => s + (d.gastoOntem + (d.incrementoDiario * (i + 1))), 0); const totalActual = sprintOperations.reduce((s, opKey) => s + (dailySpendByOp[opKey]?.[formatDate(date)] || 0), 0); if (totalActual > 0) { tableHTML += `<td>${formatCurrency(totalActual)}</td>`; } else { tableHTML += `<td>${formatCurrency(totalPlanned)}</td>`; } }); tableHTML += `</tr></tfoot>`; container.innerHTML = tableHTML + `</table>`; }
        // SUBSTITUA sua função antiga por esta versão completa e atualizada
        function renderMetasView(data, allFilteredData) {
            if (data.length === 0) return;
            const allDates = [...new Set(data.map(d => d.data))].filter(Boolean).sort((a, b) => parseDate(b) - parseDate(a));
            const lastDateStr = allDates[0];
            const dayBeforeLastDateStr = allDates[1];
            const ontemData = data.filter(d => d.data === lastDateStr);
            const diaAnteriorData = dayBeforeLastDateStr ? data.filter(d => d.data === dayBeforeLastDateStr) : [];
            const totalPeriodDataByOp = {};
            data.forEach(row => {
                const goalKey = getGoalKeyFromOperation(row.operacao);
                if (!goalKey) return;
                if (!totalPeriodDataByOp[goalKey]) totalPeriodDataByOp[goalKey] = {
                    gasto: 0,
                    receita: 0
                };
                totalPeriodDataByOp[goalKey].gasto += row.gasto;
                totalPeriodDataByOp[goalKey].receita += row.receita;
            });
            const mergedData = [];
            const activeGoals = Object.entries(GOALS_DATA).filter(([, goal]) => goal.investimento > 0);
            activeGoals.forEach(([goalKey, goal]) => {
                const matchingOpsOntem = ontemData.filter(row => getGoalKeyFromOperation(row.operacao) === goalKey);
                const gastoOntem = matchingOpsOntem.reduce((sum, r) => sum + r.gasto, 0);
                const receitaOntem = matchingOpsOntem.reduce((sum, r) => sum + r.receita, 0);
                const matchingOpsDiaAnterior = diaAnteriorData.filter(row => getGoalKeyFromOperation(row.operacao) === goalKey);
                const gastoDiaAnterior = matchingOpsDiaAnterior.reduce((sum, r) => sum + r.gasto, 0);
                const totalData = totalPeriodDataByOp[goalKey] || {
                    gasto: 0,
                    receita: 0
                };
                const roasMedioTotal = totalData.gasto > 0 ? totalData.receita / totalData.gasto : 0;
                const roasOntem = gastoOntem > 0 ? receitaOntem / gastoOntem : 0;
                const progressoInvest = (goal.investimento > 0) ? (gastoOntem / goal.investimento) * 100 : 0;
                const progressoDiaAnterior = (goal.investimento > 0) ? (gastoDiaAnterior / goal.investimento) * 100 : 0;
                const diffProgresso = progressoInvest - progressoDiaAnterior;
                mergedData.push({
                    operacao: goalKey,
                    atualInvestimento: gastoOntem,
                    metaInvestimento: goal.investimento,
                    progressoInvest: progressoInvest,
                    gapInvestimento: goal.investimento - gastoOntem,
                    atualRoas: roasOntem,
                    metaRoas: goal.roas,
                    diffRoas: (roasOntem - goal.roas) * 100,
                    roasMedioTotal: roasMedioTotal,
                    diffProgresso: diffProgresso
                });
            });
            segmentDataCache['metas-detailed-table'] = mergedData;
            const gastoTotalOntem = ontemData.reduce((sum, item) => sum + item.gasto, 0);
            const totalMeta = mergedData.reduce((sum, item) => sum + item.metaInvestimento, 0);
            const progressoTotal = totalMeta > 0 ? (gastoTotalOntem / totalMeta) * 100 : 0;
            document.getElementById('metas-kpi-cards').innerHTML = createCardHTML({
                icon: '💰',
                title: `Progresso Meta Diária (${lastDateStr || 'N/A'})`,
                value: `${progressoTotal.toFixed(1)}%`,
                footerHTML: `<div class="progress-bar"><div class="progress-bar-inner" style="width: ${Math.min(progressoTotal, 100)}%;"></div></div> <div style="font-size: 0.9em; color: var(--text-light); margin-top: 5px;">${formatCurrency(gastoTotalOntem)} de ${formatCurrency(totalMeta)}</div>`
            });
            _renderAndAttachSortListenersForMetasTable('metas-detailed-table', mergedData);
            renderDailyGoalProgressionTable(gastoTotalOntem, mergedData);
            renderSprint1MCard(allFilteredData, gastoTotalOntem);
            renderSprint1MTable(allFilteredData, ontemData);

            // LINHA MODIFICADA:
            renderSprint1810Table(allFilteredData, ontemData);
        }
        function createOrUpdateChart(canvasId, type, data, customOptions = {}, customPlugins = []) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) {
                console.error(`Canvas with ID ${canvasId} not found.`);
                return;
            }
            if (charts[canvasId]) {
                charts[canvasId].destroy();
            }

            // Lógica para altura dinâmica de gráficos de barra horizontais
            if (type === 'bar' && customOptions.indexAxis === 'y') {
                const numBars = data.labels ? data.labels.length : 0; // Verifica se labels existe
                if (numBars > 0) {
                    const newHeight = calculateChartHeight(numBars);
                    const parentContainer = ctx.parentElement;
                    if (parentContainer && parentContainer.classList.contains('chart-container')) { // Verifica se parentContainer existe
                        parentContainer.style.height = `${newHeight + 60}px`;
                    }
                }
            }

            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'bottom', labels: { boxWidth: 12, padding: 20 } },
                    tooltip: {
                        backgroundColor: '#333',
                        titleFont: { size: 14 },
                        bodyFont: { size: 12 },
                        callbacks: {
                            label: (context) => {
                                let label = context.dataset.label || '';
                                // Tratamento para valor indefinido ou nulo
                                let value = context.parsed?.y ?? context.parsed;
                                if (value == null) return label ? `${label}: N/A` : 'N/A'; // Retorna N/A se o valor for nulo/indefinido

                                if (label) { label += ': '; }
                                if (label.toLowerCase().includes('roas')) return `${label}${value.toFixed(2)}x`;
                                if (label.toLowerCase().includes('leads')) return `${label}${value.toLocaleString('pt-BR')}`;
                                // Adicionado tratamento para CPA no tooltip
                                if (label.toLowerCase().includes('cpa')) return `${label}${formatCurrency(value)}`;
                                if (label.toLowerCase().includes('ctr') || label.toLowerCase().includes('tx. conv')) return `${label}${value.toFixed(2)}%`; // Formata CTR e CVR como %

                                // Formatação padrão como moeda para outros casos (Gasto, Receita, CPM, CPC)
                                return `${label}${formatCurrency(value)}`;
                            }
                        }
                    },
                    datalabels: { display: false } // Data labels desativados por padrão
                },
                scales: { // Escalas padrão, podem ser sobrescritas por customOptions
                    x: { grid: { display: false } },
                    y: { grid: { color: 'rgba(0,0,0,0.05)' }, ticks: { callback: (v) => formatKilo(v) } }
                }
            };

            // Combina as opções padrão com as customizadas (customOptions tem prioridade)
            // Usando deep merge simples para plugins e scales
            const finalOptions = {
                ...defaultOptions,
                ...customOptions,
                plugins: { ...defaultOptions.plugins, ...customOptions.plugins },
                scales: { ...defaultOptions.scales, ...customOptions.scales } // Combina escalas padrão e customizadas
            };


            // Cria o gráfico passando os plugins customizados
            charts[canvasId] = new Chart(ctx, {
                type,
                data,
                options: finalOptions,
                plugins: customPlugins // Passa o array de plugins customizados aqui
            });
        }
        // --- INÍCIO DAS FUNÇÕES PARA A ABA "ANÁLISE DE CONTAS JN" ---

        function processJnData() {
            populateJnAccountFilter();
            // filterJnData is now called by the master filter function
        }

        function filterJnData() {
            const dateStartStr = document.getElementById('dateFilterStart').value;
            const dateEndStr = document.getElementById('dateFilterEnd').value;
            let dateStart = null, dateEnd = null;

            if (dateStartStr) { dateStart = new Date(dateStartStr + 'T00:00:00Z'); }
            if (dateEndStr) { dateEnd = new Date(dateEndStr + 'T23:59:59Z'); }

            filteredDataJn = rawDataJn.filter(row => {
                if (!row.day) return false;
                try {
                    const rowDate = new Date(row.day + 'T00:00:00Z');
                    if (dateStart && rowDate < dateStart) return false;
                    if (dateEnd && rowDate > dateEnd) return false;
                } catch (e) { return false; }
                return true;
            });
        }

        function populateJnAccountFilter() {
            const select = document.getElementById('jnAccountFilter');
            if (!select || rawDataJn.length === 0) return;
            const accounts = [...new Set(rawDataJn.map(r => r.accountName))].sort();
            select.innerHTML = '<option value="">Selecione uma conta...</option>';
            accounts.forEach(acc => {
                select.innerHTML += `<option value="${acc}">${acc}</option>`;
            });
        }

        function toggleJnViewMode(mode) {
            const singleControls = document.getElementById('jn-single-view-controls');
            const compareControls = document.getElementById('jn-compare-view-controls');
            if (mode === 'single') {
                singleControls.style.display = 'flex';
                compareControls.style.display = 'none';
                clearJnComparison();
            } else {
                singleControls.style.display = 'none';
                compareControls.style.display = 'flex';
                document.getElementById('jnAccountFilter').value = '';
                renderJnAnalysisView();
            }
        }

        function handleJnAccountSearch() {
            const searchTerm = document.getElementById('jnAccountSearch').value.toLowerCase();
            const resultsContainer = document.getElementById('jnSearchResults');
            if (!searchTerm) {
                resultsContainer.innerHTML = '';
                return;
            }
            const allAccounts = [...new Set(rawDataJn.map(r => r.accountName))].sort();
            const filteredAccounts = allAccounts.filter(acc =>
                acc.toLowerCase().includes(searchTerm) && !jnComparedAccounts.includes(acc)
            );

            resultsContainer.innerHTML = filteredAccounts.map(acc =>
                `<div class="search-result-item" onclick="addJnAccountToComparison('${acc.replace(/'/g, "\\'")}')">${acc}</div>`
            ).join('');
        }

        function addJnAccountToComparison(accountName) {
            if (!jnComparedAccounts.includes(accountName)) {
                jnComparedAccounts.push(accountName);
                renderJnSelectedAccounts();
                renderJnAnalysisView();
            }
            document.getElementById('jnAccountSearch').value = '';
            document.getElementById('jnSearchResults').innerHTML = '';
        }

        function removeJnAccountFromComparison(accountName) {
            jnComparedAccounts = jnComparedAccounts.filter(acc => acc !== accountName);
            renderJnSelectedAccounts();
            renderJnAnalysisView();
        }

        function renderJnSelectedAccounts() {
            const container = document.getElementById('jnSelectedAccounts');
            container.innerHTML = jnComparedAccounts.map((acc, index) =>
                `<span class="account-pill" style="background-color: ${FANCY_COLORS[index % FANCY_COLORS.length]}">
                    ${acc}
                    <span class="remove-pill" onclick="removeJnAccountFromComparison('${acc.replace(/'/g, "\\'")}')">&times;</span>
                </span>`
            ).join('');
        }

        function clearJnComparison() {
            jnComparedAccounts = [];
            renderJnSelectedAccounts();
            renderJnAnalysisView();
        }

        function renderJnAnalysisView() {
            renderJnEvolutionChart();

            const mode = document.querySelector('input[name="jn-view-mode"]:checked').value;
            let accountsForTable = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('jnAccountFilter').value;
                if (selectedAccount) {
                    accountsForTable.push(selectedAccount);
                }
            } else {
                accountsForTable = [...jnComparedAccounts];
            }

            let aggregatedData = [];
            if (accountsForTable.length > 0) {
                const dataToAggregate = filteredDataJn.filter(r => accountsForTable.includes(r.accountName));

                const dailySums = dataToAggregate.reduce((acc, row) => {
                    if (!acc[row.day]) {
                        acc[row.day] = { day: row.day, spend: 0, impressions: 0, clicks: 0, conversions: 0 };
                    }
                    acc[row.day].spend += row.spend;
                    acc[row.day].impressions += row.impressions;
                    acc[row.day].clicks += row.clicks;
                    acc[row.day].conversions += row.conversions;
                    return acc;
                }, {});

                aggregatedData = Object.values(dailySums).map(day => ({
                    day: day.day,
                    spend: day.spend,
                    impressions: day.impressions,
                    clicks: day.clicks,
                    conversions: day.conversions,
                    ctr: day.impressions > 0 ? (day.clicks / day.impressions) * 100 : 0,
                    convRate: day.clicks > 0 ? (day.conversions / day.clicks) * 100 : 0,
                    cpa: day.conversions > 0 ? day.spend / day.conversions : 0,
                    cpm: day.impressions > 0 ? (day.spend / day.impressions) * 1000 : 0,
                    cpc: day.clicks > 0 ? day.spend / day.clicks : 0
                }));
            }

            _renderAndAttachSortListenersForJnTable('jn-daily-table', aggregatedData, accountsForTable);
            renderAccountFunnel('jn-funnel-container', filteredDataJn, mode === 'single' ? accountsForTable[0] : null);

        }

        function _renderAndAttachSortListenersForJnTable(elementId, data, accounts) {
            const container = document.getElementById(elementId);
            if (!container) return;

            if (!data || data.length === 0) {
                container.innerHTML = (accounts && accounts.length > 0) ?
                    '<p style="padding: 20px; text-align: center;">Nenhum dado encontrado para a(s) conta(s) no período selecionado.</p>' :
                    '<p style="padding: 20px; text-align: center;">Selecione uma ou mais contas para ver os dados diários agregados.</p>';
                return;
            }

            const currentSort = jnTableSortState[elementId] || { key: 'day', order: 'desc' };
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };

            const sortedData = [...data].sort((a, b) => {
                const valA = currentSort.key === 'day' ? new Date(a[currentSort.key]) : a[currentSort.key];
                const valB = currentSort.key === 'day' ? new Date(b[currentSort.key]) : b[currentSort.key];
                if (typeof valA === 'string') {
                    return currentSort.order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return currentSort.order === 'asc' ? valA - valB : valB - valA;
            });

            const currencyReferenceAccount = accounts.length > 0 ? accounts[0] : '';

            const headers = [
                { key: 'day', label: 'Dia' }, { key: 'spend', label: 'Gasto' }, { key: 'impressions', label: 'Impressões' },
                { key: 'clicks', label: 'Cliques' }, { key: 'ctr', label: 'CTR' }, { key: 'conversions', label: 'Conversões' },
                { key: 'convRate', label: 'Tx. Conv.' }, { key: 'cpa', label: 'CPA' }, { key: 'cpm', label: 'CPM' },
                { key: 'cpc', label: 'CPC' }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedData.forEach(row => {
                tableHtml += `<tr>
                    <td>${formatDate(new Date(row.day + 'T00:00:00Z'))}</td>
                    <td>${formatCurrency(row.spend, currencyReferenceAccount)}</td>
                    <td>${row.impressions.toLocaleString('pt-BR')}</td>
                    <td>${row.clicks.toLocaleString('pt-BR')}</td>
                    <td>${(row.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${row.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                    <td>${(row.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${formatCurrency(row.cpa, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpm, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpc, currencyReferenceAccount)}</td>
                </tr>`;
            });
            tableHtml += `</tbody>`;

            const totals = data.reduce((acc, row) => {
                acc.spend += row.spend;
                acc.impressions += row.impressions;
                acc.clicks += row.clicks;
                acc.conversions += row.conversions;
                return acc;
            }, { spend: 0, impressions: 0, clicks: 0, conversions: 0 });

            const weightedAvg = {
                ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
                convRate: totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0,
                cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0,
                cpm: totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0,
                cpc: totals.clicks > 0 ? totals.spend / totals.clicks : 0,
            };

            tableHtml += `<tfoot><tr>
                <td>Total / Média</td>
                <td>${formatCurrency(totals.spend, currencyReferenceAccount)}</td>
                <td>${totals.impressions.toLocaleString('pt-BR')}</td>
                <td>${totals.clicks.toLocaleString('pt-BR')}</td>
                <td>${(weightedAvg.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${totals.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                <td>${(weightedAvg.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${formatCurrency(weightedAvg.cpa, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpm, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpc, currencyReferenceAccount)}</td>
            </tr></tfoot></table>`;

            container.innerHTML = tableHtml;

            container.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const sortKey = th.dataset.sort;
                    const currentState = jnTableSortState[elementId] || {};
                    const nextOrder = (currentState.key === sortKey && currentState.order === 'asc') ? 'desc' : 'asc';
                    jnTableSortState[elementId] = { key: sortKey, order: nextOrder };
                    _renderAndAttachSortListenersForJnTable(elementId, data, accounts);
                });
            });
        }

        function renderJnEvolutionChart() {
            const canvasId = 'jnEvolutionChart';
            const mode = document.querySelector('input[name="jn-view-mode"]:checked').value;

            let accountsToRender = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('jnAccountFilter').value;
                if (selectedAccount) accountsToRender.push(selectedAccount);
            } else {
                accountsToRender = [...jnComparedAccounts];
            }

            // Currency mismatch warning
            const warningDiv = document.getElementById('jn-currency-warning');
            if (mode === 'compare' && accountsToRender.length > 1) {
                const currencies = new Set(accountsToRender.map(acc => {
                    if (acc.toUpperCase().includes('USD')) return 'USD';
                    if (acc.toUpperCase().includes('BRL')) return 'BRL';
                    return 'Outra';
                }));
                if (currencies.size > 1) {
                    warningDiv.innerHTML = `⚠️ <strong>Atenção:</strong> Você está comparando contas com moedas diferentes (${[...currencies].join(', ')}). Os valores nos eixos monetários podem não ser diretamente comparáveis.`;
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } else {
                warningDiv.style.display = 'none';
            }

            if (accountsToRender.length === 0) {
                if (charts[canvasId]) charts[canvasId].destroy();
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#6c757d";
                    ctx.fillText("Selecione uma ou mais contas para visualizar o gráfico.", canvas.width / 2, canvas.height / 2 - 20);
                }
                return;
            }

            const selectedMetrics = Array.from(document.querySelectorAll('#jn-metric-checkbox-group input:checked')).map(cb => cb.value);
            const allDatasets = [];
            const allDates = new Set();

            accountsToRender.forEach(accountName => {
                filteredDataJn.filter(r => r.accountName === accountName).forEach(r => allDates.add(r.day));
            });
            const sortedLabelsFull = [...allDates].sort((a, b) => new Date(a) - new Date(b));
            const sortedLabels = sortedLabelsFull.map(d => formatDate(new Date(d + 'T00:00:00Z'), true));

            accountsToRender.forEach((accountName, index) => {
                const accountData = filteredDataJn.filter(r => r.accountName === accountName);
                const color = FANCY_COLORS[index % FANCY_COLORS.length];

                const mapDataToLabels = (metric) => {
                    const dataMap = new Map(accountData.map(r => [r.day, r[metric]]));
                    return sortedLabelsFull.map(date => dataMap.get(date) ?? null);
                };

                if (selectedMetrics.includes('gasto')) { allDatasets.push({ label: mode === 'single' ? `Gasto` : `Gasto - ${accountName}`, data: mapDataToLabels('spend'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.spend : color, tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpm')) { allDatasets.push({ label: mode === 'single' ? `CPM` : `CPM - ${accountName}`, data: mapDataToLabels('cpm'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.cpm : color, borderDash: [2, 2], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpa')) { allDatasets.push({ label: mode === 'single' ? `CPA` : `CPA - ${accountName}`, data: mapDataToLabels('cpa'), yAxisID: 'y2', borderColor: mode === 'single' ? METRIC_COLORS.cpa : color, borderDash: [5, 5], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('ctr')) { allDatasets.push({ label: mode === 'single' ? `CTR` : `CTR - ${accountName}`, data: mapDataToLabels('ctr'), yAxisID: 'y1', borderColor: mode === 'single' ? METRIC_COLORS.ctr : color, tension: 0.4, backgroundColor: 'transparent' }); }
            });

            const options = {
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: { display: selectedMetrics.some(m => ['gasto', 'cpm'].includes(m)), position: 'left', title: { display: true, text: `Gasto / CPM` }, ticks: { callback: (v) => formatCurrency(v) } },
                    y1: { display: selectedMetrics.includes('ctr'), position: 'right', title: { display: true, text: 'CTR (%)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) + '%' } },
                    y2: { display: selectedMetrics.includes('cpa'), position: 'right', title: { display: true, text: `CPA` }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => formatCurrency(v) } }
                }
            };
            createOrUpdateChart(canvasId, 'line', { labels: sortedLabels, datasets: allDatasets }, options);
        }

        // --- INÍCIO DAS FUNÇÕES PARA A NOVA ABA "ANÁLISE DE CONTAS MG" ---

        function processMgData() {
            populateMgAccountFilter();
            // filterMgData is now called by the master filter function
        }

        function filterMgData() {
            const dateStartStr = document.getElementById('dateFilterStart').value;
            const dateEndStr = document.getElementById('dateFilterEnd').value;
            let dateStart = null, dateEnd = null;

            if (dateStartStr) { dateStart = new Date(dateStartStr + 'T00:00:00Z'); }
            if (dateEndStr) { dateEnd = new Date(dateEndStr + 'T23:59:59Z'); }

            filteredDataMg = rawDataMg.filter(row => {
                if (!row.day) return false;
                try {
                    const rowDate = new Date(row.day + 'T00:00:00Z');
                    if (dateStart && rowDate < dateStart) return false;
                    if (dateEnd && rowDate > dateEnd) return false;
                } catch (e) { return false; }
                return true;
            });
        }

        function populateMgAccountFilter() {
            const select = document.getElementById('mgAccountFilter');
            if (!select || rawDataMg.length === 0) return;
            const accounts = [...new Set(rawDataMg.map(r => r.accountName))].sort();
            select.innerHTML = '<option value="">Selecione uma conta...</option>';
            accounts.forEach(acc => {
                select.innerHTML += `<option value="${acc}">${acc}</option>`;
            });
        }
        function populateCoordinationFilter(data) {
            const trigger = document.getElementById('coord-select-trigger');
            const optionsContainer = document.getElementById('coord-select-options');
            const optionsList = document.getElementById('coord-options-list');
            const searchInput = document.getElementById('coord-search-input');
            if (!trigger || !optionsList) return;

            const coordinators = ['NICOLE', 'MARCELO', 'AMANDA']; // Lista fixa de coordenadores
            optionsList.innerHTML = '';

            // Define que por padrão todos estarão selecionados na primeira carga
            if (selectedCoordinatorsForChart.length === 0) {
                selectedCoordinatorsForChart = [...coordinators];
            }

            coordinators.forEach(coord => {
                const id = `coord-opt-${coord.replace(/\s+/g, '')}`;
                const isChecked = selectedCoordinatorsForChart.includes(coord) ? 'checked' : '';
                optionsList.innerHTML += `<label for="${id}"><input type="checkbox" id="${id}" value="${coord}" ${isChecked}> ${coord}</label>`;
            });

            const updateTriggerText = () => {
                if (selectedCoordinatorsForChart.length === 0) trigger.textContent = 'Nenhum selecionado';
                else if (selectedCoordinatorsForChart.length === coordinators.length) trigger.textContent = 'Todos';
                else if (selectedCoordinatorsForChart.length === 1) trigger.textContent = selectedCoordinatorsForChart[0];
                else trigger.textContent = `${selectedCoordinatorsForChart.length} selecionados`;
            };
            updateTriggerText();

            trigger.addEventListener('click', () => optionsContainer.classList.toggle('open'));
            searchInput.addEventListener('keyup', () => {
                const filter = searchInput.value.toLowerCase();
                optionsList.querySelectorAll('label').forEach(label => {
                    label.style.display = label.textContent.toLowerCase().includes(filter) ? '' : 'none';
                });
            });

            optionsList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    selectedCoordinatorsForChart = coordinators.filter(c => document.getElementById(`coord-opt-${c.replace(/\s+/g, '')}`)?.checked);
                    updateTriggerText();
                    filterAndRenderAll();
                });
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.custom-select')) {
                    optionsContainer.classList.remove('open');
                }
            });
        }

        function toggleMgViewMode(mode) {
            const singleControls = document.getElementById('mg-single-view-controls');
            const compareControls = document.getElementById('mg-compare-view-controls');
            if (mode === 'single') {
                singleControls.style.display = 'flex';
                compareControls.style.display = 'none';
                clearMgComparison();
            } else {
                singleControls.style.display = 'none';
                compareControls.style.display = 'flex';
                document.getElementById('mgAccountFilter').value = '';
                renderMgAnalysisView();
            }
        }

        function handleMgAccountSearch() {
            const searchTerm = document.getElementById('mgAccountSearch').value.toLowerCase();
            const resultsContainer = document.getElementById('mgSearchResults');
            if (!searchTerm) {
                resultsContainer.innerHTML = '';
                return;
            }
            const allAccounts = [...new Set(rawDataMg.map(r => r.accountName))].sort();
            const filteredAccounts = allAccounts.filter(acc =>
                acc.toLowerCase().includes(searchTerm) && !mgComparedAccounts.includes(acc)
            );
            resultsContainer.innerHTML = filteredAccounts.map(acc =>
                `<div class="search-result-item" onclick="addMgAccountToComparison('${acc.replace(/'/g, "\\'")}')">${acc}</div>`
            ).join('');
        }

        function addMgAccountToComparison(accountName) {
            if (!mgComparedAccounts.includes(accountName)) {
                mgComparedAccounts.push(accountName);
                renderMgSelectedAccounts();
                renderMgAnalysisView();
            }
            document.getElementById('mgAccountSearch').value = '';
            document.getElementById('mgSearchResults').innerHTML = '';
        }

        function removeMgAccountFromComparison(accountName) {
            mgComparedAccounts = mgComparedAccounts.filter(acc => acc !== accountName);
            renderMgSelectedAccounts();
            renderMgAnalysisView();
        }

        function renderMgSelectedAccounts() {
            const container = document.getElementById('mgSelectedAccounts');
            container.innerHTML = mgComparedAccounts.map((acc, index) =>
                `<span class="account-pill" style="background-color: ${FANCY_COLORS[index % FANCY_COLORS.length]}">
                    ${acc}
                    <span class="remove-pill" onclick="removeMgAccountFromComparison('${acc.replace(/'/g, "\\'")}')">&times;</span>
                </span>`
            ).join('');
        }

        function clearMgComparison() {
            mgComparedAccounts = [];
            renderMgSelectedAccounts();
            renderMgAnalysisView();
        }

        function renderMgAnalysisView() {
            renderMgEvolutionChart();
            const mode = document.querySelector('input[name="mg-view-mode"]:checked').value;
            let accountsForTable = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('mgAccountFilter').value;
                if (selectedAccount) {
                    accountsForTable.push(selectedAccount);
                }
            } else {
                accountsForTable = [...mgComparedAccounts];
            }
            let aggregatedData = [];
            if (accountsForTable.length > 0) {
                const dataToAggregate = filteredDataMg.filter(r => accountsForTable.includes(r.accountName));

                const dailySums = dataToAggregate.reduce((acc, row) => {
                    if (!acc[row.day]) {
                        acc[row.day] = { day: row.day, spend: 0, impressions: 0, clicks: 0, conversions: 0 };
                    }
                    acc[row.day].spend += row.spend;
                    acc[row.day].impressions += row.impressions;
                    acc[row.day].clicks += row.clicks;
                    acc[row.day].conversions += row.conversions;
                    return acc;
                }, {});

                aggregatedData = Object.values(dailySums).map(day => ({
                    day: day.day,
                    spend: day.spend,
                    impressions: day.impressions,
                    clicks: day.clicks,
                    conversions: day.conversions,
                    ctr: day.impressions > 0 ? (day.clicks / day.impressions) * 100 : 0,
                    convRate: day.clicks > 0 ? (day.conversions / day.clicks) * 100 : 0,
                    cpa: day.conversions > 0 ? day.spend / day.conversions : 0,
                    cpm: day.impressions > 0 ? (day.spend / day.impressions) * 1000 : 0,
                    cpc: day.clicks > 0 ? day.spend / day.clicks : 0
                }));
            }

            _renderAndAttachSortListenersForMgTable('mg-daily-table', aggregatedData, accountsForTable);
            renderAccountFunnel('mg-funnel-container', filteredDataMg, mode === 'single' ? accountsForTable[0] : null);

        }

        function _renderAndAttachSortListenersForMgTable(elementId, data, accounts) {
            const container = document.getElementById(elementId);
            if (!container) return;

            if (!data || data.length === 0) {
                container.innerHTML = (accounts && accounts.length > 0) ?
                    '<p style="padding: 20px; text-align: center;">Nenhum dado encontrado para a(s) conta(s) no período selecionado.</p>' :
                    '<p style="padding: 20px; text-align: center;">Selecione uma ou mais contas para ver os dados diários agregados.</p>';
                return;
            }

            const currentSort = mgTableSortState[elementId] || { key: 'day', order: 'desc' };
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };

            const sortedData = [...data].sort((a, b) => {
                const valA = currentSort.key === 'day' ? new Date(a[currentSort.key]) : a[currentSort.key];
                const valB = currentSort.key === 'day' ? new Date(b[currentSort.key]) : b[currentSort.key];
                if (typeof valA === 'string') {
                    return currentSort.order === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return currentSort.order === 'asc' ? valA - valB : valB - valA;
            });

            const currencyReferenceAccount = accounts.length > 0 ? accounts[0] : '';

            const headers = [
                { key: 'day', label: 'Dia' }, { key: 'spend', label: 'Gasto' }, { key: 'impressions', label: 'Impressões' },
                { key: 'clicks', label: 'Cliques' }, { key: 'ctr', label: 'CTR' }, { key: 'conversions', label: 'Conversões' },
                { key: 'convRate', label: 'Tx. Conv.' }, { key: 'cpa', label: 'CPA' }, { key: 'cpm', label: 'CPM' },
                { key: 'cpc', label: 'CPC' }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            sortedData.forEach(row => {
                tableHtml += `<tr>
                    <td>${formatDate(new Date(row.day + 'T00:00:00Z'))}</td>
                    <td>${formatCurrency(row.spend, currencyReferenceAccount)}</td>
                    <td>${row.impressions.toLocaleString('pt-BR')}</td>
                    <td>${row.clicks.toLocaleString('pt-BR')}</td>
                    <td>${(row.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${row.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                    <td>${(row.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                    <td>${formatCurrency(row.cpa, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpm, currencyReferenceAccount)}</td>
                    <td>${formatCurrency(row.cpc, currencyReferenceAccount)}</td>
                </tr>`;
            });
            tableHtml += `</tbody>`;

            const totals = data.reduce((acc, row) => {
                acc.spend += row.spend;
                acc.impressions += row.impressions;
                acc.clicks += row.clicks;
                acc.conversions += row.conversions;
                return acc;
            }, { spend: 0, impressions: 0, clicks: 0, conversions: 0 });

            const weightedAvg = {
                ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
                convRate: totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0,
                cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0,
                cpm: totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0,
                cpc: totals.clicks > 0 ? totals.spend / totals.clicks : 0,
            };

            tableHtml += `<tfoot><tr>
                <td>Total / Média</td>
                <td>${formatCurrency(totals.spend, currencyReferenceAccount)}</td>
                <td>${totals.impressions.toLocaleString('pt-BR')}</td>
                <td>${totals.clicks.toLocaleString('pt-BR')}</td>
                <td>${(weightedAvg.ctr).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${totals.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                <td>${(weightedAvg.convRate).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}%</td>
                <td>${formatCurrency(weightedAvg.cpa, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpm, currencyReferenceAccount)}</td>
                <td>${formatCurrency(weightedAvg.cpc, currencyReferenceAccount)}</td>
            </tr></tfoot></table>`;

            container.innerHTML = tableHtml;

            container.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    const sortKey = th.dataset.sort;
                    const currentState = mgTableSortState[elementId] || {};
                    const nextOrder = (currentState.key === sortKey && currentState.order === 'asc') ? 'desc' : 'asc';
                    mgTableSortState[elementId] = { key: sortKey, order: nextOrder };
                    _renderAndAttachSortListenersForMgTable(elementId, data, accounts);
                });
            });
        }

        function renderMgEvolutionChart() {
            const canvasId = 'mgEvolutionChart';
            const mode = document.querySelector('input[name="mg-view-mode"]:checked').value;

            let accountsToRender = [];
            if (mode === 'single') {
                const selectedAccount = document.getElementById('mgAccountFilter').value;
                if (selectedAccount) accountsToRender.push(selectedAccount);
            } else {
                accountsToRender = [...mgComparedAccounts];
            }

            // Currency mismatch warning
            const warningDiv = document.getElementById('mg-currency-warning');
            if (mode === 'compare' && accountsToRender.length > 1) {
                const currencies = new Set(accountsToRender.map(acc => {
                    if (acc.toUpperCase().includes('USD')) return 'USD';
                    if (acc.toUpperCase().includes('BRL')) return 'BRL';
                    return 'Outra';
                }));
                if (currencies.size > 1) {
                    warningDiv.innerHTML = `⚠️ <strong>Atenção:</strong> Você está comparando contas com moedas diferentes (${[...currencies].join(', ')}). Os valores nos eixos monetários podem não ser diretamente comparáveis.`;
                    warningDiv.style.display = 'block';
                } else {
                    warningDiv.style.display = 'none';
                }
            } else {
                warningDiv.style.display = 'none';
            }

            if (accountsToRender.length === 0) {
                if (charts[canvasId]) charts[canvasId].destroy();
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "#6c757d";
                    ctx.fillText("Selecione uma ou mais contas para visualizar o gráfico.", canvas.width / 2, canvas.height / 2 - 20);
                }
                return;
            }

            const selectedMetrics = Array.from(document.querySelectorAll('#mg-metric-checkbox-group input:checked')).map(cb => cb.value);
            const allDatasets = [];
            const allDates = new Set();

            accountsToRender.forEach(accountName => {
                filteredDataMg.filter(r => r.accountName === accountName).forEach(r => allDates.add(r.day));
            });
            const sortedLabelsFull = [...allDates].sort((a, b) => new Date(a) - new Date(b));
            const sortedLabels = sortedLabelsFull.map(d => formatDate(new Date(d + 'T00:00:00Z'), true));

            accountsToRender.forEach((accountName, index) => {
                const accountData = filteredDataMg.filter(r => r.accountName === accountName);
                const color = FANCY_COLORS[index % FANCY_COLORS.length];

                const mapDataToLabels = (metric) => {
                    const dataMap = new Map(accountData.map(r => [r.day, r[metric]]));
                    return sortedLabelsFull.map(date => dataMap.get(date) ?? null);
                };

                if (selectedMetrics.includes('gasto')) { allDatasets.push({ label: mode === 'single' ? `Gasto` : `Gasto - ${accountName}`, data: mapDataToLabels('spend'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.spend : color, tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpm')) { allDatasets.push({ label: mode === 'single' ? `CPM` : `CPM - ${accountName}`, data: mapDataToLabels('cpm'), yAxisID: 'y', borderColor: mode === 'single' ? METRIC_COLORS.cpm : color, borderDash: [2, 2], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('cpa')) { allDatasets.push({ label: mode === 'single' ? `CPA` : `CPA - ${accountName}`, data: mapDataToLabels('cpa'), yAxisID: 'y2', borderColor: mode === 'single' ? METRIC_COLORS.cpa : color, borderDash: [5, 5], tension: 0.4, backgroundColor: 'transparent' }); }
                if (selectedMetrics.includes('ctr')) { allDatasets.push({ label: mode === 'single' ? `CTR` : `CTR - ${accountName}`, data: mapDataToLabels('ctr'), yAxisID: 'y1', borderColor: mode === 'single' ? METRIC_COLORS.ctr : color, tension: 0.4, backgroundColor: 'transparent' }); }
            });

            const options = {
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: { display: selectedMetrics.some(m => ['gasto', 'cpm'].includes(m)), position: 'left', title: { display: true, text: `Gasto / CPM` }, ticks: { callback: (v) => formatCurrency(v) } },
                    y1: { display: selectedMetrics.includes('ctr'), position: 'right', title: { display: true, text: 'CTR (%)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) + '%' } },
                    y2: { display: selectedMetrics.includes('cpa'), position: 'right', title: { display: true, text: `CPA` }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => formatCurrency(v) } }
                }
            };
            createOrUpdateChart(canvasId, 'line', { labels: sortedLabels, datasets: allDatasets }, options);
        }

        function setupMetricToggle() { const toggleButtons = document.querySelectorAll('#metric-toggle .toggle-btn'); toggleButtons.forEach(btn => { btn.addEventListener('click', function () { if (this.classList.contains('active')) return; toggleButtons.forEach(b => b.classList.remove('active')); this.classList.add('active'); updateProportionCharts(); }); }); }
        function populateEvolutionFilters(data, selectedValue = 'all') { const operationFilter = document.getElementById('evolutionOperationFilter'); if (!operationFilter) return; const currentSelection = selectedValue || operationFilter.value; const operations = [...new Set(data.map(r => r.operacao))].sort(); operationFilter.innerHTML = '<option value="all">Todas as Operações</option>'; operations.forEach(op => { const option = document.createElement('option'); option.value = op; option.textContent = op.replace(' TOTAL', ''); operationFilter.appendChild(option); }); if (operations.includes(currentSelection)) { operationFilter.value = currentSelection; } else { operationFilter.value = 'all'; } }
        function setupNavbar() {
            // SUBSTITUA a sua função setupNavbar por esta:
            const navButtons = document.querySelectorAll('.sidebar-nav .nav-btn'); // Mude o seletor aqui
            const viewSections = document.querySelectorAll('.view-section');
            const mainTitle = document.getElementById('main-title');

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;

                    navButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    viewSections.forEach(section => {
                        section.classList.toggle('active', section.id === targetId);
                    });

                    // Atualiza o título principal
                    if (mainTitle) {
                        mainTitle.textContent = button.querySelector('span:last-child').textContent.trim();
                    }

                    // Redimensiona gráficos na aba ativa
                    const targetSection = document.getElementById(targetId);
                    if (targetSection && targetSection.classList.contains('active')) {
                        setTimeout(() => {
                            const canvases = targetSection.querySelectorAll('canvas');
                            canvases.forEach(canvas => {
                                const chartInstance = charts[canvas.id];
                                if (chartInstance) { chartInstance.resize(); }
                            });
                        }, 10);
                    }
                });
            });
        }
        // --- NOVA FUNÇÃO PARA A VISÃO OPERACIONAL ---
        function renderOperationalView() {
            const container = document.getElementById('operational-view-container');
            const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao));
            // INÍCIO DO CÓDIGO ADICIONADO
            // ===================================================================
            const warningHTML = `
                <div style="padding: 12px 15px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 8px; margin-bottom: 20px; color: #856404; font-size: 0.95em; text-align: center;">
                    ⚠️ <strong>Aviso:</strong> Essa visualização ainda não está 100%. Não confie nos dados.
                </div>
            `;
            // ===================================================================
            // FIM DO CÓDIGO ADICIONADO
            // ===================================================================
            if (!container || filteredData.length === 0 || (rawDataJn.length === 0 && rawDataMg.length === 0)) {
                container.innerHTML = warningHTML + '<p style="padding: 20px; text-align: center;">Não há dados suficientes para exibir a visão operacional.</p>';
                return;
            }

            const allDates = [...new Set(filteredData.map(r => r.data))].map(d => parseDate(d)).filter(Boolean).sort((a, b) => b - a);
            const last7Dates = allDates.slice(0, 7).map(d => formatDate(d));

            const operations = [...new Set(dataOnlyTotal.map(r => r.operacao))].sort();
            const metrics = [
                { key: 'investimento', label: 'Investimento', format: (v, op) => formatCurrency(v, op) },
                { key: 'roas', label: 'ROAS', format: v => `${((v - 1) * 100).toFixed(2)}%` },
                { key: 'ctr', label: 'CTR', format: v => `${v.toFixed(2)}%` },
                { key: 'cvr', label: 'CVR', format: v => `${v.toFixed(2)}%` },
                { key: 'cpm', label: 'CPM', format: (v, op) => formatCurrency(v, op) },
                { key: 'cpa', label: 'CPA', format: (v, op) => formatCurrency(v, op) },
            ];

            let tableHTML = `<table class="operational-table"><thead><tr>
                <th>OPERAÇÃO</th>
                <th>Plataforma</th>
                <th>O que</th>
                <th>Resultado | Meta</th>
                ${last7Dates.map(d => `<th>${formatDate(parseDate(d), true)}</th>`).join('')}
            </tr></thead><tbody>`;

            operations.forEach((opName, opIndex) => {
                const opKeyForGoal = opName.replace(' TOTAL', '');
                const opCompany = opKeyForGoal.split(' ')[0].toUpperCase();

                const dailyData = {};
                last7Dates.forEach(dateStr => {
                    let metricsForDay = { investimento: 0, roas: 0, ctr: 0, cvr: 0, cpm: 0, cpa: 0 };
                    const specialRule = SPECIAL_JN_RULES[opKeyForGoal];

                    // Prioritize special rules if they exist
                    if (opCompany === 'JN' && specialRule) {
                        const allAccounts = [...new Set(rawDataJn.map(r => r.accountName))];
                        const matchingAccounts = allAccounts.filter(acc => {
                            const upperAcc = acc.toUpperCase();
                            return specialRule.every(keywordGroup =>
                                keywordGroup.every(kw => upperAcc.includes(kw.toUpperCase()))
                            );
                        });

                        if (matchingAccounts.length > 0) {
                            const dateObj = parseDate(dateStr);
                            const formattedDateForAccountData = `${dateObj.getFullYear()}-${(dateObj.getUTCMonth() + 1).toString().padStart(2, '0')}-${dateObj.getUTCDate().toString().padStart(2, '0')}`;
                            const accountDataForDay = filteredDataJn.filter(r => r.day === formattedDateForAccountData && matchingAccounts.includes(r.accountName));

                            if (accountDataForDay.length > 0) {
                                const sums = accountDataForDay.reduce((acc, row) => {
                                    acc.spend += row.spend; acc.impressions += row.impressions; acc.clicks += row.clicks; acc.conversions += row.conversions; return acc;
                                }, { spend: 0, impressions: 0, clicks: 0, conversions: 0 });
                                const mainOpData = dataOnlyTotal.find(r => r.operacao === opName && r.data === dateStr);
                                const receita = mainOpData ? mainOpData.receita : 0;
                                metricsForDay = {
                                    investimento: sums.spend, roas: sums.spend > 0 ? receita / sums.spend : 0,
                                    ctr: sums.impressions > 0 ? (sums.clicks / sums.impressions) * 100 : 0,
                                    cvr: sums.clicks > 0 ? (sums.conversions / sums.clicks) * 100 : 0,
                                    cpm: sums.impressions > 0 ? (sums.spend / sums.impressions) * 1000 : 0,
                                    cpa: sums.conversions > 0 ? sums.spend / sums.conversions : 0,
                                };
                            }
                        }
                    } else if (opCompany === 'JN' || opCompany === 'MG') { // Default logic for other JN/MG
                        const opKeywordsRaw = opKeyForGoal.split(' ');
                        const searchKeywords = opKeywordsRaw.slice(1).filter(kw => KNOWN_KEYWORDS.has(kw.toUpperCase()));
                        const sourceData = opCompany === 'JN' ? rawDataJn : rawDataMg;
                        const filteredSourceData = opCompany === 'JN' ? filteredDataJn : filteredDataMg;
                        const allAccounts = [...new Set(sourceData.map(r => r.accountName))];

                        const matchingAccounts = allAccounts.filter(acc => {
                            const upperAcc = acc.toUpperCase();
                            if (searchKeywords.length === 0) return true;
                            return searchKeywords.every(kw => {
                                const expandedKws = KEYWORD_MAP[kw.toUpperCase()];
                                if (expandedKws) {
                                    return expandedKws.some(expandedKw => upperAcc.includes(expandedKw));
                                }
                                return upperAcc.includes(kw.toUpperCase());
                            });
                        });

                        if (matchingAccounts.length > 0) {
                            const dateObj = parseDate(dateStr);
                            const formattedDateForAccountData = `${dateObj.getFullYear()}-${(dateObj.getUTCMonth() + 1).toString().padStart(2, '0')}-${dateObj.getUTCDate().toString().padStart(2, '0')}`;
                            const accountDataForDay = filteredSourceData.filter(r => r.day === formattedDateForAccountData && matchingAccounts.includes(r.accountName));

                            if (accountDataForDay.length > 0) {
                                const sums = accountDataForDay.reduce((acc, row) => {
                                    acc.spend += row.spend; acc.impressions += row.impressions; acc.clicks += row.clicks; acc.conversions += row.conversions; return acc;
                                }, { spend: 0, impressions: 0, clicks: 0, conversions: 0 });
                                const mainOpData = dataOnlyTotal.find(r => r.operacao === opName && r.data === dateStr);
                                const receita = mainOpData ? mainOpData.receita : 0;
                                metricsForDay = {
                                    investimento: sums.spend, roas: sums.spend > 0 ? receita / sums.spend : 0,
                                    ctr: sums.impressions > 0 ? (sums.clicks / sums.impressions) * 100 : 0,
                                    cvr: sums.clicks > 0 ? (sums.conversions / sums.clicks) * 100 : 0,
                                    cpm: sums.impressions > 0 ? (sums.spend / sums.impressions) * 1000 : 0,
                                    cpa: sums.conversions > 0 ? sums.spend / sums.conversions : 0,
                                };
                            }
                        }
                    }

                    if (metricsForDay.investimento === 0) { // Fallback if primary method fails or for non JN/MG
                        const mainOpData = dataOnlyTotal.find(r => r.operacao === opName && r.data === dateStr);
                        if (mainOpData) {
                            metricsForDay.investimento = mainOpData.gasto;
                            metricsForDay.roas = mainOpData.gasto > 0 ? mainOpData.receita / mainOpData.gasto : 0;
                            metricsForDay.cpa = mainOpData.cpa;
                        }
                    }
                    dailyData[dateStr] = metricsForDay;
                });

                let rowsHTML = '';
                metrics.forEach((metric, metricIndex) => {
                    const goal = OPERATIONAL_GOALS[opKeyForGoal]?.[metric.key];
                    const isFirstRow = metricIndex === 0;

                    rowsHTML += `<tr class="metric-row ${isFirstRow && opIndex > 0 ? 'metric-group-start' : ''}">`;
                    if (isFirstRow) {
                        rowsHTML += `<td class="op-name-cell" rowspan="${metrics.length}">${opKeyForGoal}</td>`;
                        rowsHTML += `<td class="platform-cell-container" rowspan="${metrics.length}"><span class="platform-cell">${getPlatformFromOperation(opName)}</span></td>`;
                    }
                    rowsHTML += `<td class="metric-name-cell">${metric.label}</td>`;
                    rowsHTML += `<td class="goal-cell">${goal !== undefined ? (metric.key === 'roas' ? (goal * 100).toFixed(0) + '%+' : (metric.key === 'ctr' || metric.key === 'cvr' ? goal.toFixed(0) + '%+' : metric.format(goal, opName))) : '-'}</td>`;

                    last7Dates.forEach(date => {
                        const value = dailyData[date]?.[metric.key];
                        let cellContent = metric.format(0, opName);
                        if (metric.key === 'roas') cellContent = '-100.00%';

                        if (value !== undefined && !isNaN(value)) {
                            if (value !== 0 || metric.key === 'roas') {
                                cellContent = metric.format(value, opName);
                            }
                        }

                        let cellClass = '';
                        if (metric.key === 'roas' && goal !== undefined && value !== undefined) {
                            cellClass = (value - 1) >= goal ? 'goal-value positive' : 'goal-value negative';
                        } else if ((metric.key === 'ctr' || metric.key === 'cvr') && goal !== undefined && value > 0) {
                            cellClass = value >= goal ? 'goal-value positive' : 'goal-value negative';
                        }
                        rowsHTML += `<td class="${cellClass}">${cellContent}</td>`;
                    });
                    rowsHTML += `</tr>`;
                });
                tableHTML += rowsHTML;
            });

            tableHTML += `</tbody></table>`;
            container.innerHTML = warningHTML + tableHTML;
        }


        window.addEventListener('load', () => {
            loadAllData();
            setupMetricToggle();
            setupNavbar();
        });
        // --- INÍCIO DA NOVA FUNÇÃO PARA RENDERIZAR O FUNIL ---
        // --- INÍCIO DA NOVA FUNÇÃO PARA RENDERIZAR O FUNIL (VERSÃO FINAL COM SVG) ---
        // --- INÍCIO DA FUNÇÃO DO FUNIL CORRIGIDA (VERSÃO 4 - TAXAS CORRETAS) ---
        // --- INÍCIO DA FUNÇÃO DO FUNIL CORRIGIDA (VERSÃO 5 - COM SÍMBOLO %) ---
        function renderAccountFunnel(containerId, sourceData, accountName) {
            const container = document.getElementById(containerId);
            if (!container) return;

            if (!accountName) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const accountData = sourceData.filter(r => r.accountName === accountName);

            if (accountData.length === 0) {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            const totals = accountData.reduce((acc, row) => {
                acc.impressions += row.impressions;
                acc.clicks += row.clicks;
                acc.conversions += row.conversions;
                return acc;
            }, { impressions: 0, clicks: 0, conversions: 0 });

            const ctr = totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0;
            const cvr = totals.clicks > 0 ? (totals.conversions / totals.clicks) * 100 : 0;

            // --- Lógica de Desenho do SVG ---
            const svgWidth = 500;
            const svgHeight = 240;
            const sectionHeight = svgHeight / 3;

            const funnelTopWidth = svgWidth;
            const funnelBottomWidth = svgWidth * 0.3;

            const topX = 0;
            const topRightX = funnelTopWidth;

            const mid1_LeftX = (funnelTopWidth - (funnelTopWidth * 0.75)) / 2;
            const mid1_RightX = funnelTopWidth - mid1_LeftX;

            const mid2_LeftX = (funnelTopWidth - (funnelTopWidth * 0.52)) / 2;
            const mid2_RightX = funnelTopWidth - mid2_LeftX;

            const bottomX = (funnelTopWidth - funnelBottomWidth) / 2;
            const bottomRightX = funnelTopWidth - bottomX;

            const funnelHTML = `
        <div class="funnel-wrapper">
            <h3>Funil de Conversão - ${accountName}</h3>
            <svg class="funnel-svg" viewBox="0 0 ${svgWidth + 100} ${svgHeight}" preserveAspectRatio="xMidYMid meet">
                
                <g class="funnel-section-group">
                    <title>Total de Impressões</title>
                    <polygon class="funnel-polygon" points="${topX},0 ${topRightX},0 ${mid1_RightX},${sectionHeight} ${mid1_LeftX},${sectionHeight}" fill="#6a82fb" />
                    <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight / 2 - 10}">Impressões</text>
                    <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight / 2 + 25}">${totals.impressions.toLocaleString('pt-BR')}</text>
                </g>

                <g class="funnel-section-group">
                    <title>CTR (Taxa de Clique): ${ctr.toFixed(2)}%</title>
                    <polygon class="funnel-polygon" points="${mid1_LeftX},${sectionHeight} ${mid1_RightX},${sectionHeight} ${mid2_RightX},${sectionHeight * 2} ${mid2_LeftX},${sectionHeight * 2}" fill="#5087f8" />
                    <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight * 1.5 - 10}">Cliques</text>
                    <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight * 1.5 + 25}">${totals.clicks.toLocaleString('pt-BR')}</text>
                </g>

                <g class="funnel-section-group">
                    <title>CVR (Taxa de Conversão): ${cvr.toFixed(2)}%</title>
                    <polygon class="funnel-polygon" points="${mid2_LeftX},${sectionHeight * 2} ${mid2_RightX},${sectionHeight * 2} ${bottomRightX},${svgHeight} ${bottomX},${svgHeight}" fill="#3478e8" />
                    <text class="funnel-label" x="${svgWidth / 2}" y="${sectionHeight * 2.5 - 10}">Conversões</text>
                    <text class="funnel-value" x="${svgWidth / 2}" y="${sectionHeight * 2.5 + 25}">${totals.conversions.toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 2 })}</text>
                </g>

                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#adb5bd" />
                    </marker>
                </defs>

                <path class="funnel-loss-arrow" d="M ${topRightX + 15} ${sectionHeight * 0.4} Q ${topRightX + 55} ${sectionHeight * 0.9}, ${mid1_RightX + 15} ${sectionHeight * 1.4}" marker-end="url(#arrowhead)"></path>
                <text class="funnel-loss-text" x="${topRightX + 65}" y="${sectionHeight}">
                    ${ctr.toFixed(1)}%
                </text>

                <path class="funnel-loss-arrow" d="M ${mid1_RightX + 15} ${sectionHeight * 1.4} Q ${mid1_RightX + 45} ${sectionHeight * 1.9}, ${mid2_RightX + 15} ${sectionHeight * 2.4}" marker-end="url(#arrowhead)"></path>
                 <text class="funnel-loss-text" x="${mid1_RightX + 55}" y="${sectionHeight * 2}">
                    ${cvr.toFixed(1)}%
                </text>
            </svg>
        </div>
    `;

            container.innerHTML = funnelHTML;
            container.style.display = 'block';
        }
        // ADICIONE ESTA NOVA FUNÇÃO AO SEU JAVASCRIPT

        function populateAdopsFilter(data) {
            const trigger = document.getElementById('adops-select-trigger');
            const optionsContainer = document.getElementById('adops-select-options');
            const optionsList = document.getElementById('adops-options-list');
            const searchInput = document.getElementById('adops-search-input');
            if (!trigger || !optionsList) return;

            optionsList.innerHTML = '';
            const adopsList = [...new Set(data.map(r => r.responsavelMonetizacao).filter(Boolean))].sort();

            adopsList.forEach(adops => {
                const id = `adops-opt-${adops.replace(/\s+/g, '')}`;
                const isChecked = selectedAdopsForChart.includes(adops) ? 'checked' : '';
                const optionHTML = `<label for="${id}"><input type="checkbox" id="${id}" value="${adops}" ${isChecked}> ${adops}</label>`;
                optionsList.innerHTML += optionHTML;
            });

            trigger.addEventListener('click', () => optionsContainer.classList.toggle('open'));

            searchInput.addEventListener('keyup', () => {
                const filter = searchInput.value.toLowerCase();
                optionsList.querySelectorAll('label').forEach(label => {
                    label.style.display = label.textContent.toLowerCase().includes(filter) ? '' : 'none';
                });
            });

            optionsList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    selectedAdopsForChart = adopsList.filter(m => {
                        const cb = document.getElementById(`adops-opt-${m.replace(/\s+/g, '')}`);
                        return cb && cb.checked;
                    });

                    if (selectedAdopsForChart.length === 0) {
                        trigger.textContent = 'Selecione...';
                    } else if (selectedAdopsForChart.length === 1) {
                        trigger.textContent = selectedAdopsForChart[0];
                    } else {
                        trigger.textContent = `${selectedAdopsForChart.length} AdOps selecionados`;
                    }
                    filterAndRenderAll(); // Atualiza o dashboard
                });
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('#adops-select-container')) {
                    optionsContainer.classList.remove('open');
                }
            });
        }
        // ADICIONE ESTA NOVA FUNÇÃO AO SEU JAVASCRIPT

        function renderAdopsEvolutionChart(data) {
            const canvasId = 'adopsEvolutionChart';
            const hasSelection = selectedAdopsForChart.length > 0;

            let chartData = { labels: [], datasets: [] };
            let chartOptions = {};
            const placeholderPlugin = {
                id: 'adopsEmptyChartMessage',
                afterDraw: chart => {
                    if (chart.data.datasets.length === 0) {
                        let ctx = chart.ctx;
                        let width = chart.width;
                        let height = chart.height;
                        chart.clear();
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = "16px sans-serif";
                        ctx.fillStyle = '#6c757d';
                        ctx.fillText('Selecione um ou mais AdOps para visualizar a evolução do ROAS.', width / 2, height / 2);
                        ctx.restore();
                    }
                }
            };

            if (hasSelection) {
                const dailyDataByAdops = {};
                const allDates = new Set();

                data.filter(row => selectedAdopsForChart.includes(row.responsavelMonetizacao) && row.data).forEach(row => {
                    allDates.add(row.data);
                    const adops = row.responsavelMonetizacao;
                    if (!dailyDataByAdops[adops]) dailyDataByAdops[adops] = {};
                    if (!dailyDataByAdops[adops][row.data]) {
                        dailyDataByAdops[adops][row.data] = { gasto: 0, receita: 0 };
                    }
                    dailyDataByAdops[adops][row.data].gasto += row.gasto;
                    dailyDataByAdops[adops][row.data].receita += row.receita;
                });

                const sortedLabels = Array.from(allDates).sort((a, b) => parseDate(a) - parseDate(b));
                const datasets = [];
                const colors = ['#20c997', '#fd7e14', '#3498db', '#9b59b6', '#e74c3c', '#f1c40f'];

                selectedAdopsForChart.forEach((adops, index) => {
                    const color = colors[index % colors.length];
                    const adopsDailyData = dailyDataByAdops[adops] || {};

                    const gastoData = sortedLabels.map(date => adopsDailyData[date]?.gasto ?? null);
                    const roasData = sortedLabels.map(date => {
                        const dayData = adopsDailyData[date];
                        return (dayData && dayData.gasto > 0) ? (dayData.receita / dayData.gasto) : null;
                    });

                    datasets.push({
                        label: `Gasto (${adops})`, data: gastoData, borderColor: color,
                        yAxisID: 'yGasto', tension: 0.4, borderWidth: 2.5, backgroundColor: color,
                        pointRadius: 4, pointHoverRadius: 7, borderDash: [5, 5]
                    });
                    datasets.push({
                        label: `ROAS (${adops})`, data: roasData, borderColor: color,
                        yAxisID: 'yRoas', tension: 0.4, borderWidth: 2, backgroundColor: color,
                        pointRadius: 4, pointHoverRadius: 7
                    });
                });

                const subtitleText = 'AdOps: ' + selectedAdopsForChart.join(', ');

                chartData = { labels: sortedLabels, datasets };
                chartOptions = {
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        datalabels: { display: false },
                        subtitle: { display: true, text: subtitleText, align: 'start', padding: { bottom: 20 }, font: { size: 14, style: 'italic' }, color: '#6c757d' }
                    },
                    scales: {
                        x: { ticks: { autoSkip: true, maxTicksLimit: 15 } },
                        yGasto: { type: 'linear', position: 'left', title: { display: true, text: 'Investimento Gerenciado (R$)' }, ticks: { callback: (v) => formatKilo(v) } },
                        yRoas: { type: 'linear', position: 'right', title: { display: true, text: 'ROAS (x)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) + 'x' } }
                    }
                };
            }

            createOrUpdateChart(canvasId, 'line', chartData, chartOptions, [placeholderPlugin]);
        }

        // --- FUNÇÕES PARA ANÁLISE DE CORRELAÇÃO ---

        function populateCorrelationFilters() {
            const accSelect = document.getElementById('correlationAccountFilter');
            const metricXSelect = document.getElementById('correlationMetricX');
            const metricYSelect = document.getElementById('correlationMetricY');

            // Popula contas com base nos dados de JN e MG
            const jnAccounts = [...new Set(rawDataJn.map(r => r.accountName))];
            const mgAccounts = [...new Set(rawDataMg.map(r => r.accountName))];
            const allAccounts = [...jnAccounts, ...mgAccounts].sort();

            accSelect.innerHTML = '<option value="">-- Selecione uma Conta --</option>' + allAccounts.map(acc => `<option value="${acc}">${acc}</option>`).join('');

            // Popula métricas disponíveis nos dados detalhados
            const metrics = [
                { key: 'spend', label: 'Gasto' },
                { key: 'cpa', label: 'CPA' },
                { key: 'cpm', label: 'CPM' },
                { key: 'cpc', label: 'CPC' },
                { key: 'ctr', label: 'CTR (%)' },
                { key: 'convRate', label: 'Taxa de Conversão (%)' },
                { key: 'impressions', label: 'Impressões' },
                { key: 'clicks', label: 'Cliques' },
                { key: 'conversions', label: 'Conversões' }
            ];
            const metricOptions = metrics.map(m => `<option value="${m.key}">${m.label}</option>`).join('');
            metricXSelect.innerHTML = metricOptions;
            metricYSelect.innerHTML = metricOptions;

            // Define padrões
            metricXSelect.value = 'cpa';
            metricYSelect.value = 'ctr';
        }

        function renderCorrelationChart() {
            const accountName = document.getElementById('correlationAccountFilter').value;
            const metricXKey = document.getElementById('correlationMetricX').value;
            const metricYKey = document.getElementById('correlationMetricY').value;
            const resultText = document.getElementById('correlation-result-text');
            const explanationBox = document.getElementById('correlation-explanation-box');

            // Esconde a explicação e limpa o gráfico se nada for selecionado
            explanationBox.style.display = 'none';
            if (!accountName || !metricXKey || !metricYKey) {
                resultText.textContent = "Selecione uma conta e as métricas para começar.";
                if (charts['correlationChart']) charts['correlationChart'].destroy();
                return;
            }

            // Usa a fonte de dados correta (JN ou MG)
            const sourceData = rawDataJn.some(r => r.accountName === accountName) ? rawDataJn : rawDataMg;
            const dataPoints = sourceData
                .filter(row => row.accountName === accountName)
                .map(row => ({ x: row[metricXKey], y: row[metricYKey] }))
                .filter(p => isFinite(p.x) && isFinite(p.y) && p.x > 0 && p.y > 0);

            if (dataPoints.length < 3) { // Aumentado para 3 para uma correlação minimamente útil
                resultText.textContent = "Não há dados diários suficientes para calcular a correlação.";
                if (charts['correlationChart']) charts['correlationChart'].destroy();
                return;
            }

            // Cálculos estatísticos
            const { x, y } = dataPoints.reduce((acc, p) => ({ x: [...acc.x, p.x], y: [...acc.y, p.y] }), { x: [], y: [] });
            const { slope, intercept } = linearRegression(y, x);
            const correlation = pearsonCorrelation(x, y);

            // Texto de resultado
            let strength = "muito fraca";
            if (Math.abs(correlation) >= 0.7) strength = "forte";
            else if (Math.abs(correlation) >= 0.4) strength = "moderada";
            else if (Math.abs(correlation) >= 0.2) strength = "fraca";
            const direction = correlation >= 0 ? "positiva" : "negativa";
            resultText.innerHTML = `Coeficiente de Correlação (r): <strong>${correlation.toFixed(3)}</strong> <br> Relação ${direction} ${strength}.`;

            // Linha de tendência
            const minX = Math.min(...x);
            const maxX = Math.max(...x);
            const trendlinePoints = [{ x: minX, y: slope * minX + intercept }, { x: maxX, y: slope * maxX + intercept }];

            // Cria o gráfico
            createOrUpdateChart('correlationChart', 'scatter', {
                datasets: [{
                    label: 'Dados Diários', data: dataPoints, backgroundColor: hexToRgba(REGION_COLORS.all.investment, 0.7),
                }, {
                    label: 'Linha de Tendência', data: trendlinePoints, type: 'line',
                    backgroundColor: 'transparent', borderColor: '#e74c3c', borderWidth: 2, pointRadius: 0,
                }]
            }, {
                scales: {
                    x: { title: { display: true, text: document.getElementById('correlationMetricX').options[document.getElementById('correlationMetricX').selectedIndex].text } },
                    y: { title: { display: true, text: document.getElementById('correlationMetricY').options[document.getElementById('correlationMetricY').selectedIndex].text } }
                }
            });

            // --- GERA A EXPLICAÇÃO DINÂMICA ---
            const metricXLabel = document.getElementById('correlationMetricX').options[document.getElementById('correlationMetricX').selectedIndex].text;
            const metricYLabel = document.getElementById('correlationMetricY').options[document.getElementById('correlationMetricY').selectedIndex].text;
            let directionText, strengthText;

            if (direction === 'positiva') {
                directionText = `A relação é <strong>positiva</strong>. Isso significa que, em geral, quando <strong>${metricXLabel}</strong> sobe, a <strong>${metricYLabel}</strong> também tende a subir.`;
            } else {
                directionText = `A relação é <strong>negativa</strong>. Isso significa que, em geral, quando <strong>${metricXLabel}</strong> sobe, a <strong>${metricYLabel}</strong> tende a descer.`;
            }

            if (strength === "forte") {
                strengthText = `A força <strong>"forte"</strong> (r acima de 0.7 ou abaixo de -0.7) indica que as duas métricas estão fortemente conectadas. A mudança em uma é um bom indicador da mudança na outra.`;
            } else if (strength === "moderada") {
                strengthText = `A força <strong>"moderada"</strong> (r entre 0.4 e 0.7) sugere uma tendência clara, mas outros fatores também estão influenciando o resultado.`;
            } else { // Fraca ou Muito Fraca
                strengthText = `A força <strong>"fraca"</strong> (r abaixo de 0.4) sugere que há pouca ou nenhuma conexão linear entre as métricas. Mudanças em uma não explicam bem as mudanças na outra.`;
            }

            explanationBox.innerHTML = `
        <h4>💡 Interpretando o Resultado</h4>
        <p>${directionText}</p>
        <p>${strengthText}</p>
        <p><strong>Importante:</strong> Correlação não significa causalidade. Só porque duas métricas se movem juntas, não significa que uma <i>causa</i> a outra. Podem existir outros fatores não analisados influenciando o resultado.</p>
    `;
            explanationBox.style.display = 'block';
        }
        // --- FUNÇÃO PARA O GRÁFICO DE PREVISÃO AVANÇADA ---
        // --- FUNÇÃO CORRIGIDA PARA O GRÁFICO DE PREVISÃO AVANÇADA ---

        function renderAdvancedForecastChart() {
            const historicalAggregates = filteredData
                .filter(row => row.operacao && !row.operacao.toUpperCase().endsWith('TOTAL'))
                .reduce((acc, row) => {
                    if (!row.data) return acc;
                    const date = parseDate(row.data);
                    if (!date) return acc;
                    const dateKey = date.toISOString().split('T')[0];
                    if (!acc[dateKey]) acc[dateKey] = { gasto: 0, receita: 0 };
                    acc[dateKey].gasto += row.gasto;
                    acc[dateKey].receita += row.receita;
                    return acc;
                }, {});

            const sortedHistoricalDates = Object.keys(historicalAggregates).sort();

            if (sortedHistoricalDates.length === 0 || rawDataForecast.length === 0) {
                // Limpa o gráfico e a análise se não houver dados
                if (charts['advancedForecastChart']) charts['advancedForecastChart'].destroy();
                document.getElementById('forecast-text-analysis').style.display = 'none';
                return;
            }

            const historicalLabels = sortedHistoricalDates.map(dateStr => formatDate(new Date(dateStr + 'T00:00:00Z')));
            const historicalGasto = sortedHistoricalDates.map(dateStr => historicalAggregates[dateStr].gasto);
            const historicalReceita = sortedHistoricalDates.map(dateStr => historicalAggregates[dateStr].receita);

            const forecastLabels = rawDataForecast.map(row => formatDate(row.data));
            const forecastGasto = rawDataForecast.map(row => row.gasto);
            const forecastReceita = rawDataForecast.map(row => row.receita);

            const lastHistoricalGasto = historicalGasto[historicalGasto.length - 1];
            const lastHistoricalReceita = historicalReceita[historicalReceita.length - 1];

            const allLabels = [...historicalLabels, ...forecastLabels];
            const combinedGasto = [...historicalGasto.slice(0, -1), lastHistoricalGasto, ...forecastGasto];
            const combinedReceita = [...historicalReceita.slice(0, -1), lastHistoricalReceita, ...forecastReceita];

            const historicalDataCount = historicalLabels.length;

            createOrUpdateChart('advancedForecastChart', 'line', {
                labels: allLabels,
                datasets: [{
                    label: 'Gasto (Real + Previsão)', data: combinedGasto, borderColor: '#6a82fb',
                    backgroundColor: hexToRgba('#6a82fb', 0.1), fill: true, tension: 0.3,
                    segment: { borderDash: ctx => ctx.p1DataIndex >= historicalDataCount - 1 ? [6, 6] : undefined }
                }, {
                    label: 'Receita (Real + Previsão)', data: combinedReceita, borderColor: '#20c997',
                    backgroundColor: 'transparent', tension: 0.3,
                    segment: { borderDash: ctx => ctx.p1DataIndex >= historicalDataCount - 1 ? [6, 6] : undefined }
                }]
            }, {
                plugins: { tooltip: { callbacks: { label: function (context) { let label = context.dataset.label.split(' (')[0]; const isForecast = context.dataIndex >= historicalDataCount; label += isForecast ? ' (Previsão): ' : ' (Real): '; label += formatCurrency(context.parsed.y); return label; } } } },
                scales: { y: { ticks: { callback: v => formatKilo(v) } } }
            });

            // ==========================================================
            // --- INÍCIO DA NOVA LÓGICA DE ANÁLISE DE TEXTO ---
            // ==========================================================
            const analysisBox = document.getElementById('forecast-text-analysis');
            let analysisPoints = [];

            // 1. Análise da Tendência Imediata
            const firstForecastSpend = forecastGasto[0];
            const spendChange = ((firstForecastSpend / lastHistoricalGasto) - 1) * 100;
            let immediateTrendText = `A previsão inicia com tendência de <strong>estabilidade</strong>, projetando um gasto de <strong>${formatCurrency(firstForecastSpend)}</strong> para o próximo dia, similar aos <strong>${formatCurrency(lastHistoricalGasto)}</strong> do último dia real.`;
            if (spendChange > 5) {
                immediateTrendText = `A previsão aponta para uma <strong>tendência de alta</strong> imediata, projetando um gasto de <strong>${formatCurrency(firstForecastSpend)}</strong> para o próximo dia, um aumento de <strong>${spendChange.toFixed(0)}%</strong> sobre os <strong>${formatCurrency(lastHistoricalGasto)}</strong> do último dia real.`;
            } else if (spendChange < -5) {
                immediateTrendText = `A previsão aponta para uma <strong>tendência de baixa</strong> imediata, projetando um gasto de <strong>${formatCurrency(firstForecastSpend)}</strong> para o próximo dia, uma queda de <strong>${Math.abs(spendChange).toFixed(0)}%</strong> sobre os <strong>${formatCurrency(lastHistoricalGasto)}</strong> do último dia real.`;
            }
            analysisPoints.push(immediateTrendText);

            // 2. Análise da Média Semanal
            const avgHistoricalSpend = historicalGasto.slice(-7).reduce((a, b) => a + b, 0) / 7;
            const avgForecastSpend = forecastGasto.slice(0, 7).reduce((a, b) => a + b, 0) / 7;
            const weeklyChange = ((avgForecastSpend / avgHistoricalSpend) - 1) * 100;
            analysisPoints.push(`A média de gasto para os próximos 7 dias está projetada em <strong>${formatCurrency(avgForecastSpend)}</strong> por dia, uma variação de <strong>${weeklyChange.toFixed(1)}%</strong> em relação à média da última semana (<strong>${formatCurrency(avgHistoricalSpend)}</strong>).`);

            // 3. Análise do Ritmo Mensal (Pacing)
            const today = new Date();
            const currentMonth = today.getMonth();
            const monthToDateSpend = historicalGasto.filter((_, i) => new Date(sortedHistoricalDates[i]).getMonth() === currentMonth).reduce((a, b) => a + b, 0);
            const remainingForecastSpend = forecastGasto.filter((_, i) => rawDataForecast[i].data.getMonth() === currentMonth).reduce((a, b) => a + b, 0);
            const fullMonthProjectedSpend = monthToDateSpend + remainingForecastSpend;
            analysisPoints.push(`Mantendo o ritmo atual mais a previsão, o gasto total projetado para o final deste mês é de aproximadamente <strong>${formatKilo(fullMonthProjectedSpend)}</strong>.`);

            // 4. Análise do Padrão Semanal
            const dayNames = ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"];
            const dailyForecasts = forecastGasto.slice(0, 7).map((value, i) => ({ day: dayNames[rawDataForecast[i].data.getDay()], value }));
            const maxDay = dailyForecasts.reduce((prev, current) => (prev.value > current.value) ? prev : current);
            const minDay = dailyForecasts.reduce((prev, current) => (prev.value < current.value) ? prev : current);
            analysisPoints.push(`O modelo identificou um padrão semanal nos seus dados, projetando <strong>${maxDay.day}</strong> como o dia de maior investimento e <strong>${minDay.day}</strong> como o de menor atividade na próxima semana.`);

            // Monta o HTML final e exibe a caixa
            analysisBox.innerHTML = `
        <h4>📝 Análise da Previsão</h4>
        <ul>
            ${analysisPoints.map(point => `<li>${point}</li>`).join('')}
        </ul>
    `;
            analysisBox.style.display = 'block';
        }

        // Funções de cálculo estatístico
        function linearRegression(y, x) {
            const n = y.length;
            let sum_x = 0, sum_y = 0, sum_xy = 0, sum_xx = 0;
            for (let i = 0; i < y.length; i++) {
                sum_x += x[i];
                sum_y += y[i];
                sum_xy += (x[i] * y[i]);
                sum_xx += (x[i] * x[i]);
            }
            const slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
            const intercept = (sum_y - slope * sum_x) / n;
            return { slope, intercept };
        }

        function pearsonCorrelation(x, y) {
            const n = x.length;
            const meanX = x.reduce((a, b) => a + b) / n;
            const meanY = y.reduce((a, b) => a + b) / n;
            const stdDevX = Math.sqrt(x.map(val => (val - meanX) ** 2).reduce((a, b) => a + b) / n);
            const stdDevY = Math.sqrt(y.map(val => (val - meanY) ** 2).reduce((a, b) => a + b) / n);
            let covariance = 0;
            for (let i = 0; i < n; i++) {
                covariance += (x[i] - meanX) * (y[i] - meanY);
            }
            covariance /= n;
            return covariance / (stdDevX * stdDevY);
        }
        // --- (Adicione estas funções junto com as outras de renderização de gráficos, como renderManagerCharts) ---

        function populateManagerFilter(data) {
            const trigger = document.getElementById('manager-select-trigger');
            const optionsContainer = document.getElementById('manager-select-options');
            const optionsList = document.getElementById('manager-options-list');
            const searchInput = document.getElementById('manager-search-input');
            if (!trigger || !optionsList) return;

            optionsList.innerHTML = ''; // Limpa antes de popular
            const managers = [...new Set(data.map(r => r.responsavelAquisicao).filter(Boolean))]
                .filter(m => !EXCLUDED_MANAGERS.includes(m.toUpperCase()))
                .sort();

            managers.forEach(manager => {
                const id = `manager-opt-${manager.replace(/\s+/g, '')}`;
                const isChecked = selectedManagersForChart.includes(manager) ? 'checked' : '';
                const optionHTML = `
            <label for="${id}">
                <input type="checkbox" id="${id}" value="${manager}" ${isChecked}>
                ${manager}
            </label>
        `;
                optionsList.innerHTML += optionHTML;
            });

            // --- Lógica do seletor customizado ---
            trigger.addEventListener('click', () => optionsContainer.classList.toggle('open'));

            searchInput.addEventListener('keyup', () => {
                const filter = searchInput.value.toLowerCase();
                optionsList.querySelectorAll('label').forEach(label => {
                    const text = label.textContent.toLowerCase();
                    label.style.display = text.includes(filter) ? '' : 'none';
                });
            });

            optionsList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    selectedManagersForChart = managers.filter(m => {
                        const cb = document.getElementById(`manager-opt-${m.replace(/\s+/g, '')}`);
                        return cb && cb.checked;
                    });

                    if (selectedManagersForChart.length === 0) {
                        trigger.textContent = 'Selecione...';
                    } else if (selectedManagersForChart.length === 1) {
                        trigger.textContent = selectedManagersForChart[0];
                    } else {
                        trigger.textContent = `${selectedManagersForChart.length} gestores selecionados`;
                    }
                    filterAndRenderAll(); // Atualiza o dashboard
                });
            });

            // Fecha o dropdown se clicar fora
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.custom-select')) {
                    optionsContainer.classList.remove('open');
                }
            });
        }
        function renderManagerEvolutionChart(data) {
            const canvasId = 'gestorEvolucaoDiariaChart';
            const hasSelection = selectedManagersForChart.length > 0;

            let chartData = { labels: [], datasets: [] };
            let chartOptions = {};

            // Plugin para exibir a mensagem placeholder (mockup) quando não há seleção
            const placeholderPlugin = {
                id: 'emptyChartMessage',
                afterDraw: chart => {
                    if (chart.data.datasets.length === 0) {
                        let ctx = chart.ctx;
                        let width = chart.width;
                        let height = chart.height;
                        chart.clear();

                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.font = "16px sans-serif";
                        ctx.fillStyle = '#6c757d';
                        ctx.fillText('Selecione um ou mais gestores para visualizar a evolução.', width / 2, height / 2);
                        ctx.restore();
                    }
                }
            };

            if (hasSelection) {
                const dailyDataByManager = {};
                const allDates = new Set();

                data.filter(row => selectedManagersForChart.includes(row.responsavelAquisicao) && row.data).forEach(row => {
                    allDates.add(row.data);
                    const manager = row.responsavelAquisicao;
                    if (!dailyDataByManager[manager]) dailyDataByManager[manager] = {};
                    if (!dailyDataByManager[manager][row.data]) {
                        dailyDataByManager[manager][row.data] = { gasto: 0, receita: 0, leads: 0 };
                    }
                    dailyDataByManager[manager][row.data].gasto += row.gasto;
                    dailyDataByManager[manager][row.data].receita += row.receita;
                    dailyDataByManager[manager][row.data].leads += row.leads;
                });

                const sortedLabels = Array.from(allDates).sort((a, b) => parseDate(a) - parseDate(b));
                const datasets = [];
                const colors = ['#6a82fb', '#764ba2', '#20c997', '#fd7e14', '#e74c3c', '#3498db', '#f1c40f'];

                selectedManagersForChart.forEach((manager, index) => {
                    const color = colors[index % colors.length];
                    const managerDailyData = dailyDataByManager[manager] || {};

                    const gastoData = sortedLabels.map(date => managerDailyData[date]?.gasto ?? null);
                    const roasData = sortedLabels.map(date => {
                        const dayData = managerDailyData[date];
                        return (dayData && dayData.gasto > 0) ? (dayData.receita / dayData.gasto) : null;
                    });
                    // 1. Cálculo do CPA
                    const cpaData = sortedLabels.map(date => {
                        const dayData = managerDailyData[date];
                        return (dayData && dayData.leads > 0) ? (dayData.gasto / dayData.leads) : null;
                    });

                    // 2. Adição dos datasets (incluindo CPA) e garantia dos pontos visíveis
                    datasets.push({
                        label: `Invest. (${manager})`, data: gastoData, borderColor: color,
                        yAxisID: 'yGasto', tension: 0.4, borderWidth: 2.5, spanGaps: true,
                        backgroundColor: color, pointRadius: 4, pointHoverRadius: 7 // Pontos visíveis
                    });
                    datasets.push({
                        label: `ROAS (${manager})`, data: roasData, borderColor: color,
                        borderDash: [5, 5], yAxisID: 'yRoas', tension: 0.4, borderWidth: 2, spanGaps: true,
                        backgroundColor: color, pointRadius: 4, pointHoverRadius: 7 // Pontos visíveis
                    });
                    datasets.push({
                        label: `CPA (${manager})`, data: cpaData, borderColor: color,
                        borderDash: [1, 3], yAxisID: 'yCpa', tension: 0.4, borderWidth: 1.5, spanGaps: true,
                        backgroundColor: color, pointRadius: 4, pointHoverRadius: 7 // Pontos visíveis
                    });
                });

                const subtitleText = 'Gestor(es): ' + selectedManagersForChart.join(', ');

                chartData = { labels: sortedLabels, datasets };
                chartOptions = {
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        // 3. Remoção dos números (data labels)
                        datalabels: {
                            display: false
                        },
                        subtitle: {
                            display: true,
                            text: subtitleText,
                            align: 'start',
                            padding: { bottom: 20 },
                            font: { size: 14, style: 'italic' },
                            color: '#6c757d'
                        }
                    },
                    scales: {
                        x: { ticks: { autoSkip: true, maxTicksLimit: 15 } },
                        yGasto: { type: 'linear', position: 'left', title: { display: true, text: 'Investimento (R$)' }, ticks: { callback: (v) => formatKilo(v) } },
                        yRoas: { type: 'linear', position: 'right', title: { display: true, text: 'ROAS (x)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) + 'x' }, afterFit: (scale) => { scale.width = 70; } },
                        // 4. Criação do novo eixo para o CPA
                        yCpa: { type: 'linear', position: 'right', title: { display: true, text: 'CPA (R$)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => formatCurrency(v), padding: 15 }, afterFit: (scale) => { scale.width = 80; } }
                    }
                };
            }

            createOrUpdateChart(canvasId, 'line', chartData, chartOptions, [placeholderPlugin]);
        }


        // SUBSTITUA TODAS AS FUNÇÕES DE COORDENAÇÃO POR ESTE BLOCO COMPLETO

        // SUBSTITUA A SUA FUNÇÃO 'renderCoordinationView' POR ESTA VERSÃO CORRIGIDA

        function renderCoordinationView(data) {
            const coordinators = selectedCoordinatorsForChart.length > 0 ? selectedCoordinatorsForChart : ['NICOLE', 'MARCELO', 'AMANDA'];

            // CORREÇÃO CRÍTICA AQUI: Adicionamos 'endsWithTOTAL(row.operacao)' para usar apenas as linhas de total
            const coordinationData = data.filter(row =>
                endsWithTOTAL(row.operacao) && // <-- ESTA LINHA CORRIGE O GRÁFICO
                row.coordenadorAquisicao &&
                coordinators.includes(row.coordenadorAquisicao.trim().toUpperCase())
            );

            const summary = {};
            const dailyData = {};
            const allDates = new Set();

            // Inicializa as estruturas de dados para todos os coordenadores selecionados
            coordinators.forEach(coord => {
                summary[coord] = { gasto: 0, receita: 0, leads: 0, activeDays: new Set(), operations: new Set() };
                dailyData[coord] = {};
            });

            // Processa os dados já filtrados
            coordinationData.forEach(row => {
                const coord = row.coordenadorAquisicao.trim().toUpperCase();
                if (summary[coord]) { // Garante que o coordenador está na lista a ser processada
                    summary[coord].gasto += row.gasto;
                    summary[coord].receita += row.receita;
                    summary[coord].leads += row.leads;
                    summary[coord].operations.add(row.operacao.replace(' TOTAL', ''));
                    if (row.data) {
                        summary[coord].activeDays.add(row.data);
                        allDates.add(row.data);
                        if (!dailyData[coord][row.data]) {
                            dailyData[coord][row.data] = { gasto: 0, receita: 0, leads: 0 };
                        }
                        dailyData[coord][row.data].gasto += row.gasto;
                        dailyData[coord][row.data].receita += row.receita;
                        dailyData[coord][row.data].leads += row.leads;
                    }
                }
            });

            const sortedLabels = Array.from(allDates).sort((a, b) => parseDate(a) - parseDate(b));

            renderCoordinatorSummaryCards(summary);
            renderCoordinatorSpendPieChart(summary);
            renderCoordinatorEvolutionChart(dailyData, sortedLabels, coordinators);
            renderCoordinatorOpsCountChart(summary);
            renderCoordinatorOpsList(summary); // Esta é a função que vamos melhorar a seguir
        }

        function renderCoordinatorSummaryCards(summaryData) {
            const container = document.getElementById('coordination-summary-cards');
            container.innerHTML = '';

            if (Object.keys(summaryData).every(coord => summaryData[coord].gasto === 0)) {
                container.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-light);">Nenhum dado de coordenação encontrado para o período ou filtros selecionados.</p>';
                return;
            }

            Object.entries(summaryData).forEach(([coord, data]) => {
                if (data.gasto > 0) { // Só mostra o card se houver gasto
                    const numDays = data.activeDays.size || 1;
                    const roasMedio = data.gasto > 0 ? data.receita / data.gasto : 0;
                    const cpaMedio = data.leads > 0 ? data.gasto / data.leads : 0;
                    const gastoMedioDiario = data.gasto / numDays;

                    const cardHTML = `
                <div class="regional-section">
                    <h3>👑 ${coord}</h3>
                    <div class="summary-cards" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                        ${createCardHTML({ icon: '💰', title: 'Gasto Total', value: formatCurrency(data.gasto) })}
                        ${createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roasMedio.toFixed(2)}x` })}
                        ${createCardHTML({ icon: '💸', title: 'CPA Médio', value: formatCurrency(cpaMedio) })}
                        ${createCardHTML({ icon: '👥', title: 'Leads Totais', value: data.leads.toLocaleString('pt-BR') })}
                    </div>
                </div>`;
                    container.innerHTML += cardHTML;
                }
            });
        }

        function renderCoordinatorSpendPieChart(summaryData) {
            const labels = Object.keys(summaryData).filter(coord => summaryData[coord].gasto > 0);
            const data = labels.map(coord => summaryData[coord].gasto);
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6'];

            createOrUpdateChart('coordinationSpendPieChart', 'pie', {
                labels, datasets: [{ data, backgroundColor: labels.map((_, i) => colors[i % colors.length]) }]
            }, {
                plugins: {
                    datalabels: { display: true, formatter: (v, ctx) => (ctx.chart.getDatasetMeta(0).total > 0 ? (v / ctx.chart.getDatasetMeta(0).total * 100).toFixed(1) + '%' : '0%'), color: '#fff', font: { weight: 'bold', size: 14 } }
                }
            });
        }

        function renderCoordinatorOpsCountChart(summaryData) {
            const labels = Object.keys(summaryData).filter(coord => summaryData[coord].operations.size > 0);
            const data = labels.map(coord => summaryData[coord].operations.size);
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6'];
            createOrUpdateChart('coordinationOpsCountChart', 'bar', {
                labels, datasets: [{ data, backgroundColor: labels.map((_, i) => colors[i % colors.length]) }]
            }, {
                indexAxis: 'y',
                plugins: {
                    legend: { display: false },
                    datalabels: { display: true, anchor: 'end', align: 'end', color: '#333', font: { weight: 'bold' } }
                },
                scales: { x: { display: false }, y: { grid: { display: false } } }
            });
        }

        function renderCoordinatorEvolutionChart(dailyDataByCoord, sortedLabels, coordinators) {
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6'];
            const datasets = [];

            coordinators.forEach((coord, index) => {
                const color = colors[index % colors.length];
                const dailyData = dailyDataByCoord[coord];

                if (!dailyData) return; // Pula se o coordenador não tiver dados

                const gastoData = sortedLabels.map(date => dailyData[date]?.gasto ?? null);
                const roasData = sortedLabels.map(date => (dailyData[date] && dailyData[date].gasto > 0) ? (dailyData[date].receita / dailyData[date].gasto) : null);
                const cpaData = sortedLabels.map(date => (dailyData[date] && dailyData[date].leads > 0) ? (dailyData[date].gasto / dailyData[date].leads) : null);

                datasets.push({ label: `Gasto (${coord})`, data: gastoData, borderColor: color, yAxisID: 'yGasto', tension: 0.4, borderWidth: 2.5, pointRadius: 3, pointHoverRadius: 6, backgroundColor: color });
                datasets.push({ label: `ROAS (${coord})`, data: roasData, borderColor: color, borderDash: [5, 5], yAxisID: 'yRoas', tension: 0.4, borderWidth: 2, pointRadius: 3, pointHoverRadius: 6, backgroundColor: color });
                datasets.push({ label: `CPA (${coord})`, data: cpaData, borderColor: color, borderDash: [1, 3], yAxisID: 'yCpa', tension: 0.4, borderWidth: 1.5, pointRadius: 3, pointHoverRadius: 6, backgroundColor: color });
            });

            createOrUpdateChart('coordinationEvolutionChart', 'line', { labels: sortedLabels, datasets }, {
                interaction: { mode: 'index', intersect: false },
                plugins: { datalabels: { display: false } },
                scales: {
                    x: { ticks: { autoSkip: true, maxTicksLimit: 10 } },
                    yGasto: { type: 'linear', position: 'left', title: { display: true, text: 'Gasto Diário (R$)' }, ticks: { callback: v => formatKilo(v) } },
                    yRoas: { type: 'linear', position: 'right', title: { display: true, text: 'ROAS (x)' }, grid: { drawOnChartArea: false }, ticks: { callback: v => v.toFixed(2) + 'x' }, afterFit: (s) => { s.width = 60; } },
                    yCpa: { type: 'linear', position: 'right', title: { display: true, text: 'CPA (R$)' }, grid: { drawOnChartArea: false }, ticks: { padding: 15, callback: v => formatCurrency(v) }, afterFit: (s) => { s.width = 70; } }
                }
            });
        }

        function renderCoordinatorOpsCountChart(summaryData) {
            const labels = Object.keys(summaryData);
            const data = labels.map(coord => summaryData[coord].operations.size);
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6'];

            createOrUpdateChart('coordinationOpsCountChart', 'bar', {
                labels, datasets: [{ data, backgroundColor: labels.map((_, i) => colors[i % colors.length]) }]
            }, {
                indexAxis: 'y',
                plugins: {
                    legend: { display: false },
                    datalabels: { display: true, anchor: 'end', align: 'end', color: '#333', font: { weight: 'bold' } }
                },
                scales: { x: { display: false }, y: { grid: { display: false } } }
            });
        }

        // SUBSTITUA A FUNÇÃO ANTIGA POR ESTA

        // SUBSTITUA A FUNÇÃO ANTIGA POR ESTA NOVA VERSÃO

        function renderCoordinatorOpsList(summaryData) {
            const container = document.getElementById('coordination-ops-list-container');
            container.innerHTML = ''; // Limpa o conteúdo anterior

            Object.entries(summaryData).forEach(([coord, data]) => {
                if (data.operations.size === 0) return; // Pula se o coordenador não tiver operações

                const opsArray = Array.from(data.operations).sort();
                const numColumns = 3; // Você pode ajustar para 2, 3 ou 4 colunas
                const rowsPerColumn = Math.ceil(opsArray.length / numColumns);

                let tableHTML = `
            <div class="regional-section">
                <h3>👑 Operações de ${coord} (${opsArray.length})</h3>
                <table class="performance-table">
                    <tbody>
        `;

                for (let i = 0; i < rowsPerColumn; i++) {
                    tableHTML += '<tr>';
                    for (let j = 0; j < numColumns; j++) {
                        const opIndex = i + j * rowsPerColumn;
                        const op = opIndex < opsArray.length ? opsArray[opIndex] : ''; // Pega a operação ou deixa a célula vazia
                        tableHTML += `<td>${op}</td>`;
                    }
                    tableHTML += '</tr>';
                }

                tableHTML += `
                    </tbody>
                </table>
            </div>
        `;
                container.innerHTML += tableHTML;
            });
        }

        function renderCoordinatorEvolutionChart(dailyDataByCoord, sortedLabels) {
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f1c40f', '#9b59b6'];
            const datasets = Object.keys(dailyDataByCoord).map((coord, index) => {
                const data = sortedLabels.map(date => dailyDataByCoord[coord][date] || 0);
                return {
                    label: coord,
                    data: data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: hexToRgba(colors[index % colors.length], 0.1),
                    fill: false,
                    tension: 0.4,
                    pointRadius: 3,
                    pointHoverRadius: 6
                };
            });

            createOrUpdateChart('coordinationEvolutionChart', 'line', {
                labels: sortedLabels,
                datasets: datasets
            }, {
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: { title: { display: true, text: 'Gasto Diário (R$)' }, ticks: { callback: (v) => formatKilo(v) } }
                }
            });
        }
        // --- FUNÇÕES DE CONTROLE DE UI (ATUALIZADAS) ---
        function setupEventListeners() {
          // --- Controle da Sidebar (Minimizar/Expandir) ---
          const sidebarToggleBtn = document.getElementById('sidebar-toggle');
          if (sidebarToggleBtn) {
              sidebarToggleBtn.addEventListener('click', () => {
                  document.body.classList.toggle('sidebar-minimized');
                  localStorage.setItem('sidebarState', document.body.classList.contains('sidebar-minimized') ? 'minimized' : 'expanded');
                  setTimeout(() => {
                      Object.values(charts).forEach(chart => {
                          if (chart && typeof chart.resize === 'function') {
                              try { chart.resize(); } catch (e) { console.warn("Erro resize:", chart.canvas.id, e); }
                          }
                      });
                  }, 400);
              });
          }
          if (localStorage.getItem('sidebarState') === 'minimized') {
              document.body.classList.add('sidebar-minimized');
          }

          // --- Controle da Navegação Principal e Itens de Menu Group ---
          const sidebarMenu = document.querySelector('.sidebar-menu');
          const viewSections = document.querySelectorAll('.view-section');
          const mainTitle = document.getElementById('main-title');
          const allNavButtons = document.querySelectorAll('.sidebar-nav .nav-btn');

          if (!sidebarMenu) return;

          sidebarMenu.addEventListener('click', (event) => {
              const button = event.target.closest('.nav-btn');
              if (!button) return;

              const targetId = button.dataset.target;
              const parentViewId = button.dataset.parentView || targetId;
              const tooltip = button.dataset.tooltip;

              if (!targetId || !parentViewId) return;

              // --- 1. Atualiza Botões ---
              allNavButtons.forEach(btn => btn.classList.remove('active'));
              button.classList.add('active');
              if (button.dataset.parentView) {
                  const parentButton = sidebarMenu.querySelector(`.nav-btn[data-target="${parentViewId}"]`);
                  if (parentButton) parentButton.classList.add('active');
              }

              // --- 2. Atualiza Seções Principais e Sub-views ---
              viewSections.forEach(section => {
                  const shouldSectionBeActive = section.id === parentViewId;
                  section.classList.toggle('active', shouldSectionBeActive);

                  if (shouldSectionBeActive) {
                      const subViews = section.querySelectorAll('.operacoes-sub-view');
                      if (subViews.length > 0) {
                          subViews.forEach(subView => {
                              const shouldSubViewBeActive = subView.id === targetId;
                              subView.classList.toggle('active', shouldSubViewBeActive);
                              // REMOVIDA A CHAMADA A populateComparisonFilters DAQUI
                          });
                      }
                  } else {
                       section.querySelectorAll('.operacoes-sub-view').forEach(sv => sv.classList.remove('active'));
                  }
              });

              // --- 3. Atualiza Título ---
              if (mainTitle && tooltip) {
                  mainTitle.textContent = tooltip;
              }

              // --- 4. Redimensiona Gráficos ---
              setTimeout(() => {
                  const activeMainView = document.querySelector('.view-section.active');
                  if (activeMainView) {
                      const activeSubView = activeMainView.querySelector('.operacoes-sub-view.active');
                      const containerToScan = activeSubView || activeMainView;
                      containerToScan.querySelectorAll('canvas').forEach(canvas => {
                          const chartInstance = charts[canvas.id];
                          if (chartInstance && typeof chartInstance.resize === 'function') {
                               try { chartInstance.resize(); } catch (e) { console.warn("Erro resize:", canvas.id, e); }
                          }
                      });
                  }
              }, 50);
          });

          // --- Mantém as outras lógicas ---
          document.querySelectorAll('#metric-toggle .toggle-btn').forEach(btn => { /* ...código mantido... */ });
          const plannerButton = document.getElementById('plannerCalculateBtn');
          if (plannerButton) { plannerButton.addEventListener('click', runGoalPlanner); }

          // Inicializa o estado visual
          const initialActiveButton = sidebarMenu.querySelector('.nav-btn.active');
          if (initialActiveButton) {
              // Sem timeout aqui, o clique deve ocorrer após listeners estarem prontos
              initialActiveButton.click();
          }
      }
        /// --- PONTO DE ENTRADA DA APLICAÇÃO ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Chama a função e ESPERA ela terminar, guardando os dados retornados
            const initialData = await loadAllData(true);

            // Somente depois que os dados chegarem, inicializa o resto
            if (initialData && initialData.length > 0) {
                initializeDashboard(); // Agora chamamos a inicialização aqui
                setupEventListeners();
            } else {
                console.error("Nenhum dado foi carregado na inicialização.");
                document.getElementById('status').textContent = "❌ Falha ao carregar dados iniciais.";
            }
        });
    </script>
</body>

</html>
