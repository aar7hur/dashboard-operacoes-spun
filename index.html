<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Operações v10.4 (Correção de Bug)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.1.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        :root {
            --primary-color: #6a82fb;
            --text-color: #343a40;
            --text-light: #6c757d;
            --bg-body: #f8f9fa;
            --bg-light: #ffffff;
            --border-color: #e9ecef;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            --border-radius: 12px;
            --color-positive: #20c997;
            --color-negative: #e74c3c;
            --color-neutral: #ffc107;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-color);
            padding: 25px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        /* Layout Geral e Utilitários */
        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .loader {
            border: 6px solid #e9ecef;
            border-top: 6px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .section-title {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--text-color);
            margin: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        .chart-full { grid-column: 1 / -1; }

        /* Header e Controles */
        .header {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px 35px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        h1 { font-size: 1.8em; font-weight: 700; display: flex; align-items: center; gap: 15px; }
        .controls { display: flex; gap: 15px; flex-wrap: wrap; align-items: center; }
        .status { font-size: 0.9em; color: var(--text-light); }
        button {
            padding: 10px 25px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(106, 130, 251, 0.4);
        }

        /* Filtros Gerais (Topo) */
        .filters {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .filter-group { display: flex; flex-direction: column; gap: 5px; }
        .filter-group label { font-size: 0.85em; font-weight: 600; color: var(--text-light); }
        input[type="date"], select {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            width: 180px;
            background-color: #fff;
        }
        select { width: 220px; }


        /* Navbar e Abas */
        .main-nav {
            display: flex;
            gap: 5px;
            background-color: var(--bg-light);
            padding: 5px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
        }
        .nav-btn {
            flex-grow: 1;
            padding: 12px 15px;
            background: transparent;
            color: var(--text-light);
            font-weight: 600;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
        }
        .nav-btn:hover {
            background-color: #f1f3f5;
            color: var(--text-color);
        }
        .nav-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 2px 5px rgba(106, 130, 251, 0.3);
        }

        .view-section { display: none; }
        .view-section.active { display: block; }
        
        /* Cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .card {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
        }
        .card-header { display: flex; justify-content: space-between; align-items: flex-start; }
        .card-header h3 { color: var(--text-light); font-size: 1em; text-transform: uppercase; font-weight: 600; margin: 0; display: flex; align-items: center; gap: 10px;}
        .card .value { color: var(--text-color); font-size: 2.2em; font-weight: 700; margin-top: 8px; margin-bottom: 5px; }
        
        /* LAYOUT PARA MÉTRICAS SECUNDÁRIAS NOS CARDS */
        .card .secondary-metrics {
            display: flex;
            justify-content: space-between;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        .card .metric-item {
            display: flex;
            flex-direction: column;
        }
        .card .metric-label {
            font-size: 0.8em;
            color: var(--text-light);
            text-transform: uppercase;
        }
        .card .metric-value {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-color);
        }

        /* Cards Regionais & Por Empresa */
        .regional-cards-wrapper { display: grid; grid-template-columns: 1fr; gap: 25px; margin-bottom: 20px; }
        .regional-section { background: var(--bg-light); border: 1px solid var(--border-color); padding: 25px; border-radius: var(--border-radius); box-shadow: var(--shadow); }
        .regional-section h3 { font-size: 1.5em; font-weight: 600; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }

        /* Tabela de Comparação Diária */
        .comparison-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
        .comparison-table th, .comparison-table td { padding: 10px; text-align: right; border-bottom: 1px solid var(--border-color); }
        .comparison-table th:first-child, .comparison-table td:first-child { text-align: left; font-weight: 600; }
        .comparison-table thead th { color: var(--text-light); font-size: 0.9em; text-transform: uppercase; }
        .comparison-table .delta-positive, .performance-table .delta-positive { color: var(--color-positive); font-weight: 600; }
        .comparison-table .delta-negative, .performance-table .delta-negative { color: var(--color-negative); font-weight: 600; }
        .comparison-table .delta-neutral { color: var(--text-light); }
        .comparison-container { background: var(--bg-light); border: 1px solid var(--border-color); padding: 25px; border-radius: var(--border-radius); box-shadow: var(--shadow); margin-bottom: 20px; }
        .comparison-container h3 { font-size: 1.5em; font-weight: 600; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        
        /* Gráficos */
        .chart-container {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            position: relative;
            height: 450px; 
        }
        .chart-container.chart-full {
             height: 600px;
        }
        .chart-container h2 { display: flex; align-items: center; gap: 10px; color: var(--text-color); margin-bottom: 20px; font-size: 1.3em; font-weight: 600; }
        
        #view-managers .charts-grid,
        #view-adops .charts-grid {
            grid-template-columns: 1fr;
        }
        #view-managers .chart-container,
        #view-adops .chart-container {
            height: auto;
        }
        
        #view-segments .charts-grid {
            grid-template-columns: repeat(auto-fit, minmax(700px, 1fr));
        }

        /* Seletor de Métrica */
        .metric-selector-container {
            margin: 0;
            margin-left: auto;
        }
        .metric-toggle { display: flex; border: 1px solid var(--border-color); border-radius: 10px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.04); }
        .toggle-btn { padding: 8px 20px; border: none; background-color: var(--bg-light); cursor: pointer; font-size: 13px; font-weight: 600; color: var(--text-light); transition: all 0.2s ease-in-out; display: flex; align-items: center; gap: 8px; }
        .toggle-btn:first-of-type { border-right: 1px solid var(--border-color); }
        .toggle-btn.active { background-color: var(--primary-color); color: white; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); }
        .toggle-btn:not(.active):hover { background-color: #f1f3f5; }

        /* Filtros do gráfico de evolução */
        .chart-filters-container {
            display: flex;
            gap: 25px;
            align-items: flex-end;
            background-color: var(--bg-light);
            padding: 15px 20px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        .checkbox-wrapper {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        .checkbox-wrapper input[type="checkbox"] {
            display: none;
        }
        .checkbox-wrapper label {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #f8f9fa;
            color: var(--text-light);
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            margin: 0;
        }
        .checkbox-wrapper input[type="checkbox"]:checked + label {
            background-color: var(--primary-color);
            color: white;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .checkbox-wrapper label:not(:last-of-type) {
            border-right: 1px solid var(--border-color);
        }

        /* Tabelas de Performance (Segmentos & Metas) */
        .performance-table { width: 100%; border-collapse: collapse; }
        .performance-table th, .performance-table td { padding: 12px 15px; text-align: left; border-bottom: 1px solid #eee; vertical-align: middle; }
        .performance-table th { font-weight: 600; background-color: #f9f9f9; }
        .performance-table tfoot td { font-weight: bold; background-color: #f1f3f5; border-top: 2px solid #dee2e6; }
        
        .performance-table th.sortable {
            cursor: pointer;
            user-select: none;
        }
        .performance-table th.sortable:hover {
            background-color: #f0f0f0;
        }
        .performance-table th .sort-indicator {
            display: inline-block;
            margin-left: 5px;
            color: var(--text-light);
        }
        
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .progress-bar {
            flex-grow: 1;
            background-color: var(--border-color);
            border-radius: 5px;
            height: 18px;
            overflow: hidden;
        }
        .progress-bar-inner {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
            transition: width 0.3s ease-in-out;
            text-align: right;
            padding-right: 5px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            line-height: 18px;
        }
        .progress-bar-inner.positive { background-color: var(--color-positive); }
        .progress-bar-inner.negative { background-color: var(--color-negative); }
        .progress-percent {
            font-weight: 600;
            font-size: 0.9em;
            min-width: 45px;
        }

        /* ESTILOS PARA TABELA DE ACELERAÇÃO */
        .acceleration-table th, .acceleration-table td {
            text-align: right;
            white-space: nowrap;
        }
        .acceleration-table th:first-child, .acceleration-table td:first-child {
            text-align: left;
            position: sticky;
            left: 0;
            background-color: #fff;
            z-index: 1;
        }
         .acceleration-table thead th {
            text-align: center;
            vertical-align: middle;
            z-index: 2;
        }
        .acceleration-table thead tr:first-child th {
            background-color: #f1f3f5;
            border-bottom: 2px solid #dee2e6;
        }
        .acceleration-table .scenario-group-start {
            border-left: 2px solid #dee2e6;
        }
        .acceleration-table .acrescimo-cell span {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            background-color: #fbeae8;
        }

        /* ESTILOS PARA TABELA SPRINT 1M */
        .sprint-table th, .sprint-table td { text-align: right; vertical-align: middle; }
        .sprint-table th:first-child, .sprint-table td:first-child { text-align: left; }
        .sprint-table .daily-cell {
            padding: 4px 8px;
            border-radius: 6px;
            text-align: center;
            min-width: 130px;
        }
        .sprint-table .daily-cell div:first-child { font-size: 0.8em; color: var(--text-light); line-height: 1.2; }
        .sprint-table .daily-cell div:last-child { font-weight: bold; line-height: 1.2; }
        
        .sprint-table .daily-cell.delta-positive { background-color: #e6f8f3; }
        .sprint-table .daily-cell.delta-negative { background-color: #fbeae8; }
        .sprint-table th { white-space: nowrap; }

    </style>
</head>
<body>
    <div class="loader-overlay" id="loader"> <div class="loader"></div> </div>

    <div class="container">
        <div class="header">
            <h1>📊 Dashboard de Operações</h1>
            <div class="controls">
                <div id="status" class="status">Pronto para carregar.</div>
                <button id="updateBtn" onclick="loadData(true)">🔄 Atualizar Dados</button>
            </div>
        </div>

        <div class="filters">
            <div class="filter-group"><label for="dateFilterStart">Data de Início:</label><input type="date" id="dateFilterStart" onchange="filterData()"></div>
            <div class="filter-group"><label for="dateFilterEnd">Data Final:</label><input type="date" id="dateFilterEnd" onchange="filterData()"></div>
            <button onclick="clearFilters()" style="background: #6c757d; margin-left: auto;">Limpar Filtros</button>
        </div>

        <nav class="main-nav">
            <button class="nav-btn active" data-target="view-general">Visão Geral</button>
            <button class="nav-btn" data-target="view-proportion">Análise de Proporção</button>
            <button class="nav-btn" data-target="view-managers">Performance por Gestor</button>
            <button class="nav-btn" data-target="view-adops">Performance por AdOps</button>
            <button class="nav-btn" data-target="view-segments">Segmentos de Negócio</button>
            <button class="nav-btn" data-target="view-companies">Performance por Empresa</button>
            <button class="nav-btn" data-target="view-metas">Metas</button>
        </nav>
        
        <div class="content-wrapper" id="mainContent">
            
            <div id="view-general" class="view-section active">
                <div class="section-header"><h2 class="section-title" id="general-results-title">Resultados Gerais do Período</h2></div>
                <div class="summary-cards" id="summaryCards"></div>

                <div class="section-header"><h2 class="section-title" id="regional-results-title">Resultados do Período por Região</h2></div>
                <div class="regional-cards-wrapper">
                    <div class="regional-section" id="regional-br"><h3>🇧🇷 Brasil</h3><div class="summary-cards" id="summaryCardsBr"></div></div>
                    <div class="regional-section" id="regional-us"><h3>🇺🇸 Estados Unidos</h3><div class="summary-cards" id="summaryCardsUs"></div></div>
                    <div class="regional-section" id="regional-eu"><h3>🇪🇺 Europa</h3><div class="summary-cards" id="summaryCardsEu"></div></div>
                </div>

                <div class="section-header"><h2 class="section-title">Evolução Diária</h2></div>
                <div class="chart-filters-container">
                        <div class="filter-group">
                            <label>Comparar Regiões:</label>
                            <div id="region-checkbox-group" class="checkbox-wrapper">
                                <input type="checkbox" id="region-all" value="all" onchange="handleRegionSelection(this)" checked><label for="region-all">Todas</label>
                                <input type="checkbox" id="region-br" value="br" onchange="handleRegionSelection(this)"><label for="region-br">Brasil</label>
                                <input type="checkbox" id="region-us" value="us" onchange="handleRegionSelection(this)"><label for="region-us">USA</label>
                                <input type="checkbox" id="region-eu" value="eu" onchange="handleRegionSelection(this)"><label for="region-eu">Europa</label>
                            </div>
                        </div>
                    <div class="filter-group">
                        <label for="evolutionOperationFilter">Filtrar por Operação:</label>
                        <select id="evolutionOperationFilter" onchange="updateEvolutionChartWithFilters()"><option value="all" selected>Todas as Operações</option></select>
                    </div>
                </div>
                <div class="charts-grid">
                    <div class="chart-container chart-full">
                        <canvas id="evolucaoCompletaChart"></canvas>
                    </div>
                </div>
                
                <div class="section-header"><h2 class="section-title">Análise Comparativa Diária</h2></div>
                <div id="dailyComparisonContainer">
                    <div class="comparison-container" id="dailyComparisonTotal"></div>
                    <div class="comparison-container" id="dailyComparisonBr"></div>
                    <div class="comparison-container" id="dailyComparisonUs"></div>
                    <div class="comparison-container" id="dailyComparisonEu"></div>
                </div>

                <div class="section-header"><h2 class="section-title">Projeção para o Fim do Mês</h2></div>
                <div class="summary-cards" id="projectionCards"></div>
            </div>

            <div id="view-proportion" class="view-section">
                <div class="section-header">
                    <h2 class="section-title">Proporção de Investimento / Leads</h2>
                    <div class="metric-selector-container">
                        <div id="metric-toggle" class="metric-toggle">
                            <button class="toggle-btn active" data-metric="gasto">📊 Investimento</button>
                            <button class="toggle-btn" data-metric="leads">👥 Leads</button>
                        </div>
                    </div>
                </div>
                <div class="charts-grid">
                    <div class="chart-container"><h2>🌍 Por Região</h2><canvas id="regionInvestmentPieChart"></canvas></div>
                    <div class="chart-container"><h2>💻 Por Plataforma</h2><canvas id="platformInvestmentPieChart"></canvas></div>
                    <div class="chart-container"><h2>📊 Por Nicho (BR)</h2><canvas id="nicheBrChart"></canvas></div>
                    <div class="chart-container"><h2>📊 Por Nicho (US)</h2><canvas id="nicheUsChart"></canvas></div>
                </div>
            </div>

            <div id="view-managers" class="view-section">
                <div class="section-header"><h2 class="section-title">Análise de Performance por Gestor (Aquisição)</h2></div>
                <div class="charts-grid">
                    <div class="chart-container"><h2>📈 Operações por Gestor</h2><canvas id="managerOpsCountChart"></canvas></div>
                    <div class="chart-container"><h2>💸 CPA Médio por Gestor</h2><canvas id="gestorCpaChart"></canvas></div>
                    <div class="chart-container"><h2>💰 Maior Investimento</h2><canvas id="gestorInvestimentoTotalChart"></canvas></div>
                    <div class="chart-container"><h2>🎯 Melhor ROAS</h2><canvas id="gestorRoasChart"></canvas></div>
                </div>
            </div>

            <div id="view-adops" class="view-section">
                 <div class="section-header"><h2 class="section-title">Análise de Performance por AdOps (Monetização)</h2></div>
                 <div class="charts-grid">
                    <div class="chart-container"><h2>📈 Receita Total por AdOps</h2><canvas id="adopsRevenueChart"></canvas></div>
                    <div class="chart-container"><h2>💰 Investimento Gerenciado</h2><canvas id="adopsInvestmentChart"></canvas></div>
                    <div class="chart-container"><h2>🎯 ROAS Médio por AdOps</h2><canvas id="adopsRoasChart"></canvas></div>
                    <div class="chart-container"><h2>👥 Leads Gerenciados</h2><canvas id="adopsLeadsChart"></canvas></div>
                    <div class="chart-container"><h2>📋 Operações por AdOps</h2><canvas id="adopsOpsCountChart"></canvas></div>
                 </div>
            </div>
            
            <div id="view-segments" class="view-section">
                <div class="section-header"><h2 class="section-title">Análise Comparativa por Segmento de Negócio</h2></div>
                <div class="charts-grid">
                    <div class="chart-container"><h2>🇺🇸 Cartão de Crédito (US)</h2><div id="segmentUsCcTable"></div></div>
                    <div class="chart-container"><h2>🇺🇸 Empréstimo (US)</h2><div id="segmentUsEmpTable"></div></div>
                    <div class="chart-container"><h2>🇧🇷 Cartão de Crédito (BR)</h2><div id="segmentBrCcTable"></div></div>
                    <div class="chart-container"><h2>🇧🇷 Empréstimo (BR)</h2><div id="segmentBrEmpTable"></div></div>
                    <div class="chart-container"><h2>🇩🇪 Cartão de Crédito (DE)</h2><div id="segmentDeCcTable"></div></div>
                    <div class="chart-container"><h2>🇫🇷 Cartão de Crédito (FR)</h2><div id="segmentFrCcTable"></div></div>
                </div>
            </div>

            <div id="view-companies" class="view-section">
                <div class="section-header"><h2 class="section-title">Resultados Consolidados por Empresa</h2></div>
                <div class="regional-cards-wrapper" id="company-cards-wrapper">
                    </div>
                
                <div class="section-header"><h2 class="section-title">Distribuição do Gasto Total por Empresa</h2></div>
                <div class="charts-grid">
                    <div class="chart-container">
                        <canvas id="companyTotalGastoPieChart"></canvas>
                    </div>
                </div>

                <div class="section-header"><h2 class="section-title">Evolução do Investimento por Empresa</h2></div>
                <div class="chart-filters-container">
                    <div class="filter-group">
                        <label>Selecionar Empresas:</label>
                        <div id="company-checkbox-group" class="checkbox-wrapper">
                            </div>
                    </div>
                </div>
                <div class="charts-grid">
                    <div class="chart-container chart-full">
                        <canvas id="companyEvolutionChart"></canvas>
                    </div>
                </div>

                <div class="section-header"><h2 class="section-title">Distribuição Regional do Investimento por Empresa</h2></div>
                <div class="charts-grid" id="companyDistributionCharts">
                    </div>
            </div>

            <div id="view-metas" class="view-section">
                <div class="section-header"><h2 class="section-title">Visão Geral das Metas Diárias</h2></div>
                <div class="summary-cards" style="grid-template-columns: 1fr 1fr; align-items: stretch;">
                    <div id="metas-kpi-cards"></div>
                    <div id="sprint-kpi-cards"></div>
                </div>
                
                <div class="section-header"><h2 class="section-title">🚀 Sprint 1M - Plano de Aceleração Diária (até 12/10)</h2></div>
                <div class="chart-container chart-full" style="height: auto; padding: 25px;">
                    <div id="sprint-1m-table" style="overflow-x: auto;"></div>
                </div>

                <div class="section-header"><h2 class="section-title">Performance Detalhada vs. Metas Diárias</h2></div>
                <div class="chart-container chart-full" style="height: auto; padding: 0;">
                    <div id="metas-detailed-table"></div>
                </div>
                
                <div class="section-header"><h2 class="section-title">Simulador de Aceleração para Metas Gerais</h2></div>
                <div class="chart-container chart-full" style="height: auto; padding: 25px;">
                    <div id="metas-acceleration-table" style="overflow-x: auto;"></div>
                </div>
            </div>

        </div>
    </div>

    <script>
        const SHEET_ID = '1iMEXFAfdB--bCzNYF8DkyTbzxjRARAHXaUX2_KBUvpc';
        const SHEET_NAME = 'Controle_diario';
        const EXCLUDED_MANAGERS = ['NICOLE', 'MARCELO', 'AMANDA']; 
        const REGION_COLORS = { 'all': { investment: '#6a82fb', roas: '#fd7e14', leads: '#9b59b6' }, 'br': { investment: '#009739', roas: '#2ecc71', leads: '#1abc9c' }, 'us': { investment: '#DC143C', roas: '#e74c3c', leads: '#c0392b' }, 'eu': { investment: '#4169E1', roas: '#3498db', leads: '#2980b9' } };
        const SEGMENT_US_CC = ['MG US CC TOTAL', 'FM US CC TOTAL', 'CL US CC TOTAL', 'GRID US CC TOTAL', 'JN US CC TOTAL'];
        const SEGMENT_US_EMP = ['JN US EMP TOTAL', 'MG US EMP TOTAL'];
        const SEGMENT_BR_CC = ['JN BR CC TOTAL', 'MG BR CC TOTAL'];
        const SEGMENT_BR_EMP = ['JN BR EMP TOTAL', 'MG BR EMP TOTAL'];
        const SEGMENT_DE_CC = ['JN DE CC TOTAL', 'MG DE CC TOTAL'];
        const SEGMENT_FR_CC = ['JN FR CC TOTAL', 'MG FR CC TOTAL'];
        
        const COMPANIES = {
            'MG': { name: 'MG', color: '#3498db' }, 'JN': { name: 'JN', color: '#2ecc71' }, 'GRID': { name: 'GRID', color: '#e74c3c' }, 'FM': { name: 'FM', color: '#f1c40f' }, 'CL': { name: 'CL', color: '#9b59b6'}, 'ND': { name: 'ND', color: '#34495e'}
        };
        
        const GOALS_DATA = {
            'JN EMP BR': { investimento: 65000, roas: 0.90 }, 'JN CC BR': { investimento: 100000, roas: 0.90 }, 'JN CC EUA': { investimento: 500000, roas: 0.80 }, 'JN EMP EUA': { investimento: 375000, roas: 0.80 }, 'JN CC UK': { investimento: 25000, roas: 0.70 }, 'JN CC DE': { investimento: 25000, roas: 0.70 }, 'JN CC AU': { investimento: 25000, roas: 0.70 }, 'JN CC FR': { investimento: 25000, roas: 0.70 }, 'JN CC ES': { investimento: 0, roas: 0.70 }, 'ND CC US': { investimento: 25000, roas: 0.70 }, 'ND CC DE': { investimento: 0, roas: 0.65 }, 'ND CC IT': { investimento: 0, roas: 0.65 }, 'MG CC BR': { investimento: 65000, roas: 0.90 }, 'MG EMP BR': { investimento: 100000, roas: 0.90 }, 'MG CC US': { investimento: 250000, roas: 0.80 }, 'MG EMP US': { investimento: 125000, roas: 0.80 }, 'MG CC FR': { investimento: 15000, roas: 0.70 }, 'MG CC DE': { investimento: 15000, roas: 0.70 }, 'CL CC US': { investimento: 250000, roas: 0.80 }, 'GRID 1 CC US': { investimento: 250000, roas: 0.80 }, 'FM CC US': { investimento: 250000, roas: 0.80 }, 'FM CC FR': { investimento: 15000, roas: 0.70 }, 'FM CC UK': { investimento: 15000, roas: 0.70 }
        };

        // --- CONSTANTES PARA A META SPRINT 1M ---
        const SPRINT_1M_DEADLINE = new Date(Date.UTC(2025, 9, 12)); // Mês 9 = Outubro
        const SPRINT_1M_GOAL = 1000000;
        
        // REGRAS DE NEGÓCIO ATUALIZADAS
        const SPRINT_1M_RULES = {
            'JN CC EUA': { finalTarget: 300000 },
            'CL CC US':  { target: 10000 },
            'FM CC US':  { exclude: true },
            'JN CC BR':  { target: 40000 },
            'MG EMP BR': { target: 25000 },
        };
        
        const SPRINT_1M_BASE_OPERATIONS = [
            'JN CC EUA', 'JN EMP EUA', 'MG CC US', 'MG EMP US', 'JN CC BR', 
            'GRID 1 CC US', 'JN CC FR', 'JN CC DE', 'MG CC BR', 'MG CC DE', 
            'MG CC FR', 'MG EMP BR', 'CL CC US', 'ND CC US', 'JN EMP BR'
        ];

        let rawData = [], filteredData = [], charts = {};
        let segmentDataCache = {}, tableSortState = {}, metasTableSortState = {};

        Chart.register(ChartDataLabels);

        // --- UTILITY FUNCTIONS ---
        function hexToRgba(hex, alpha = 1) { if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) return `rgba(200,200,200,${alpha})`; let c = hex.substring(1).split(''); if (c.length === 3) { c = [c[0], c[0], c[1], c[1], c[2], c[2]]; } c = '0x' + c.join(''); return `rgba(${(c >> 16) & 255}, ${(c >> 8) & 255}, ${c & 255}, ${alpha})`; }
        function parseMonetaryValue(v) { return parseFloat(String(v || '').replace(/[R$\s.]/g, '').replace(',', '.')) || 0; }
        function parseDate(dateStr) { if (!dateStr || typeof dateStr !== 'string') return null; const parts = dateStr.split('/'); if (parts.length === 3) { return new Date(Date.UTC(parseInt(parts[2], 10), parseInt(parts[1], 10) - 1, parseInt(parts[0], 10))); } return null; }
        function formatDate(dateObj, simple = false) { if(!dateObj) return null; const day = dateObj.getUTCDate().toString().padStart(2, '0'); const month = (dateObj.getUTCMonth() + 1).toString().padStart(2, '0'); if (simple) return `${day}/${month}`; return `${day}/${month}/${dateObj.getUTCFullYear()}`; }
        function endsWithTOTAL(text) { return /\bTOTAL\s*$/i.test(text || ''); }
        function formatCurrency(value) { return value.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }); }
        function formatKilo(num) { if (Math.abs(num) >= 1000000) return 'R$ ' + (num / 1000000).toFixed(1).replace('.', ',') + 'M'; if (Math.abs(num) >= 1000) return 'R$ ' + (num / 1000).toFixed(1).replace('.', ',') + 'k'; return formatCurrency(num); }
        
        // FUNÇÃO ADICIONADA NOVAMENTE
        function getPlatformFromOperation(opName) { return (opName || '').substring(0, 2).toUpperCase() === 'ND' ? 'Meta Ads' : 'Google Ads'; }

        // CORRIGIDO: Mapeamento de nomes de operações
        function getGoalKeyFromOperation(opName) {
            let cleanOp = opName.replace(' TOTAL', '').trim();
            if (cleanOp.startsWith('GRID US')) return 'GRID 1 CC US';
            
            const parts = cleanOp.split(' ');
            if (parts.length < 3) return cleanOp;

            const company = parts[0];
            const country = parts[1];
            const niche = parts.slice(2).join(' ');

            // Tenta o formato [Empresa] [Nicho] [País]
            let potentialKey = `${company} ${niche} ${country}`;
            if (GOALS_DATA[potentialKey]) return potentialKey;

            // Tenta com EUA para US
            if (country === 'US') {
                const euaKey = `${company} ${niche} EUA`;
                if (GOALS_DATA[euaKey]) return euaKey;
            }
            
            return potentialKey; // Fallback
        }

        // --- DATA LOADING & CACHING ---
        async function loadData(forceRefresh = false) {
            document.getElementById('loader').style.display = 'flex';
            document.getElementById('updateBtn').disabled = true;
            document.getElementById('status').textContent = '⏳ Carregando...';
            try {
                const csvUrl = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME)}`;
                const response = await fetch(csvUrl, { cache: forceRefresh ? 'reload' : 'default' });
                if (!response.ok) throw new Error(`Network response was not ok`);
                const csvText = await response.text();
                Papa.parse(csvText, {
                    header: true, skipEmptyLines: true,
                    complete: (results) => {
                        rawData = results.data.map(row => ({
                            data: row.DATA,
                            operacao: row['OPERAÇÃO'],
                            gasto: parseMonetaryValue(row.GASTO),
                            receita: parseMonetaryValue(row.RECEITA),
                            cpa: parseMonetaryValue(row.CPA),
                            leads: parseInt(row['TOTAL DE LEADS'] || 0),
                            responsavelAquisicao: row['RESPONSÁVEL AQUISIÇÃO'],
                            responsavelMonetizacao: row['RESPONSÁVEL MONETIZAÇÃO'] 
                        })).filter(row => row.operacao && row.operacao.trim() !== '');
                        processData();
                    }, error: (error) => { throw error; }
                });
            } catch (error) {
                document.getElementById('status').textContent = `❌ Erro: ${error.message}`;
                document.getElementById('loader').style.display = 'none';
                document.getElementById('updateBtn').disabled = false;
            }
        }
        
        function processData() { filterData(); const allTotalData = rawData.filter(r => endsWithTOTAL(r.operacao)); populateEvolutionFilters(allTotalData); populateCompanyCheckboxes(); document.getElementById('loader').style.display = 'none'; document.getElementById('updateBtn').disabled = false; document.getElementById('status').textContent = `✅ Dados atualizados!`; }
        function filterData() { const dateStartStr = document.getElementById('dateFilterStart').value; const dateEndStr = document.getElementById('dateFilterEnd').value; let dateStart = null, dateEnd = null; if (dateStartStr) { dateStart = new Date(Date.UTC(...dateStartStr.split('-').map((n, i) => i === 1 ? n - 1 : n))); } if (dateEndStr) { dateEnd = new Date(Date.UTC(...dateEndStr.split('-').map((n, i) => i === 1 ? n - 1 : n))); dateEnd.setUTCHours(23, 59, 59, 999); } filteredData = rawData.filter(row => { const rowDate = parseDate(row.data); if (dateStart && (!rowDate || rowDate < dateStart)) return false; if (dateEnd && (!rowDate || rowDate > dateEnd)) return false; return true; }); updateDashboard(); }
        function clearFilters() { ['dateFilterStart', 'dateFilterEnd'].forEach(id => document.getElementById(id).value = ''); filterData(); }
        
        function updateDashboard() { 
            const mainContent = document.getElementById('mainContent'); 
            if (!mainContent) return; 
            const hasData = filteredData.length > 0; 
            mainContent.style.display = hasData ? 'block' : 'none'; 
            
            const dateStartInput = document.getElementById('dateFilterStart');
            const dateEndInput = document.getElementById('dateFilterEnd');
            let dateRangeStr = '';
            if (dateStartInput.value && dateEndInput.value) {
                const start = formatDate(new Date(dateStartInput.value + 'T00:00:00Z'), true);
                const end = formatDate(new Date(dateEndInput.value + 'T00:00:00Z'), true);
                dateRangeStr = `(${start} a ${end})`;
            }
            document.getElementById('general-results-title').textContent = `Resultados Gerais do Período ${dateRangeStr}`;
            document.getElementById('regional-results-title').textContent = `Resultados do Período por Região ${dateRangeStr}`;

            if (hasData) { 
                const dataNoTotal = filteredData.filter(r => !endsWithTOTAL(r.operacao)); 
                const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao)); 
                updateSummaryCards(dataOnlyTotal); 
                updateRegionalSummaryCards(dataOnlyTotal); 
                updateDailyComparison(dataOnlyTotal); 
                updateProjectionCards(dataOnlyTotal); 
                updateCharts(dataNoTotal, dataOnlyTotal); 
            } 
        }
        
        function updateCharts(dataNoTotal, dataOnlyTotal) {
            updateEvolutionChartWithFilters();
            updateProportionCharts();
            renderNicheComparisonCharts(dataOnlyTotal);
            renderManagerCharts(dataNoTotal);
            renderAdopsCharts(dataOnlyTotal);
            renderBusinessSegmentTables(dataOnlyTotal);
            renderCompanyView(dataOnlyTotal);
            renderMetasView(dataOnlyTotal, filteredData);
        }
        
        function handleRegionSelection(checkbox) { const allCheckbox = document.getElementById('region-all'); const regionCheckboxes = document.querySelectorAll('#region-checkbox-group input:not(#region-all)'); if (checkbox.id === 'region-all' && checkbox.checked) { regionCheckboxes.forEach(cb => cb.checked = false); } else if (checkbox.id !== 'region-all') { if (Array.from(regionCheckboxes).some(cb => cb.checked)) { allCheckbox.checked = false; } } if (!document.querySelector('#region-checkbox-group input:checked')) { allCheckbox.checked = true; } updateEvolutionChartWithFilters(); }
        
        function updateEvolutionChartWithFilters() { const selectedRegions = Array.from(document.querySelectorAll('#region-checkbox-group input:checked')).map(cb => cb.value); const operationFilter = document.getElementById('evolutionOperationFilter'); const selectedOperation = operationFilter.value; const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao)); const baseData = selectedOperation === 'all' ? dataOnlyTotal : dataOnlyTotal.filter(r => r.operacao === selectedOperation); operationFilter.disabled = selectedRegions.length > 1 && !selectedRegions.includes('all'); const datasetsToRender = []; const allDates = new Set(); selectedRegions.forEach(regionKey => { let regionData; let regionLabel; if (regionKey === 'all') { regionData = baseData; regionLabel = 'Todas'; } else { regionLabel = regionKey.toUpperCase(); regionData = baseData.filter(row => { const op = row.operacao.toUpperCase(); if (regionKey === 'br') return op.includes('BR'); if (regionKey === 'us') return op.includes('US'); if (regionKey === 'eu') return ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p)); return false; }); } if (regionData && regionData.length > 0) { const dailyData = {}; regionData.forEach(row => { if (row.data) { if (!dailyData[row.data]) dailyData[row.data] = { gasto: 0, receita: 0, leads: 0 }; dailyData[row.data].gasto += row.gasto; dailyData[row.data].receita += row.receita; dailyData[row.data].leads += row.leads; allDates.add(row.data); } }); datasetsToRender.push({ key: regionKey, label: regionLabel, data: dailyData }); } }); const sortedLabels = Array.from(allDates).sort((a, b) => parseDate(a) - parseDate(b)); const finalChartJsDatasets = []; datasetsToRender.forEach(dataset => { const investmentColor = REGION_COLORS[dataset.key]?.investment || '#cccccc'; const roasColor = REGION_COLORS[dataset.key]?.roas || '#aaaaaa'; const leadsColor = REGION_COLORS[dataset.key]?.leads || '#888888'; const gastoData = sortedLabels.map(date => dataset.data[date]?.gasto ?? null); const roasData = sortedLabels.map(date => { const dayData = dataset.data[date]; return (dayData && dayData.gasto > 0) ? (dayData.receita / dayData.gasto) : null; }); const leadsData = sortedLabels.map(date => dataset.data[date]?.leads ?? null); finalChartJsDatasets.push({ label: `Investimento (${dataset.label})`, data: gastoData, yAxisID: 'y', borderColor: investmentColor, backgroundColor: hexToRgba(investmentColor, 0.1), fill: datasetsToRender.length === 1, tension: 0.4 }); finalChartJsDatasets.push({ label: `ROAS (${dataset.label})`, data: roasData, yAxisID: 'y1', borderColor: roasColor, backgroundColor: 'transparent', borderDash: [5, 5], tension: 0.4, fill: false }); finalChartJsDatasets.push({ label: `Leads (${dataset.label})`, data: leadsData, yAxisID: 'y2', borderColor: leadsColor, backgroundColor: 'transparent', borderDash: [2, 2], tension: 0.4, fill: false }); }); createOrUpdateChart('evolucaoCompletaChart', 'line', { labels: sortedLabels, datasets: finalChartJsDatasets }, { scales: { y: { title: { display: true, text: 'Valores (R$)' }, ticks: { callback: (v) => formatKilo(v) } }, y1: { position: 'right', title: { display: true, text: 'ROAS (x)' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toFixed(2) } }, y2: { position: 'right', title: { display: true, text: 'Leads' }, grid: { drawOnChartArea: false }, ticks: { callback: (v) => v.toLocaleString('pt-BR') } } } }); }
        function updateSummaryCards(data) { const totalGasto = data.reduce((s, r) => s + r.gasto, 0); const totalReceita = data.reduce((s, r) => s + r.receita, 0); const totalLeads = data.reduce((s, r) => s + r.leads, 0); const roasMedio = totalGasto > 0 ? (totalReceita / totalGasto) : 0; const cpaMedio = totalLeads > 0 ? (totalGasto / totalLeads) : 0; const roasDiffFrom1 = (roasMedio - 1) * 100; document.getElementById('summaryCards').innerHTML = createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(totalGasto), footerHTML: `<div class="secondary-metrics"><div class="metric-item"><span class="metric-label">Total de Leads</span><span class="metric-value">${totalLeads.toLocaleString('pt-BR')}</span></div><div class="metric-item"><span class="metric-label">CPA Médio</span><span class="metric-value">${formatCurrency(cpaMedio)}</span></div></div>` }) + createCardHTML({ icon: '📈', title: 'Receita Total', value: formatCurrency(totalReceita) }) + createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roasMedio.toFixed(2)}x`, delta: roasDiffFrom1, deltaPositiveOverride: roasDiffFrom1 >= 0 }); }
        function updateRegionalSummaryCards(data) { const regions = [ { key: 'br', containerId: 'summaryCardsBr', filter: (op) => op.includes('BR') }, { key: 'us', containerId: 'summaryCardsUs', filter: (op) => op.includes('US') }, { key: 'eu', containerId: 'summaryCardsEu', filter: (op) => ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p)) } ]; regions.forEach(region => { const regionalData = data.filter(row => region.filter(row.operacao.toUpperCase())); const totalGasto = regionalData.reduce((s, r) => s + r.gasto, 0); const totalReceita = regionalData.reduce((s, r) => s + r.receita, 0); const totalLeads = regionalData.reduce((s, r) => s + r.leads, 0); const roasMedio = totalGasto > 0 ? (totalReceita / totalGasto) : 0; const cpaMedio = totalLeads > 0 ? (totalGasto / totalLeads) : 0; const roasDiffFrom1 = (roasMedio - 1) * 100; const container = document.getElementById(region.containerId); if(container) { if (totalGasto > 0) { container.parentElement.style.display = 'block'; container.innerHTML = createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(totalGasto), footerHTML: `<div class="secondary-metrics"><div class="metric-item"><span class="metric-label">Total de Leads</span><span class="metric-value">${totalLeads.toLocaleString('pt-BR')}</span></div><div class="metric-item"><span class="metric-label">CPA Médio</span><span class="metric-value">${formatCurrency(cpaMedio)}</span></div></div>` }) + createCardHTML({ icon: '📈', title: 'Receita Total', value: formatCurrency(totalReceita) }) + createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roasMedio.toFixed(2)}x`, delta: roasDiffFrom1, deltaPositiveOverride: roasDiffFrom1 >= 0 }); } else { container.parentElement.style.display = 'none'; } } }); }
        function updateDailyComparison(data) { const allDates = [...new Set(data.map(r => r.data))].map(d => parseDate(d)).sort((a, b) => b - a); if (allDates.length === 0) return; const d1 = allDates[0]; const findDate = (offset) => allDates.find(d => (d1 - d) / (1000*60*60*24) === offset); const dates = { d1: d1, d2: findDate(1), d4: findDate(3), d8: findDate(7) }; const getMetricsForDate = (targetDate, dataset) => { if (!targetDate) return { gasto: 0, receita: 0, leads: 0, roas: 0, cpa: 0, date: null }; const dateStr = formatDate(targetDate); const dataForDate = dataset.filter(r => r.data === dateStr); const gasto = dataForDate.reduce((s, r) => s + r.gasto, 0); const receita = dataForDate.reduce((s, r) => s + r.receita, 0); const leads = dataForDate.reduce((s, r) => s + r.leads, 0); return { gasto, receita, leads, roas: gasto > 0 ? receita / gasto : 0, cpa: leads > 0 ? gasto / leads : 0, date: dateStr }; }; const createComparisonTableHTML = (title, metrics) => { const calcDelta = (v1, v2) => { if (v2 === 0) return v1 > 0 ? Infinity : 0; return ((v1 / v2) - 1) * 100; }; const formatDelta = (delta) => { if (!isFinite(delta) || isNaN(delta)) return `<span class="delta-neutral">-</span>`; const cls = delta >= 0 ? 'delta-positive' : 'delta-negative'; const sign = delta > 0 ? '+' : ''; return `<span class="${cls}">${sign}${delta.toFixed(1)}%</span>`; }; let html = `<h3>${title}</h3><table class="comparison-table"><thead><tr> <th>Métrica</th> <th>Ontem (${metrics.d1.date || 'N/A'})</th> <th>D-2 (${metrics.d2.date || 'N/A'})</th><th>%</th> <th>D-4 (${metrics.d4.date || 'N/A'})</th><th>%</th> <th>D-8 (${metrics.d8.date || 'N/A'})</th><th>%</th> </tr></thead><tbody>`; const rows = [ { label: 'Investimento', format: formatCurrency, key: 'gasto' }, { label: 'Receita', format: formatCurrency, key: 'receita' }, { label: 'Leads', format: (v) => v.toLocaleString('pt-BR'), key: 'leads' }, { label: 'ROAS', format: (v) => `${v.toFixed(2)}x`, key: 'roas' }, { label: 'CPA', format: formatCurrency, key: 'cpa', inverse: true } ]; rows.forEach(r => { const v1 = metrics.d1[r.key], v2 = metrics.d2[r.key], v4 = metrics.d4[r.key], v8 = metrics.d8[r.key]; let d2 = calcDelta(v1, v2), d4 = calcDelta(v1, v4), d8 = calcDelta(v1, v8); if(r.inverse) { d2*=-1; d4*=-1; d8*=-1; } html += `<tr> <td>${r.label}</td> <td>${r.format(v1)}</td> <td>${r.format(v2)}</td><td>${formatDelta(d2)}</td> <td>${r.format(v4)}</td><td>${formatDelta(d4)}</td> <td>${r.format(v8)}</td><td>${formatDelta(d8)}</td> </tr>`; }); return html + '</tbody></table>'; }; const totalMetrics = { d1: getMetricsForDate(dates.d1, data), d2: getMetricsForDate(dates.d2, data), d4: getMetricsForDate(dates.d4, data), d8: getMetricsForDate(dates.d8, data) }; document.getElementById('dailyComparisonTotal').innerHTML = createComparisonTableHTML('📊 Comparativo Total', totalMetrics); const regions = [ { key: 'br', containerId: 'dailyComparisonBr', filter: (op) => op.includes('BR'), title: '🇧🇷 Brasil' }, { key: 'us', containerId: 'dailyComparisonUs', filter: (op) => op.includes('US'), title: '🇺🇸 Estados Unidos' }, { key: 'eu', containerId: 'dailyComparisonEu', filter: (op) => ['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p)), title: '🇪🇺 Europa' } ]; regions.forEach(region => { const regionalData = data.filter(row => region.filter(row.operacao.toUpperCase())); const regionalMetrics = { d1: getMetricsForDate(dates.d1, regionalData), d2: getMetricsForDate(dates.d2, regionalData), d4: getMetricsForDate(dates.d4, regionalData), d8: getMetricsForDate(dates.d8, regionalData) }; const container = document.getElementById(region.containerId); if (regionalMetrics.d1.gasto > 0 || regionalMetrics.d2.gasto > 0) { container.innerHTML = createComparisonTableHTML(region.title, regionalMetrics); container.style.display = 'block'; } else { container.style.display = 'none'; } }); }
        function updateProjectionCards(data) { const projectionContainer = document.getElementById('projectionCards'); projectionContainer.innerHTML = ''; const dates = [...new Set(data.map(r => r.data))].filter(Boolean); if (dates.length < 1) return; const lastDayOfMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0); const lastDateInData = parseDate(dates.sort((a, b) => parseDate(a) - parseDate(b)).pop()); const daysRemaining = Math.max(0, (lastDayOfMonth - lastDateInData) / (1000 * 60 * 60 * 24)); const totalGasto = data.reduce((s, r) => s + r.gasto, 0); const avgDailyGasto = totalGasto / dates.length; const projectedGasto = totalGasto + (avgDailyGasto * daysRemaining); const subtitle = `*Baseado na média de ${dates.length} dia(s) do período`; projectionContainer.innerHTML = createCardHTML({ icon: '🔮', title: 'Projeção de Gasto', value: formatCurrency(projectedGasto), isProjection: true, subtitle: subtitle }); }
        function createCardHTML(config) { const deltaClass = (config.deltaPositiveOverride !== undefined) ? (config.deltaPositiveOverride ? 'positive' : 'negative') : (config.delta > 0 ? 'positive' : 'negative'); const deltaHTML = config.delta ? `<span class="delta ${deltaClass}">${config.delta > 0 ? '▲' : '▼'} ${Math.abs(config.delta).toFixed(1)}%</span>` : ''; const subtitleHTML = config.subtitle ? `<div class="subtitle">${config.subtitle}</div>` : ''; const footerHTML = config.footerHTML ? config.footerHTML : ''; const valueClass = 'value'; return `<div class="card ${config.isProjection ? 'projection' : ''}"><div class="card-header"><h3>${config.icon} ${config.title}</h3>${deltaHTML}</div><div class="${valueClass}">${config.value}</div>${subtitleHTML}${footerHTML}</div>`; }
        
        function calculateChartHeight(numBars, minHeight = 250, barHeight = 40) {
            return Math.max(minHeight, numBars * barHeight + 100);
        }

        function createOrUpdateChart(canvasId, type, data, customOptions = {}) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) { return; }
            if (charts[canvasId]) { charts[canvasId].destroy(); }

            if (type === 'bar' && customOptions.indexAxis === 'y') {
                const numBars = data.labels.length;
                const newHeight = calculateChartHeight(numBars);
                ctx.style.height = `${newHeight}px`;
                if (ctx.parentElement.classList.contains('chart-container')) {
                    ctx.parentElement.style.height = `${newHeight + 60}px`;
                }
            } else {
                ctx.style.height = '';
                 if (ctx.parentElement.classList.contains('chart-container')) {
                    ctx.parentElement.style.height = ''; 
                 }
            }

            const defaultOptions = { 
                responsive: true, 
                maintainAspectRatio: false, 
                plugins: { 
                    legend: { position: 'bottom', labels: { boxWidth: 12, padding: 20 } }, 
                    tooltip: { backgroundColor: '#333', titleFont: { size: 14 }, bodyFont: { size: 12 }, footerFont: { size: 10 }, callbacks: { label: (ctx) => { let label = ctx.dataset.label || '', value = ctx.parsed.y ?? ctx.parsed; const metric = document.querySelector('#metric-toggle .toggle-btn.active')?.dataset.metric || 'gasto'; if (label) { label += ': '; } if (['regionInvestmentPieChart', 'platformInvestmentPieChart', 'nicheBrChart', 'nicheUsChart', 'companyTotalGastoPieChart'].includes(canvasId) || canvasId.startsWith('companyDistribution')) { return `${label}${formatCurrency(value)}`; } if (ctx.dataset.label?.includes('ROAS')) return `${label}${value.toFixed(2)}`; if (ctx.dataset.label?.includes('Leads')) return `${label}${value.toLocaleString('pt-BR')}`; if(canvasId === 'metas-bubble-chart') { const point = ctx.raw; return [ `${point.label}`, `Investimento: ${point.progressoInvest.toFixed(0)}% da Meta`, `ROAS: ${point.diffRoas.toFixed(2)} p.p. vs Meta`, `Gasto: ${formatCurrency(point.gasto)}` ]; } return `${label}${formatCurrency(value)}`; } } }, datalabels: { display: false } 
                }, 
                scales: { 
                    x: { grid: { display: false } }, 
                    y: { grid: { color: 'rgba(0,0,0,0.05)' }, ticks: { callback: (v) => formatKilo(v) } 
                } 
            } }; 
            charts[canvasId] = new Chart(ctx, { type, data, options: { ...defaultOptions, ...customOptions } }); 
        }

        function updateProportionCharts() { const metric = document.querySelector('#metric-toggle .toggle-btn.active').dataset.metric; const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao)); renderRegionSummaryCharts(dataOnlyTotal, metric); renderPlatformSummaryCharts(dataOnlyTotal, metric); renderNicheComparisonCharts(dataOnlyTotal, metric); }
        function renderRegionSummaryCharts(data, metric = 'gasto') { const regionTotals = { europa: 0, brasil: 0, usa: 0 }; data.forEach(row => { const op = row.operacao.toUpperCase(); if (op.includes('BR')) regionTotals.brasil += row[metric]; else if (op.includes('US')) regionTotals.usa += row[metric]; else if (['UK', 'DE', 'AU', 'FR'].some(p => op.includes(p))) regionTotals.europa += row[metric]; }); createOrUpdateChart('regionInvestmentPieChart', 'pie', { labels: ['Europa', 'Brasil', 'USA'], datasets: [{ data: [regionTotals.europa, regionTotals.brasil, regionTotals.usa], backgroundColor: ['#4169E1', '#009739', '#DC143C'] }] }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }); }
        function renderNicheComparisonCharts(data, metric = 'gasto') { const nicheSpending = { us_cc: 0, us_emp: 0, br_cc: 0, br_emp: 0 }; data.forEach(row => { const op = row.operacao.toUpperCase(); if (op.includes('US')) { if (op.includes('CC')) nicheSpending.us_cc += row[metric]; if (op.includes('EMP')) nicheSpending.us_emp += row[metric]; } else if (op.includes('BR')) { if (op.includes('CC')) nicheSpending.br_cc += row[metric]; if (op.includes('EMP')) nicheSpending.br_emp += row[metric]; } }); const pieOptions = { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }; createOrUpdateChart('nicheUsChart', 'pie', { labels: ['Cartão de Crédito', 'Empréstimo'], datasets: [{ data: [nicheSpending.us_cc, nicheSpending.us_emp], backgroundColor: ['#3498db', '#e67e22'] }] }, pieOptions); createOrUpdateChart('nicheBrChart', 'pie', { labels: ['Cartão de Crédito', 'Empréstimo'], datasets: [{ data: [nicheSpending.br_cc, nicheSpending.br_emp], backgroundColor: ['#2ecc71', '#f1c40f'] }] }, pieOptions); }
        function renderPlatformSummaryCharts(data, metric = 'gasto') { const platformData = { 'Meta Ads': 0, 'Google Ads': 0 }; data.forEach(row => { platformData[getPlatformFromOperation(row.operacao)] += row[metric]; }); createOrUpdateChart('platformInvestmentPieChart', 'pie', { labels: Object.keys(platformData), datasets: [{ data: Object.values(platformData), backgroundColor: ['#3b5998', '#4285F4'] }] }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff', font: { weight: 'bold', size: 14 } } } }); }
        
        function renderManagerCharts(data) {
            const includedData = data.filter(row => row.responsavelAquisicao && !EXCLUDED_MANAGERS.includes(row.responsavelAquisicao.toUpperCase()));
            const managerSummary = {};
            includedData.forEach(row => {
                const manager = row.responsavelAquisicao;
                if (!managerSummary[manager]) managerSummary[manager] = { gasto: 0, receita: 0, leads: 0, ops: new Set() };
                managerSummary[manager].gasto += row.gasto;
                managerSummary[manager].receita += row.receita;
                managerSummary[manager].leads += row.leads;
                managerSummary[manager].ops.add(row.operacao);
            });

            const managers = Object.keys(managerSummary);
            const horizontalBarOptions = (formatter) => ({
                indexAxis: 'y',
                plugins: {
                    legend: { display: false },
                    datalabels: { display: true, anchor: 'end', align: 'end', color: '#555', font: { size: 12, weight: '600' }, formatter: formatter, offset: 4 }
                },
                scales: {
                    x: { grid: { display: false }, ticks: { display: false } },
                    y: { grid: { display: false }, ticks: { font: { size: 14 } } }
                }
            });

            const sortedByGasto = [...managers].sort((a, b) => managerSummary[b].gasto - managerSummary[a].gasto);
            createOrUpdateChart('gestorInvestimentoTotalChart', 'bar', {
                labels: sortedByGasto,
                datasets: [{ label: 'Investimento Total', data: sortedByGasto.map(m => managerSummary[m].gasto), backgroundColor: '#3498db' }]
            }, horizontalBarOptions((v) => formatKilo(v)));

            const sortedByRoas = [...managers].sort((a, b) => (managerSummary[b].gasto > 0 ? managerSummary[b].receita / managerSummary[b].gasto : 0) - (managerSummary[a].gasto > 0 ? managerSummary[a].receita / managerSummary[a].gasto : 0));
            createOrUpdateChart('gestorRoasChart', 'bar', {
                labels: sortedByRoas,
                datasets: [{ label: 'ROAS Médio', data: sortedByRoas.map(m => managerSummary[m].gasto > 0 ? managerSummary[m].receita / managerSummary[m].gasto : 0), backgroundColor: '#9b59b6' }]
            }, horizontalBarOptions((v) => v.toFixed(2) + 'x'));

            const sortedByCPA = [...managers].sort((a, b) => (managerSummary[a].leads > 0 ? managerSummary[a].gasto / managerSummary[a].leads : Infinity) - (managerSummary[b].leads > 0 ? managerSummary[b].gasto / managerSummary[b].leads : Infinity));
            createOrUpdateChart('gestorCpaChart', 'bar', {
                labels: sortedByCPA,
                datasets: [{ label: 'CPA Médio', data: sortedByCPA.map(m => managerSummary[m].leads > 0 ? managerSummary[m].gasto / managerSummary[m].leads : 0), backgroundColor: '#e67e22' }]
            }, horizontalBarOptions((v) => formatCurrency(v)));
            
            const sortedByOps = [...managers].sort((a, b) => managerSummary[b].ops.size - managerSummary[a].ops.size);
            createOrUpdateChart('managerOpsCountChart', 'bar', {
                labels: sortedByOps,
                datasets: [{ label: 'Nº de Operações', data: sortedByOps.map(m => managerSummary[m].ops.size), backgroundColor: '#1abc9c' }]
            }, horizontalBarOptions((v) => v));
        }
        
        function renderAdopsCharts(data) {
            const adopsSummary = {};
            const includedData = data.filter(row => row.responsavelMonetizacao && row.responsavelMonetizacao.trim() !== "");
            includedData.forEach(row => {
                const adops = row.responsavelMonetizacao;
                if (!adopsSummary[adops]) {
                    adopsSummary[adops] = { gasto: 0, receita: 0, leads: 0, ops: new Set() };
                }
                adopsSummary[adops].gasto += row.gasto;
                adopsSummary[adops].receita += row.receita;
                adopsSummary[adops].leads += row.leads;
                adopsSummary[adops].ops.add(row.operacao); 
            });
            const adopsPersonnel = Object.keys(adopsSummary);

            const horizontalBarOptions = (formatter) => ({
                indexAxis: 'y',
                plugins: {
                    legend: { display: false },
                    datalabels: { display: true, anchor: 'end', align: 'end', color: '#555', font: { size: 12, weight: '600' }, formatter: formatter, offset: 4 }
                },
                scales: {
                    x: { grid: { display: false }, ticks: { display: false } },
                    y: { grid: { display: false }, ticks: { font: { size: 14 } } }
                }
            });

            const sortedByRevenue = [...adopsPersonnel].sort((a, b) => adopsSummary[b].receita - adopsSummary[a].receita);
            createOrUpdateChart('adopsRevenueChart', 'bar', {
                labels: sortedByRevenue,
                datasets: [{ label: 'Receita Total', data: sortedByRevenue.map(m => adopsSummary[m].receita), backgroundColor: '#2ecc71' }]
            }, horizontalBarOptions(formatCurrency));

            const sortedByInvestment = [...adopsPersonnel].sort((a, b) => adopsSummary[b].gasto - adopsSummary[a].gasto);
            createOrUpdateChart('adopsInvestmentChart', 'bar', {
                labels: sortedByInvestment,
                datasets: [{ label: 'Investimento Gerenciado', data: sortedByInvestment.map(m => adopsSummary[m].gasto), backgroundColor: '#3498db' }]
            }, horizontalBarOptions(formatCurrency));

            const sortedByRoas = [...adopsPersonnel].sort((a, b) => (adopsSummary[b].gasto > 0 ? adopsSummary[b].receita / adopsSummary[b].gasto : 0) - (adopsSummary[a].gasto > 0 ? adopsSummary[a].receita / adopsSummary[a].gasto : 0));
            createOrUpdateChart('adopsRoasChart', 'bar', {
                labels: sortedByRoas,
                datasets: [{ label: 'ROAS Médio', data: sortedByRoas.map(m => adopsSummary[m].gasto > 0 ? adopsSummary[m].receita / adopsSummary[m].gasto : 0), backgroundColor: '#9b59b6' }]
            }, horizontalBarOptions((v) => v.toFixed(2) + 'x'));

            const sortedByLeads = [...adopsPersonnel].sort((a, b) => adopsSummary[b].leads - adopsSummary[a].leads);
            createOrUpdateChart('adopsLeadsChart', 'bar', {
                labels: sortedByLeads,
                datasets: [{ label: 'Leads Gerenciados', data: sortedByLeads.map(m => adopsSummary[m].leads), backgroundColor: '#f1c40f' }]
            }, horizontalBarOptions((v) => v.toLocaleString('pt-BR')));
            
            const sortedByOps = [...adopsPersonnel].sort((a, b) => adopsSummary[b].ops.size - adopsSummary[a].ops.size);
            createOrUpdateChart('adopsOpsCountChart', 'bar', {
                labels: sortedByOps,
                datasets: [{ label: 'Nº de Operações', data: sortedByOps.map(m => adopsSummary[m].ops.size), backgroundColor: '#e74c3c' }]
            }, horizontalBarOptions((v) => v));
        }

        function renderBusinessSegmentTables(data) {
            createSegmentTable('segmentUsCcTable', SEGMENT_US_CC, data);
            createSegmentTable('segmentUsEmpTable', SEGMENT_US_EMP, data);
            createSegmentTable('segmentBrCcTable', SEGMENT_BR_CC, data);
            createSegmentTable('segmentBrEmpTable', SEGMENT_BR_EMP, data);
            createSegmentTable('segmentDeCcTable', SEGMENT_DE_CC, data);
            createSegmentTable('segmentFrCcTable', SEGMENT_FR_CC, data);
        }

        function createSegmentTable(elementId, segmentOperations, allData) {
            const segmentData = segmentOperations.map(op => {
                const rows = allData.filter(row => row.operacao === op);
                const gasto = rows.reduce((s, r) => s + r.gasto, 0);
                const receita = rows.reduce((s, r) => s + r.receita, 0);
                const leads = rows.reduce((s, r) => s + r.leads, 0);

                const roas = gasto > 0 ? receita / gasto : 0;
                const cpa = leads > 0 ? gasto / leads : 0;
                const receitaPorLead = leads > 0 ? receita / leads : 0;
                const perdaPorLead = cpa - receitaPorLead;
                const roasPercentage = (roas - 1) * 100;

                return { operacao: op, gasto, receita, leads, cpa, roasPercentage, perdaPorLead };
            });

            segmentDataCache[elementId] = segmentData;
            _renderAndAttachSortListeners(elementId, segmentData, tableSortState);
        }

        function _renderAndAttachSortListeners(elementId, dataToRender, stateObject) {
            const container = document.getElementById(elementId);
            if (!container) return;

            const currentSort = stateObject[elementId] || {};
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };
            
            const headers = [
                { key: 'operacao', label: 'Operação' },
                { key: 'gasto', label: 'Gasto' },
                { key: 'leads', label: 'Leads' },
                { key: 'cpa', label: 'CPA' },
                { key: 'roasPercentage', label: 'ROAS' },
                { key: 'perdaPorLead', label: 'Perda por Lead' }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            dataToRender.forEach(d => {
                const roasClass = d.roasPercentage >= 0 ? 'delta-positive' : 'delta-negative';
                const roasSign = d.roasPercentage >= 0 ? '+' : '';
                tableHtml += `<tr>
                    <td>${d.operacao.replace(' TOTAL', '')}</td>
                    <td>${formatCurrency(d.gasto)}</td>
                    <td>${d.leads.toLocaleString('pt-BR')}</td>
                    <td>${formatCurrency(d.cpa)}</td>
                    <td><span class="${roasClass}">${roasSign}${d.roasPercentage.toFixed(0)}%</span></td>
                    <td><span class="${d.perdaPorLead > 0 ? 'delta-negative' : 'delta-positive'}">${formatCurrency(d.perdaPorLead)}</span></td>
                </tr>`;
            });
            
            container.innerHTML = tableHtml + `</tbody></table>`;
            
            container.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    sortTable(elementId, th.dataset.sort, segmentDataCache, stateObject, _renderAndAttachSortListeners);
                });
            });
        }

        function sortTable(elementId, sortKey, cacheObject, stateObject, renderFunc) {
            const data = [...cacheObject[elementId]];
            const currentState = stateObject[elementId] || {};
            
            let defaultOrder = 'desc';
            if (['cpa', 'perdaPorLead', 'operacao'].includes(sortKey)) {
                defaultOrder = 'asc';
            }

            let nextOrder = defaultOrder;
            if (currentState.key === sortKey) {
                nextOrder = currentState.order === 'asc' ? 'desc' : 'asc';
            }

            stateObject[elementId] = { key: sortKey, order: nextOrder };

            data.sort((a, b) => {
                const valA = a[sortKey];
                const valB = b[sortKey];

                if (typeof valA === 'string') {
                    return nextOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    return nextOrder === 'asc' ? valA - valB : valB - valA;
                }
            });

            renderFunc(elementId, data, stateObject);
        }

        function renderCompanyView(data) {
            const companySummary = {};
            Object.keys(COMPANIES).forEach(prefix => {
                companySummary[prefix] = { gasto: 0, receita: 0, leads: 0, opsData: [] };
            });

            data.forEach(row => {
                const prefix = row.operacao.substring(0, row.operacao.indexOf(' ')).toUpperCase();
                if (COMPANIES[prefix]) {
                    companySummary[prefix].gasto += row.gasto;
                    companySummary[prefix].receita += row.receita;
                    companySummary[prefix].leads += row.leads;
                    companySummary[prefix].opsData.push(row);
                }
            });

            const cardsContainer = document.getElementById('company-cards-wrapper');
            cardsContainer.innerHTML = '';
            Object.entries(companySummary).forEach(([prefix, summary]) => {
                if (summary.gasto > 0) {
                    const company = COMPANIES[prefix];
                    const roas = summary.gasto > 0 ? summary.receita / summary.gasto : 0;
                    const cpa = summary.leads > 0 ? summary.gasto / summary.leads : 0;
                    
                    let companyHTML = `<div class="regional-section"><h3>${company.name}</h3><div class="summary-cards">`;
                    companyHTML += createCardHTML({ icon: '💰', title: 'Investimento Total', value: formatCurrency(summary.gasto) });
                    companyHTML += createCardHTML({ icon: '🎯', title: 'ROAS Médio', value: `${roas.toFixed(2)}x` });
                    companyHTML += createCardHTML({ icon: '💸', title: 'CPA Médio', value: formatCurrency(cpa) });
                    companyHTML += createCardHTML({ icon: '👥', title: 'Total de Leads', value: summary.leads.toLocaleString('pt-BR') });
                    companyHTML += `</div></div>`;
                    cardsContainer.innerHTML += companyHTML;
                }
            });

            const totalGastoData = Object.entries(companySummary)
                .filter(([, summary]) => summary.gasto > 0)
                .map(([prefix, summary]) => ({
                    label: COMPANIES[prefix].name,
                    value: summary.gasto,
                    color: COMPANIES[prefix].color
                }));

            if (totalGastoData.length > 0) {
                createOrUpdateChart('companyTotalGastoPieChart', 'pie', {
                    labels: totalGastoData.map(d => d.label),
                    datasets: [{
                        data: totalGastoData.map(d => d.value),
                        backgroundColor: totalGastoData.map(d => d.color)
                    }]
                }, {
                    plugins: {
                        datalabels: {
                            display: true,
                            formatter: (value, ctx) => {
                                const total = ctx.chart.getDatasetMeta(0).total;
                                return total > 0 ? (value / total * 100).toFixed(1) + '%' : '0%';
                            },
                            color: '#fff',
                            font: { weight: 'bold', size: 14 }
                        }
                    }
                });
            } else {
                if (charts['companyTotalGastoPieChart']) charts['companyTotalGastoPieChart'].destroy();
                const ctx = document.getElementById('companyTotalGastoPieChart').getContext('2d');
                if(ctx) ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            }

            updateCompanyEvolutionChart(); 

            const distributionContainer = document.getElementById('companyDistributionCharts');
            distributionContainer.innerHTML = '';
            Object.entries(companySummary).forEach(([prefix, summary]) => {
                 if (summary.gasto > 0) {
                    const company = COMPANIES[prefix];
                    const regionalSplit = { br: 0, us: 0, eu: 0 };
                    summary.opsData.forEach(row => {
                        const op = row.operacao.toUpperCase();
                        if(op.includes('BR')) regionalSplit.br += row.gasto;
                        else if(op.includes('US')) regionalSplit.us += row.gasto;
                        else if(['DE', 'FR', 'UK', 'AU'].some(c => op.includes(c))) regionalSplit.eu += row.gasto;
                    });
                    
                    const canvasId = `companyDistribution-${prefix}`;
                    const chartContainerHTML = `
                        <div class="chart-container">
                            <h2>Distribuição Regional - ${company.name}</h2>
                            <canvas id="${canvasId}"></canvas>
                        </div>`;
                    distributionContainer.innerHTML += chartContainerHTML;
                    
                    setTimeout(() => {
                        createOrUpdateChart(canvasId, 'pie', {
                            labels: ['Brasil', 'Estados Unidos', 'Europa'],
                            datasets: [{
                                label: 'Investimento',
                                data: [regionalSplit.br, regionalSplit.us, regionalSplit.eu],
                                backgroundColor: [REGION_COLORS.br.investment, REGION_COLORS.us.investment, REGION_COLORS.eu.investment]
                            }]
                        }, { plugins: { datalabels: { display: true, formatter: (v, ctx) => { const total = ctx.chart.getDatasetMeta(0).total; return total > 0 ? (v / total * 100).toFixed(1) + '%' : '0%'; }, color: '#fff' } } });
                    }, 0);
                 }
            });
        }
        
        function populateCompanyCheckboxes() {
            const container = document.getElementById('company-checkbox-group');
            if (!container) return;

            container.innerHTML = '';
            
            container.innerHTML += `<input type="checkbox" id="company-all" value="all" onchange="handleCompanySelection(this)" checked><label for="company-all">Todas</label>`;

            Object.entries(COMPANIES).forEach(([prefix, company]) => {
                container.innerHTML += `
                    <input type="checkbox" id="company-${prefix}" value="${prefix}" onchange="handleCompanySelection(this)">
                    <label for="company-${prefix}">${company.name}</label>
                `;
            });
        }
        
        function handleCompanySelection(checkbox) {
            const allCheckbox = document.getElementById('company-all');
            const companyCheckboxes = document.querySelectorAll('#company-checkbox-group input:not(#company-all)');

            if (checkbox.id === 'company-all' && checkbox.checked) {
                companyCheckboxes.forEach(cb => cb.checked = false);
            } else if (checkbox.id !== 'company-all') {
                if (Array.from(companyCheckboxes).some(cb => cb.checked)) {
                    allCheckbox.checked = false;
                }
            }
            
            if (!document.querySelector('#company-checkbox-group input:checked')) {
                allCheckbox.checked = true;
            }

            updateCompanyEvolutionChart();
        }

        function updateCompanyEvolutionChart() {
            const selectedCompanyPrefixes = Array.from(document.querySelectorAll('#company-checkbox-group input:checked')).map(cb => cb.value);
            const dataOnlyTotal = filteredData.filter(r => endsWithTOTAL(r.operacao));

            const allDates = [...new Set(dataOnlyTotal.map(r => r.data))].sort((a, b) => parseDate(a) - parseDate(b));
            
            const evolutionDatasets = [];
            const companiesToDisplay = selectedCompanyPrefixes.includes('all') ? Object.keys(COMPANIES) : selectedCompanyPrefixes;

            companiesToDisplay.forEach(prefix => {
                const company = COMPANIES[prefix];
                if (!company) return;

                const dailyData = {};
                dataOnlyTotal.filter(row => row.operacao.startsWith(prefix)).forEach(row => {
                    if (!dailyData[row.data]) dailyData[row.data] = 0;
                    dailyData[row.data] += row.gasto;
                });

                const investmentData = allDates.map(date => dailyData[date] || 0);

                if (selectedCompanyPrefixes.includes('all') && !investmentData.some(val => val > 0)) {
                    return;
                }
                
                evolutionDatasets.push({
                    label: company.name,
                    data: investmentData,
                    borderColor: company.color,
                    backgroundColor: hexToRgba(company.color, 0.1),
                    fill: false,
                    tension: 0.4
                });
            });
            
            createOrUpdateChart('companyEvolutionChart', 'line', { labels: allDates, datasets: evolutionDatasets });
        }


        // --- Funções para a aba de Metas (ATUALIZADAS) ---
        
        function renderMetasView(data, allFilteredData) {
            if (data.length === 0) return;
            
            const allDates = [...new Set(data.map(d => d.data))].filter(Boolean).sort((a,b) => parseDate(b) - parseDate(a));
            const lastDateStr = allDates[0];
            const dayBeforeLastDateStr = allDates[1];

            const ontemData = data.filter(d => d.data === lastDateStr);
            const diaAnteriorData = dayBeforeLastDateStr ? data.filter(d => d.data === dayBeforeLastDateStr) : [];

            const totalPeriodDataByOp = {};
             data.forEach(row => {
                const goalKey = getGoalKeyFromOperation(row.operacao);
                if (!goalKey) return;
                if (!totalPeriodDataByOp[goalKey]) totalPeriodDataByOp[goalKey] = { gasto: 0, receita: 0 };
                totalPeriodDataByOp[goalKey].gasto += row.gasto;
                totalPeriodDataByOp[goalKey].receita += row.receita;
            });
            
            const mergedData = [];
            const activeGoals = Object.entries(GOALS_DATA).filter(([,goal]) => goal.investimento > 0);

            activeGoals.forEach(([goalKey, goal]) => {
                const matchingOpsOntem = ontemData.filter(row => getGoalKeyFromOperation(row.operacao) === goalKey);
                const gastoOntem = matchingOpsOntem.reduce((sum, r) => sum + r.gasto, 0);
                const receitaOntem = matchingOpsOntem.reduce((sum, r) => sum + r.receita, 0);

                const matchingOpsDiaAnterior = diaAnteriorData.filter(row => getGoalKeyFromOperation(row.operacao) === goalKey);
                const gastoDiaAnterior = matchingOpsDiaAnterior.reduce((sum, r) => sum + r.gasto, 0);

                const totalData = totalPeriodDataByOp[goalKey] || {gasto: 0, receita: 0};
                const roasMedioTotal = totalData.gasto > 0 ? totalData.receita / totalData.gasto : 0;
                const roasOntem = gastoOntem > 0 ? receitaOntem / gastoOntem : 0;

                const progressoInvest = (goal.investimento > 0) ? (gastoOntem / goal.investimento) * 100 : 0;
                const progressoDiaAnterior = (goal.investimento > 0) ? (gastoDiaAnterior / goal.investimento) * 100 : 0;
                const diffProgresso = progressoInvest - progressoDiaAnterior;

                mergedData.push({
                    operacao: goalKey,
                    atualInvestimento: gastoOntem,
                    metaInvestimento: goal.investimento,
                    progressoInvest: progressoInvest,
                    gapInvestimento: goal.investimento - gastoOntem,
                    atualRoas: roasOntem,
                    metaRoas: goal.roas,
                    diffRoas: (roasOntem - goal.roas) * 100,
                    roasMedioTotal: roasMedioTotal,
                    diffProgresso: diffProgresso
                });
            });
            
            segmentDataCache['metas-detailed-table'] = mergedData;
            
            const gastoTotalOntem = ontemData.reduce((sum, item) => sum + item.gasto, 0);
            const totalMeta = mergedData.reduce((sum, item) => sum + item.metaInvestimento, 0);
            const progressoTotal = totalMeta > 0 ? (gastoTotalOntem / totalMeta) * 100 : 0;
            
            document.getElementById('metas-kpi-cards').innerHTML = createCardHTML({
                icon: '💰', title: `Progresso Meta Diária (${lastDateStr || 'N/A'})`, value: `${progressoTotal.toFixed(1)}%`,
                footerHTML: `<div class="progress-bar"><div class="progress-bar-inner" style="width: ${Math.min(progressoTotal, 100)}%;"></div></div> 
                               <div style="font-size: 0.9em; color: var(--text-light); margin-top: 5px;">${formatCurrency(gastoTotalOntem)} de ${formatCurrency(totalMeta)}</div>`
            });

            _renderAndAttachSortListenersForMetasTable('metas-detailed-table', mergedData);

            renderDailyGoalProgressionTable(gastoTotalOntem, mergedData);
            
            renderSprint1MCard(allFilteredData, gastoTotalOntem);
            renderSprint1MTable(allFilteredData, ontemData);
        }
        
        function _renderAndAttachSortListenersForMetasTable(elementId, dataToRender) {
             const container = document.getElementById(elementId);
            if (!container) return;

            const currentSort = metasTableSortState[elementId] || {};
            const getSortIndicator = (key) => {
                if (currentSort.key !== key) return '⇅';
                return currentSort.order === 'desc' ? '▼' : '▲';
            };
            
            const headers = [
                { key: 'operacao', label: 'Operação' },
                { key: 'atualInvestimento', label: 'Investimento de Ontem' },
                { key: 'metaInvestimento', label: 'Meta Diária' },
                { key: 'progressoInvest', label: 'Progresso', style: 'min-width: 180px;' },
                { key: 'diffProgresso', label: 'Status Investimento' },
                { key: 'gapInvestimento', label: 'Gap (R$)' },
                { key: 'atualRoas', label: 'ROAS de Ontem' },
                { key: 'roasMedioTotal', label: 'ROAS Médio Total' },
                { key: 'metaRoas', label: 'Meta ROAS' },
                { key: 'diffRoas', label: 'Status ROAS' }
            ];

            let tableHtml = `<table class="performance-table"><thead><tr>`;
            headers.forEach(h => {
                tableHtml += `<th class="sortable" data-sort="${h.key}" style="${h.style || ''}">${h.label} <span class="sort-indicator">${getSortIndicator(h.key)}</span></th>`;
            });
            tableHtml += `</tr></thead><tbody>`;

            dataToRender.forEach(d => {
                const progresso = Math.min(d.progressoInvest, 100);
                const roasClass = d.diffRoas >= 0 ? 'delta-positive' : 'delta-negative';
                const roasSign = d.diffRoas >= 0 ? '+' : '';

                const statusInvestClass = d.diffProgresso >= 0 ? 'delta-positive' : 'delta-negative';
                const statusInvestSign = d.diffProgresso > 0 ? '+' : '';
                const statusInvestText = !isNaN(d.diffProgresso) ? `${statusInvestSign}${d.diffProgresso.toFixed(1)} p.p.` : '-';


                tableHtml += `<tr>
                    <td>${d.operacao}</td>
                    <td>${formatCurrency(d.atualInvestimento)}</td>
                    <td>${formatCurrency(d.metaInvestimento)}</td>
                    <td>
                        <div class="progress-bar-container">
                            <div class="progress-bar">
                                <div class="progress-bar-inner" style="width: ${progresso}%;"></div>
                            </div>
                            <span class="progress-percent">${d.progressoInvest.toFixed(0)}%</span>
                        </div>
                    </td>
                    <td><span class="${statusInvestClass}">${statusInvestText}</span></td>
                    <td>${formatCurrency(d.gapInvestimento)}</td>
                    <td>${(d.atualRoas * 100).toFixed(0)}%</td>
                    <td>${(d.roasMedioTotal * 100).toFixed(0)}%</td>
                    <td>${(d.metaRoas * 100).toFixed(0)}%</td>
                    <td><span class="${roasClass}">${roasSign}${d.diffRoas.toFixed(1)} p.p.</span></td>
                </tr>`;
            });
            
            container.innerHTML = tableHtml + `</tbody></table>`;
            
            container.querySelectorAll('.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    sortTable(elementId, th.dataset.sort, segmentDataCache, metasTableSortState, _renderAndAttachSortListenersForMetasTable);
                });
            });
        }
        
        function renderDailyGoalProgressionTable(gastoTotalOntem, metasData) {
            const container = document.getElementById('metas-acceleration-table');
            if (!container) return;

            const totalMetaDiariaOriginal = metasData.reduce((sum, item) => sum + item.metaInvestimento, 0);

            const cenarios = [
                { label: 'Cenário 1M/dia', target: 1000000 },
                { label: 'Cenário 1.5M/dia', target: 1500000 },
                { label: 'Cenário 2M/dia', target: 2000000 },
                { label: 'Cenário 2.5M/dia', target: 2500000 }
            ];

            let tableHTML = `<table class="performance-table acceleration-table">`;
            
            tableHTML += `<thead><tr>
                <th rowspan="2" style="min-width: 200px;">Operação</th>
                <th rowspan="2">Gasto de Ontem</th>
                <th rowspan="2">Meta Original</th>`;
            cenarios.forEach((c, index) => {
                tableHTML += `<th colspan="2" class="${index === 0 ? 'scenario-group-start' : ''}">${c.label}</th>`;
            });
            tableHTML += `</tr>`;

            tableHTML += `<tr>`;
            cenarios.forEach((c, index) => {
                tableHTML += `<th class="${index === 0 ? 'scenario-group-start' : ''}">Gasto Alvo</th><th>Acréscimo</th>`;
            });
            tableHTML += `</tr></thead>`;

            tableHTML += `<tbody>`;
            metasData.forEach(op => {
                tableHTML += `<tr>
                    <td>${op.operacao}</td>
                    <td>${formatCurrency(op.atualInvestimento)}</td>
                    <td>${formatCurrency(op.metaInvestimento)}</td>`;
                
                cenarios.forEach((c, index) => {
                    const gapGlobal = c.target - gastoTotalOntem;
                    const groupClass = index === 0 ? 'scenario-group-start' : '';

                    if (gapGlobal <= 0) {
                        tableHTML += `<td class="delta-positive ${groupClass}">Atingido</td><td>-</td>`;
                    } else {
                        const peso = (totalMetaDiariaOriginal > 0) ? op.metaInvestimento / totalMetaDiariaOriginal : 0;
                        const acrescimo = gapGlobal * peso;
                        const gastoAlvo = op.atualInvestimento + acrescimo;
                        tableHTML += `<td class="${groupClass}">${formatCurrency(gastoAlvo)}</td>
                                      <td class="delta-negative acrescimo-cell"><span>+${formatCurrency(acrescimo)}</span></td>`;
                    }
                });
                tableHTML += `</tr>`;
            });

            container.innerHTML = tableHTML + '</tbody></table>';
        }

        // --- FUNÇÕES DA META SPRINT 1M (LÓGICA CORRIGIDA E REFINADA) ---

        function renderSprint1MCard(allFilteredData, gastoTotalOntem) {
            const container = document.getElementById('sprint-kpi-cards');
            if (!container) return;

            const progress = SPRINT_1M_GOAL > 0 ? (gastoTotalOntem / SPRINT_1M_GOAL) * 100 : 0;
            
            container.innerHTML = createCardHTML({
                icon: '🚀', title: `Progresso Sprint 1M (até ${formatDate(SPRINT_1M_DEADLINE, true)})`, value: `${progress.toFixed(1)}%`,
                footerHTML: `<div class="progress-bar"><div class="progress-bar-inner" style="width: ${Math.min(progress, 100)}%;"></div></div> 
                               <div style="font-size: 0.9em; color: var(--text-light); margin-top: 5px;">${formatCurrency(gastoTotalOntem)} de ${formatCurrency(SPRINT_1M_GOAL)}</div>`
            });
        }

        function renderSprint1MTable(allFilteredData, ontemData) {
            const container = document.getElementById('sprint-1m-table');
            if (!container) return;
            
            const today = new Date();
            today.setUTCHours(0,0,0,0);
            const daysRemaining = Math.max(1, (SPRINT_1M_DEADLINE.getTime() - today.getTime()) / (1000 * 60 * 60 * 24) + 1);

            const opMetrics = {};
            const sprintOperations = SPRINT_1M_BASE_OPERATIONS.filter(opKey => !SPRINT_1M_RULES[opKey]?.exclude);
            
            sprintOperations.forEach(opKey => {
                const opData = allFilteredData.filter(row => getGoalKeyFromOperation(row.operacao) === opKey);
                const totalGasto = opData.reduce((sum, r) => sum + r.gasto, 0);
                const totalReceita = opData.reduce((sum, r) => sum + r.receita, 0);
                const gastoOntem = ontemData.filter(row => getGoalKeyFromOperation(row.operacao) === opKey).reduce((sum, r) => sum + r.gasto, 0);
                opMetrics[opKey] = { roas: totalGasto > 0 ? totalReceita / totalGasto : 0, gastoOntem: gastoOntem };
            });

            const gastoTotalOntem = ontemData.reduce((sum, r) => sum + r.gasto, 0);
            let totalGapParaAcelerar = SPRINT_1M_GOAL - gastoTotalOntem;
            
            const tableData = [];
            let totalIncrementoFixo = 0;

            sprintOperations.forEach(opKey => {
                const rule = SPRINT_1M_RULES[opKey];
                if (rule) {
                    let incrementoDiario = 0;
                    let metaDiariaFinal = 0;
                    if (rule.finalTarget) {
                        metaDiariaFinal = rule.finalTarget;
                        const gap = metaDiariaFinal - opMetrics[opKey].gastoOntem;
                        incrementoDiario = gap / daysRemaining;
                    } else if (rule.target) {
                        metaDiariaFinal = rule.target;
                        const gap = metaDiariaFinal - opMetrics[opKey].gastoOntem;
                        incrementoDiario = gap > 0 ? gap / daysRemaining : 0;
                    }
                    totalIncrementoFixo += incrementoDiario;
                    tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal, incrementoDiario });
                }
            });
            
            const gapParaDistribuir = (totalGapParaAcelerar / daysRemaining) - totalIncrementoFixo;
            const opsParaDistribuir = sprintOperations.filter(opKey => !SPRINT_1M_RULES[opKey] && opMetrics[opKey].roas > 0.9);
            const pesoTotal = opsParaDistribuir.reduce((sum, opKey) => sum + (GOALS_DATA[opKey]?.investimento || 50000), 0);

            opsParaDistribuir.forEach(opKey => {
                const peso = (GOALS_DATA[opKey]?.investimento || 50000) / pesoTotal;
                const incrementoDiario = gapParaDistribuir > 0 ? gapParaDistribuir * peso : 0;
                const metaDiariaFinal = opMetrics[opKey].gastoOntem + (incrementoDiario * daysRemaining);
                tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal, incrementoDiario });
            });
            
            sprintOperations.forEach(opKey => {
                if (!tableData.find(d => d.operacao === opKey)) {
                     tableData.push({ operacao: opKey, ...opMetrics[opKey], metaDiariaFinal: opMetrics[opKey].gastoOntem, incrementoDiario: 0 });
                }
            });

            const dateHeaders = Array.from({ length: daysRemaining }, (_, i) => { const d = new Date(today); d.setUTCDate(today.getUTCDate() + i); return d; });
            const dailySpendByOp = allFilteredData.reduce((acc, row) => { const key = getGoalKeyFromOperation(row.operacao); if (key) { if (!acc[key]) acc[key] = {}; acc[key][row.data] = (acc[key][row.data] || 0) + row.gasto; } return acc; }, {});

            let tableHTML = `<table class="performance-table sprint-table"><thead><tr>
                <th>Operação</th><th>Gasto Ontem</th><th>Meta Diária Final</th><th>Gap p/ Meta</th><th>Incremento Diário</th>`;
            dateHeaders.forEach(d => tableHTML += `<th>${formatDate(d, true)}</th>`);
            tableHTML += `</tr></thead><tbody>`;

            tableData.sort((a, b) => sprintOperations.indexOf(a.operacao) - sprintOperations.indexOf(b.operacao));

            tableData.forEach(d => {
                const gap = d.metaDiariaFinal - d.gastoOntem;
                tableHTML += `<tr>
                    <td>${d.operacao}</td><td>${formatCurrency(d.gastoOntem)}</td>
                    <td style="font-weight:bold;">${formatCurrency(d.metaDiariaFinal)}</td>
                    <td class="${gap >= 0 ? 'delta-negative' : 'delta-positive'}">${formatCurrency(gap)}</td>
                    <td style="font-style: italic; color: ${d.incrementoDiario >= 0 ? 'var(--color-negative)' : 'var(--color-positive)'};">${d.incrementoDiario >= 0 ? '+' : ''}${formatCurrency(d.incrementoDiario)}</td>`;
                
                dateHeaders.forEach((date, i) => {
                    const plannedSpend = d.gastoOntem + (d.incrementoDiario * (i + 1));
                    const actualSpend = dailySpendByOp[d.operacao]?.[formatDate(date)];
                    
                    if (actualSpend !== undefined) {
                        const performanceClass = actualSpend >= plannedSpend ? 'delta-positive' : 'delta-negative';
                        const progressPct = plannedSpend > 0.01 ? (actualSpend / plannedSpend * 100).toFixed(0) : 100;
                        tableHTML += `<td>
                            <div class="daily-cell ${performanceClass}">
                                <div>Real: ${formatCurrency(actualSpend)} (${progressPct}%)</div>
                                <div>Planj: ${formatCurrency(plannedSpend)}</div>
                            </div></td>`;
                    } else {
                        tableHTML += `<td><div class="daily-cell"><div>Planj: ${formatCurrency(plannedSpend)}</div></div></td>`;
                    }
                });
                tableHTML += `</tr>`;
            });

            tableHTML += `</tbody><tfoot><tr><td>Total</td>`;
            const footerTotals = {
                gastoOntem: tableData.reduce((s, d) => s + d.gastoOntem, 0),
                metaDiariaFinal: tableData.reduce((s, d) => s + d.metaDiariaFinal, 0),
                gap: tableData.reduce((s, d) => s + (d.metaDiariaFinal - d.gastoOntem), 0),
                incrementoDiario: tableData.reduce((s, d) => s + d.incrementoDiario, 0)
            };
            tableHTML += `<td>${formatCurrency(footerTotals.gastoOntem)}</td>
                          <td>${formatCurrency(footerTotals.metaDiariaFinal)}</td>
                          <td>${formatCurrency(footerTotals.gap)}</td>
                          <td>+${formatCurrency(footerTotals.incrementoDiario)}</td>`;
            
            dateHeaders.forEach((date, i) => {
                const totalPlanned = tableData.reduce((s, d) => s + (d.gastoOntem + (d.incrementoDiario * (i + 1))), 0);
                const totalActual = sprintOperations.reduce((s, opKey) => s + (dailySpendByOp[opKey]?.[formatDate(date)] || 0), 0);
                 if (totalActual > 0) {
                     tableHTML += `<td>${formatCurrency(totalActual)}</td>`;
                 } else {
                     tableHTML += `<td>${formatCurrency(totalPlanned)}</td>`;
                 }
            });
            tableHTML += `</tr></tfoot>`;

            container.innerHTML = tableHTML + `</table>`;
        }


        function setupMetricToggle() { const toggleButtons = document.querySelectorAll('#metric-toggle .toggle-btn'); toggleButtons.forEach(btn => { btn.addEventListener('click', function () { if (this.classList.contains('active')) return; toggleButtons.forEach(b => b.classList.remove('active')); this.classList.add('active'); updateProportionCharts(); }); }); }
        function populateEvolutionFilters(data, selectedValue = 'all') { const operationFilter = document.getElementById('evolutionOperationFilter'); if (!operationFilter) return; const currentSelection = selectedValue || operationFilter.value; const operations = [...new Set(data.map(r => r.operacao))].sort(); operationFilter.innerHTML = '<option value="all">Todas as Operações</option>'; operations.forEach(op => { const option = document.createElement('option'); option.value = op; option.textContent = op.replace(' TOTAL', ''); operationFilter.appendChild(option); }); if (operations.includes(currentSelection)) { operationFilter.value = currentSelection; } else { operationFilter.value = 'all'; } }
        function setupNavbar() { const navButtons = document.querySelectorAll('.nav-btn'); const viewSections = document.querySelectorAll('.view-section'); navButtons.forEach(button => { button.addEventListener('click', () => { const targetId = button.dataset.target; const targetSection = document.getElementById(targetId); navButtons.forEach(btn => btn.classList.remove('active')); button.classList.add('active'); viewSections.forEach(section => { section.classList.toggle('active', section.id === targetId); }); 
                if (targetSection && targetSection.classList.contains('active')) {
                    setTimeout(() => {
                        const canvases = targetSection.querySelectorAll('canvas');
                        canvases.forEach(canvas => {
                            const chartInstance = charts[canvas.id];
                            if (chartInstance) {
                                chartInstance.resize();
                            }
                        });
                    }, 10);
                }
            }); 
        }); }

        window.addEventListener('load', () => {
            loadData();
            setupMetricToggle();
            setupNavbar();
        });
    </script>
</body>
</html>
